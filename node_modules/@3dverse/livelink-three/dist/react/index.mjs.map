{
  "version": 3,
  "sources": ["../../sources/react/ThreeOverlayProvider.tsx", "../../sources/ThreeOverlay.ts", "../../sources/react/TransformControls.tsx"],
  "sourcesContent": ["//------------------------------------------------------------------------------\nimport React from \"react\";\nimport { createContext, PropsWithChildren, useContext, useEffect, useState } from \"react\";\nimport { ViewportContext } from \"@3dverse/livelink-react\";\nimport type * as THREE from \"three\";\n\nimport { ThreeOverlay } from \"../ThreeOverlay\";\n\n//------------------------------------------------------------------------------\nexport const ThreeOverlayContext = createContext<{\n    overlay: ThreeOverlay | null;\n}>({\n    overlay: null,\n});\n\n//------------------------------------------------------------------------------\nfunction ThreeOverlayProvider({ scene, children }: PropsWithChildren<{ scene: THREE.Scene }>) {\n    const { viewport, camera } = useContext(ViewportContext);\n    const [overlay, setOverlay] = useState<ThreeOverlay | null>(null);\n\n    useEffect(() => {\n        if (!viewport || !camera) {\n            setOverlay(null);\n            return;\n        }\n\n        const overlay = new ThreeOverlay({ viewport_camera_projection: camera, scene });\n        viewport.addOverlay({ overlay });\n        setOverlay(overlay);\n\n        return () => {\n            viewport.removeOverlay({ overlay });\n        };\n    }, [viewport, camera]);\n\n    return <ThreeOverlayContext.Provider value={{ overlay }}>{children}</ThreeOverlayContext.Provider>;\n}\n\n//------------------------------------------------------------------------------\nexport { ThreeOverlayProvider as ThreeOverlay };\n", "import * as THREE from \"three\";\nimport type {\n    CameraProjection,\n    Components,\n    Entity,\n    EntityUpdatedEvent,\n    OverlayInterface,\n    Viewport,\n} from \"@3dverse/livelink\";\n\n/**\n *\n */\nexport class ThreeOverlay implements OverlayInterface {\n    /**\n     *\n     */\n    #scene: THREE.Scene = new THREE.Scene();\n\n    /**\n     *\n     */\n    #camera: THREE.Camera;\n\n    /**\n     *\n     */\n    #viewport: Viewport;\n\n    /**\n     *\n     */\n    #renderer: THREE.WebGLRenderer;\n\n    /**\n     *\n     */\n    #offscreenCanvas: OffscreenCanvas;\n\n    /**\n     *\n     */\n    #event_abort_controller: AbortController = new AbortController();\n\n    /**\n     *\n     */\n    constructor({\n        viewport_camera_projection,\n        scene,\n    }: {\n        viewport_camera_projection: CameraProjection;\n        scene: THREE.Scene;\n    }) {\n        this.#scene = scene;\n        this.#viewport = viewport_camera_projection.viewport;\n        this.#offscreenCanvas = new OffscreenCanvas(this.#viewport.width, this.#viewport.height);\n        const context = this.#offscreenCanvas.getContext(\"webgl2\");\n        if (!context) {\n            throw new Error(\"Cannot create a WebGL2 context\");\n        }\n\n        this.#renderer = new THREE.WebGLRenderer({ context, canvas: this.#offscreenCanvas });\n\n        this.#renderer.setClearColor(0xffffff, 0);\n        this.#renderer.setPixelRatio(1);\n        this.#renderer.setSize(this.#viewport.width, this.#viewport.height, false);\n\n        this.#camera = this.#setupCameraProjection();\n    }\n\n    /**\n     *\n     */\n    get camera(): Readonly<THREE.Camera> {\n        return this.#camera;\n    }\n\n    /**\n     *\n     */\n    get scene() {\n        return this.#scene;\n    }\n\n    /**\n     * Create a THREE.Camera from the camera_projection component of the viewport,\n     */\n    #setupCameraProjection(): THREE.Camera {\n        const cameraEntity = this.#viewport.camera_projection?.camera_entity;\n        if (!cameraEntity) {\n            throw new Error(\"Viewport has no camera_projection\");\n        }\n\n        const perspective_lens = cameraEntity.perspective_lens;\n        const orthographic_lens = cameraEntity.orthographic_lens;\n\n        // Unregister the previous entity update handlers.\n        this.#event_abort_controller.abort();\n        this.#event_abort_controller = new AbortController();\n\n        if (perspective_lens) {\n            this.#camera = this.#setupPerspectiveLens({ cameraEntity, perspective_lens });\n        } else if (orthographic_lens) {\n            this.#camera = this.#setupOrthographicLens({ cameraEntity, orthographic_lens });\n        } else {\n            throw new Error(\"Camera entity has no perspective_lens or orthographic_lens component\");\n        }\n\n        this.#camera.matrixAutoUpdate = false;\n        return this.#camera;\n    }\n\n    /**\n     * Create a THREE.PerspectiveCamera from a perspective_lens component,\n     * and update it when the perspective_lens component is updated.\n     * Whenever the perspective_lens component is deleted, #setupCameraProjection is called\n     * to re-create the camera.\n     */\n    #setupPerspectiveLens({\n        cameraEntity,\n        perspective_lens,\n    }: {\n        cameraEntity: Entity;\n        perspective_lens: Components.PerspectiveLens;\n    }): THREE.PerspectiveCamera {\n        const perspectiveCamera = new THREE.PerspectiveCamera();\n        const INFINITE_FAR_VALUE = 100000;\n\n        const applyLens = (perspective_lens: Components.PerspectiveLens) => {\n            perspectiveCamera.aspect = this.#viewport.aspect_ratio;\n            perspectiveCamera.fov = perspective_lens.fovy;\n            perspectiveCamera.near = perspective_lens.nearPlane;\n            perspectiveCamera.far = perspective_lens.farPlane || INFINITE_FAR_VALUE;\n        };\n\n        const entity_update_handler = (event: EntityUpdatedEvent) => {\n            if (event.deleted_components.includes(\"perspective_lens\")) {\n                this.#setupCameraProjection();\n                return;\n            }\n\n            if (event.updated_components.includes(\"perspective_lens\")) {\n                applyLens(cameraEntity.perspective_lens!);\n            }\n        };\n\n        cameraEntity.addEventListener(\"on-entity-updated\", entity_update_handler, {\n            signal: this.#event_abort_controller.signal,\n        });\n\n        applyLens(perspective_lens);\n        return perspectiveCamera;\n    }\n\n    /**\n     * Create a THREE.OrthographicCamera from an orthographic_lens component,\n     * and update it when the orthographic_lens component is updated.\n     * Whenever the orthographic_lens component is deleted, #setupCameraProjection is called\n     * to re-create the camera.\n     */\n    #setupOrthographicLens({\n        cameraEntity,\n        orthographic_lens,\n    }: {\n        cameraEntity: Entity;\n        orthographic_lens: Components.OrthographicLens;\n    }): THREE.OrthographicCamera {\n        const orthographicCamera = new THREE.OrthographicCamera();\n\n        const applyLens = (orthographic_lens: Components.OrthographicLens) => {\n            orthographicCamera.left = -this.#viewport.aspect_ratio * orthographic_lens.zoomFactor[0];\n            orthographicCamera.right = this.#viewport.aspect_ratio * orthographic_lens.zoomFactor[0];\n            orthographicCamera.top = -orthographic_lens.zoomFactor[1];\n            orthographicCamera.bottom = orthographic_lens.zoomFactor[1];\n            orthographicCamera.near = orthographic_lens.zNear;\n            orthographicCamera.far = orthographic_lens.zFar;\n        };\n\n        const entity_update_handler = (event: EntityUpdatedEvent) => {\n            if (event.deleted_components.includes(\"orthographic_lens\")) {\n                this.#setupCameraProjection();\n                return;\n            }\n\n            if (event.updated_components.includes(\"orthographic_lens\")) {\n                applyLens(cameraEntity.orthographic_lens!);\n            }\n        };\n\n        cameraEntity.addEventListener(\"on-entity-updated\", entity_update_handler, {\n            signal: this.#event_abort_controller.signal,\n        });\n\n        applyLens(orthographic_lens);\n        return orthographicCamera;\n    }\n\n    /**\n     *\n     */\n    draw({ output_canvas }: { output_canvas: OffscreenCanvas | null }): OffscreenCanvas | null {\n        const viewport_camera_projection = this.#viewport.camera_projection;\n        if (!viewport_camera_projection) {\n            return null;\n        }\n\n        this.#drawFrameForCamera({ viewport_camera_projection });\n\n        if (output_canvas) {\n            throw new Error(\"Not implemented\");\n        }\n\n        return this.#offscreenCanvas;\n    }\n\n    /**\n     *\n     */\n    #drawFrameForCamera({ viewport_camera_projection }: { viewport_camera_projection: CameraProjection }) {\n        // Here we MUST NOT use the transform of the camera entity, but the one from the camera projection.\n        this.#camera.position.fromArray(viewport_camera_projection.world_position);\n        this.#camera.quaternion.fromArray(viewport_camera_projection.world_orientation);\n        this.#camera.updateMatrix();\n        this.#camera.projectionMatrix.fromArray(viewport_camera_projection.clip_from_view_matrix);\n        this.#camera.projectionMatrixInverse.fromArray(viewport_camera_projection.view_from_clip_matrix);\n\n        this.#renderer.setViewport(0, 0, this.#viewport.width, this.#viewport.height);\n        this.#renderer.render(this.#scene, this.#camera);\n    }\n\n    /**\n     *\n     */\n    resize({ width, height }: { width: number; height: number }): void {\n        this.#offscreenCanvas.width = width;\n        this.#offscreenCanvas.height = height;\n        this.#renderer.setSize(width, height, false);\n    }\n\n    /**\n     *\n     */\n    release() {\n        this.#event_abort_controller.abort();\n        this.#renderer.dispose();\n    }\n}\n", "import { forwardRef, type Ref, useContext, useEffect, useImperativeHandle, useMemo, useState } from \"react\";\nimport * as THREE from \"three\";\nimport { ViewportContext } from \"@3dverse/livelink-react\";\n\nimport type { CameraController, Entity, EntityUpdatedEvent } from \"@3dverse/livelink\";\nimport type {\n    TransformControls as TransformController,\n    TransformControlsEventMap,\n} from \"../types/ThreeTransformControls\";\n\nimport { ThreeOverlayContext } from \"./ThreeOverlayProvider\";\n\n//------------------------------------------------------------------------------\nexport function TransformControlsComponent(\n    {\n        controlledEntity,\n        cameraController,\n        setDragging,\n    }: {\n        controlledEntity: Entity | null;\n        cameraController: CameraController | null;\n        setDragging?: (isDragging: boolean) => void;\n    },\n    ref: Ref<TransformController | undefined>,\n) {\n    const { overlay } = useContext(ThreeOverlayContext);\n    const { viewport } = useContext(ViewportContext);\n    const transformControlsModule = useTransformControlsModule();\n\n    const anchorObject = useMemo(() => new THREE.Object3D(), []);\n    const [controls, setControls] = useState<TransformController | undefined>(undefined);\n\n    useImperativeHandle(ref, () => controls, [controls]);\n\n    //--------------------------------------------------------------------------\n    useEffect(() => {\n        if (!viewport || !overlay || !cameraController || !transformControlsModule) {\n            return;\n        }\n\n        const controls = new transformControlsModule.TransformControls(overlay.camera, viewport.dom_element);\n\n        const redrawHandler = function () {\n            viewport.rendering_surface.redrawLastFrame();\n        };\n\n        viewport.dom_element.addEventListener(\"pointermove\", redrawHandler);\n\n        setControls(controls);\n        overlay.scene.add(controls.getHelper());\n\n        return () => {\n            viewport.dom_element.removeEventListener(\"pointermove\", redrawHandler);\n            overlay.scene.remove(controls.getHelper());\n            controls.dispose();\n        };\n    }, [viewport, overlay, cameraController, transformControlsModule]);\n\n    //--------------------------------------------------------------------------\n    useEffect(() => {\n        if (!controls || !cameraController) {\n            return;\n        }\n\n        const handler = function (event: TransformControlsEventMap[\"dragging-changed\"]) {\n            const value = Boolean(event.value);\n            cameraController.enabled = !value;\n            if (setDragging) {\n                setTimeout(() => setDragging(value), 0);\n            }\n        };\n\n        controls.addEventListener(\"dragging-changed\", handler);\n        return () => {\n            controls.removeEventListener(\"dragging-changed\", handler);\n        };\n    }, [controls, cameraController, setDragging]);\n\n    //--------------------------------------------------------------------------\n    useEffect(() => {\n        if (!controlledEntity || !controls || !overlay) {\n            return;\n        }\n\n        overlay.scene.add(anchorObject);\n        controls.attach(anchorObject);\n\n        let isDragging = false;\n\n        const controlsListener = function () {\n            controlledEntity.global_transform.position = controls.object.position.toArray();\n            controls.object.quaternion.toArray(controlledEntity.global_transform.orientation);\n            controlledEntity.global_transform = {\n                scale: controls.object.scale.toArray(),\n            };\n        };\n\n        const draggingChangedHandler = function (event: TransformControlsEventMap[\"dragging-changed\"]) {\n            isDragging = Boolean(event.value);\n        };\n\n        controls.addEventListener(\"dragging-changed\", draggingChangedHandler);\n\n        const entityUpdateHandler = function (event: EntityUpdatedEvent) {\n            if (event.updated_components.includes(\"local_transform\") && !isDragging) {\n                applyEntityTransform();\n            }\n        };\n\n        const applyEntityTransform = function () {\n            anchorObject.position.fromArray(controlledEntity.global_transform.position);\n            anchorObject.quaternion.fromArray(controlledEntity.global_transform.orientation);\n            anchorObject.scale.fromArray(controlledEntity.global_transform.scale);\n            anchorObject.updateMatrixWorld();\n        };\n\n        controls.addEventListener(\"objectChange\", controlsListener);\n\n        // Listen for changes on the controlled entity and its parents\n        const abortController = new AbortController();\n        let entity: Entity | null = controlledEntity;\n        while (entity) {\n            entity.addEventListener(\"on-entity-updated\", entityUpdateHandler, { signal: abortController.signal });\n            entity = entity.parent;\n        }\n\n        applyEntityTransform();\n\n        return () => {\n            overlay.scene.remove(anchorObject);\n            controls.removeEventListener(\"objectChange\", controlsListener);\n            controls.removeEventListener(\"dragging-changed\", draggingChangedHandler);\n            abortController.abort();\n            controls.detach();\n        };\n    }, [overlay, controlledEntity, controls, anchorObject]);\n\n    return null;\n}\n\n//------------------------------------------------------------------------------\ntype TransformControlsModule = {\n    TransformControls: new (camera: THREE.Camera, domElement: HTMLElement) => TransformController;\n};\n\n//------------------------------------------------------------------------------\n/**\n * Since the Three.js TransformControls module is only exported as an es module,\n * we need to use dynamic imports to load it.\n */\nconst useTransformControlsModule = () => {\n    const [transformControlsModule, setTransformControlsModule] = useState<TransformControlsModule | undefined>(\n        undefined,\n    );\n\n    useEffect(() => {\n        import(\"three/addons/controls/TransformControls.js\").then(setTransformControlsModule);\n    }, []);\n\n    return transformControlsModule;\n};\n\n//------------------------------------------------------------------------------\nconst TransformControlsComponentWithRef = forwardRef(TransformControlsComponent);\nexport { TransformControlsComponentWithRef as TransformControls };\nexport type { TransformController };\n"],
  "mappings": "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",
  "names": ["React", "createContext", "useContext", "useEffect", "useState", "ViewportContext", "THREE", "ThreeOverlay", "#scene", "#camera", "#viewport", "#renderer", "#offscreenCanvas", "#event_abort_controller", "viewport_camera_projection", "scene", "context", "#setupCameraProjection", "cameraEntity", "perspective_lens", "orthographic_lens", "#setupPerspectiveLens", "#setupOrthographicLens", "perspectiveCamera", "INFINITE_FAR_VALUE", "applyLens", "entity_update_handler", "event", "orthographicCamera", "output_canvas", "#drawFrameForCamera", "width", "height", "ThreeOverlayContext", "createContext", "ThreeOverlayProvider", "scene", "children", "viewport", "camera", "useContext", "ViewportContext", "overlay", "setOverlay", "useState", "useEffect", "ThreeOverlay", "React", "forwardRef", "useContext", "useEffect", "useImperativeHandle", "useMemo", "useState", "THREE", "ViewportContext", "TransformControlsComponent", "controlledEntity", "cameraController", "setDragging", "ref", "overlay", "useContext", "ThreeOverlayContext", "viewport", "ViewportContext", "transformControlsModule", "useTransformControlsModule", "anchorObject", "useMemo", "controls", "setControls", "useState", "useImperativeHandle", "useEffect", "redrawHandler", "handler", "event", "value", "isDragging", "controlsListener", "draggingChangedHandler", "entityUpdateHandler", "applyEntityTransform", "abortController", "entity", "setTransformControlsModule", "TransformControlsComponentWithRef", "forwardRef"]
}
