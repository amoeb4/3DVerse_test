import x from"react";import{createContext as R,useContext as L,useEffect as H,useState as O}from"react";import{ViewportContext as j}from"@3dverse/livelink-react";import*as m from"three";var h=class{#a=new m.Scene;#e;#t;#r;#n;#o=new AbortController;constructor({viewport_camera_projection:e,scene:r}){this.#a=r,this.#t=e.viewport,this.#n=new OffscreenCanvas(this.#t.width,this.#t.height);let t=this.#n.getContext("webgl2");if(!t)throw new Error("Cannot create a WebGL2 context");this.#r=new m.WebGLRenderer({context:t,canvas:this.#n}),this.#r.setClearColor(16777215,0),this.#r.setPixelRatio(1),this.#r.setSize(this.#t.width,this.#t.height,!1),this.#e=this.#s()}get camera(){return this.#e}get scene(){return this.#a}#s(){let e=this.#t.camera_projection?.camera_entity;if(!e)throw new Error("Viewport has no camera_projection");let r=e.perspective_lens,t=e.orthographic_lens;if(this.#o.abort(),this.#o=new AbortController,r)this.#e=this.#i({cameraEntity:e,perspective_lens:r});else if(t)this.#e=this.#l({cameraEntity:e,orthographic_lens:t});else throw new Error("Camera entity has no perspective_lens or orthographic_lens component");return this.#e.matrixAutoUpdate=!1,this.#e}#i({cameraEntity:e,perspective_lens:r}){let t=new m.PerspectiveCamera,a=1e5,l=s=>{t.aspect=this.#t.aspect_ratio,t.fov=s.fovy,t.near=s.nearPlane,t.far=s.farPlane||a},n=s=>{if(s.deleted_components.includes("perspective_lens")){this.#s();return}s.updated_components.includes("perspective_lens")&&l(e.perspective_lens)};return e.addEventListener("on-entity-updated",n,{signal:this.#o.signal}),l(r),t}#l({cameraEntity:e,orthographic_lens:r}){let t=new m.OrthographicCamera,a=n=>{t.left=-this.#t.aspect_ratio*n.zoomFactor[0],t.right=this.#t.aspect_ratio*n.zoomFactor[0],t.top=-n.zoomFactor[1],t.bottom=n.zoomFactor[1],t.near=n.zNear,t.far=n.zFar},l=n=>{if(n.deleted_components.includes("orthographic_lens")){this.#s();return}n.updated_components.includes("orthographic_lens")&&a(e.orthographic_lens)};return e.addEventListener("on-entity-updated",l,{signal:this.#o.signal}),a(r),t}draw({output_canvas:e}){let r=this.#t.camera_projection;if(!r)return null;if(this.#c({viewport_camera_projection:r}),e)throw new Error("Not implemented");return this.#n}#c({viewport_camera_projection:e}){this.#e.position.fromArray(e.world_position),this.#e.quaternion.fromArray(e.world_orientation),this.#e.updateMatrix(),this.#e.projectionMatrix.fromArray(e.clip_from_view_matrix),this.#e.projectionMatrixInverse.fromArray(e.view_from_clip_matrix),this.#r.setViewport(0,0,this.#t.width,this.#t.height),this.#r.render(this.#a,this.#e)}resize({width:e,height:r}){this.#n.width=e,this.#n.height=r,this.#r.setSize(e,r,!1)}release(){this.#o.abort(),this.#r.dispose()}};var C=R({overlay:null});function G({scene:i,children:e}){let{viewport:r,camera:t}=L(j),[a,l]=O(null);return H(()=>{if(!r||!t){l(null);return}let n=new h({viewport_camera_projection:t,scene:i});return r.addOverlay({overlay:n}),l(n),()=>{r.removeOverlay({overlay:n})}},[r,t]),x.createElement(C.Provider,{value:{overlay:a}},e)}import{forwardRef as A,useContext as y,useEffect as u,useImperativeHandle as P,useMemo as M,useState as T}from"react";import*as _ from"three";import{ViewportContext as F}from"@3dverse/livelink-react";function z({controlledEntity:i,cameraController:e,setDragging:r},t){let{overlay:a}=y(C),{viewport:l}=y(F),n=S(),s=M(()=>new _.Object3D,[]),[o,w]=T(void 0);return P(t,()=>o,[o]),u(()=>{if(!l||!a||!e||!n)return;let c=new n.TransformControls(a.camera,l.dom_element),p=function(){l.rendering_surface.redrawLastFrame()};return l.dom_element.addEventListener("pointermove",p),w(c),a.scene.add(c.getHelper()),()=>{l.dom_element.removeEventListener("pointermove",p),a.scene.remove(c.getHelper()),c.dispose()}},[l,a,e,n]),u(()=>{if(!o||!e)return;let c=function(p){let d=!!p.value;e.enabled=!d,r&&setTimeout(()=>r(d),0)};return o.addEventListener("dragging-changed",c),()=>{o.removeEventListener("dragging-changed",c)}},[o,e,r]),u(()=>{if(!i||!o||!a)return;a.scene.add(s),o.attach(s);let c=!1,p=function(){i.global_transform.position=o.object.position.toArray(),o.object.quaternion.toArray(i.global_transform.orientation),i.global_transform={scale:o.object.scale.toArray()}},d=function(v){c=!!v.value};o.addEventListener("dragging-changed",d);let b=function(v){v.updated_components.includes("local_transform")&&!c&&E()},E=function(){s.position.fromArray(i.global_transform.position),s.quaternion.fromArray(i.global_transform.orientation),s.scale.fromArray(i.global_transform.scale),s.updateMatrixWorld()};o.addEventListener("objectChange",p);let g=new AbortController,f=i;for(;f;)f.addEventListener("on-entity-updated",b,{signal:g.signal}),f=f.parent;return E(),()=>{a.scene.remove(s),o.removeEventListener("objectChange",p),o.removeEventListener("dragging-changed",d),g.abort(),o.detach()}},[a,i,o,s]),null}var S=()=>{let[i,e]=T(void 0);return u(()=>{import("three/addons/controls/TransformControls.js").then(e)},[]),i},K=A(z);export{G as ThreeOverlay,C as ThreeOverlayContext,K as TransformControls,z as TransformControlsComponent};
//# sourceMappingURL=index.mjs.map
