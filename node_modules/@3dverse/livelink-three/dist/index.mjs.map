{
  "version": 3,
  "sources": ["../sources/ThreeOverlay.ts"],
  "sourcesContent": ["import * as THREE from \"three\";\nimport type {\n    CameraProjection,\n    Components,\n    Entity,\n    EntityUpdatedEvent,\n    OverlayInterface,\n    Viewport,\n} from \"@3dverse/livelink\";\n\n/**\n *\n */\nexport class ThreeOverlay implements OverlayInterface {\n    /**\n     *\n     */\n    #scene: THREE.Scene = new THREE.Scene();\n\n    /**\n     *\n     */\n    #camera: THREE.Camera;\n\n    /**\n     *\n     */\n    #viewport: Viewport;\n\n    /**\n     *\n     */\n    #renderer: THREE.WebGLRenderer;\n\n    /**\n     *\n     */\n    #offscreenCanvas: OffscreenCanvas;\n\n    /**\n     *\n     */\n    #event_abort_controller: AbortController = new AbortController();\n\n    /**\n     *\n     */\n    constructor({\n        viewport_camera_projection,\n        scene,\n    }: {\n        viewport_camera_projection: CameraProjection;\n        scene: THREE.Scene;\n    }) {\n        this.#scene = scene;\n        this.#viewport = viewport_camera_projection.viewport;\n        this.#offscreenCanvas = new OffscreenCanvas(this.#viewport.width, this.#viewport.height);\n        const context = this.#offscreenCanvas.getContext(\"webgl2\");\n        if (!context) {\n            throw new Error(\"Cannot create a WebGL2 context\");\n        }\n\n        this.#renderer = new THREE.WebGLRenderer({ context, canvas: this.#offscreenCanvas });\n\n        this.#renderer.setClearColor(0xffffff, 0);\n        this.#renderer.setPixelRatio(1);\n        this.#renderer.setSize(this.#viewport.width, this.#viewport.height, false);\n\n        this.#camera = this.#setupCameraProjection();\n    }\n\n    /**\n     *\n     */\n    get camera(): Readonly<THREE.Camera> {\n        return this.#camera;\n    }\n\n    /**\n     *\n     */\n    get scene() {\n        return this.#scene;\n    }\n\n    /**\n     * Create a THREE.Camera from the camera_projection component of the viewport,\n     */\n    #setupCameraProjection(): THREE.Camera {\n        const cameraEntity = this.#viewport.camera_projection?.camera_entity;\n        if (!cameraEntity) {\n            throw new Error(\"Viewport has no camera_projection\");\n        }\n\n        const perspective_lens = cameraEntity.perspective_lens;\n        const orthographic_lens = cameraEntity.orthographic_lens;\n\n        // Unregister the previous entity update handlers.\n        this.#event_abort_controller.abort();\n        this.#event_abort_controller = new AbortController();\n\n        if (perspective_lens) {\n            this.#camera = this.#setupPerspectiveLens({ cameraEntity, perspective_lens });\n        } else if (orthographic_lens) {\n            this.#camera = this.#setupOrthographicLens({ cameraEntity, orthographic_lens });\n        } else {\n            throw new Error(\"Camera entity has no perspective_lens or orthographic_lens component\");\n        }\n\n        this.#camera.matrixAutoUpdate = false;\n        return this.#camera;\n    }\n\n    /**\n     * Create a THREE.PerspectiveCamera from a perspective_lens component,\n     * and update it when the perspective_lens component is updated.\n     * Whenever the perspective_lens component is deleted, #setupCameraProjection is called\n     * to re-create the camera.\n     */\n    #setupPerspectiveLens({\n        cameraEntity,\n        perspective_lens,\n    }: {\n        cameraEntity: Entity;\n        perspective_lens: Components.PerspectiveLens;\n    }): THREE.PerspectiveCamera {\n        const perspectiveCamera = new THREE.PerspectiveCamera();\n        const INFINITE_FAR_VALUE = 100000;\n\n        const applyLens = (perspective_lens: Components.PerspectiveLens) => {\n            perspectiveCamera.aspect = this.#viewport.aspect_ratio;\n            perspectiveCamera.fov = perspective_lens.fovy;\n            perspectiveCamera.near = perspective_lens.nearPlane;\n            perspectiveCamera.far = perspective_lens.farPlane || INFINITE_FAR_VALUE;\n        };\n\n        const entity_update_handler = (event: EntityUpdatedEvent) => {\n            if (event.deleted_components.includes(\"perspective_lens\")) {\n                this.#setupCameraProjection();\n                return;\n            }\n\n            if (event.updated_components.includes(\"perspective_lens\")) {\n                applyLens(cameraEntity.perspective_lens!);\n            }\n        };\n\n        cameraEntity.addEventListener(\"on-entity-updated\", entity_update_handler, {\n            signal: this.#event_abort_controller.signal,\n        });\n\n        applyLens(perspective_lens);\n        return perspectiveCamera;\n    }\n\n    /**\n     * Create a THREE.OrthographicCamera from an orthographic_lens component,\n     * and update it when the orthographic_lens component is updated.\n     * Whenever the orthographic_lens component is deleted, #setupCameraProjection is called\n     * to re-create the camera.\n     */\n    #setupOrthographicLens({\n        cameraEntity,\n        orthographic_lens,\n    }: {\n        cameraEntity: Entity;\n        orthographic_lens: Components.OrthographicLens;\n    }): THREE.OrthographicCamera {\n        const orthographicCamera = new THREE.OrthographicCamera();\n\n        const applyLens = (orthographic_lens: Components.OrthographicLens) => {\n            orthographicCamera.left = -this.#viewport.aspect_ratio * orthographic_lens.zoomFactor[0];\n            orthographicCamera.right = this.#viewport.aspect_ratio * orthographic_lens.zoomFactor[0];\n            orthographicCamera.top = -orthographic_lens.zoomFactor[1];\n            orthographicCamera.bottom = orthographic_lens.zoomFactor[1];\n            orthographicCamera.near = orthographic_lens.zNear;\n            orthographicCamera.far = orthographic_lens.zFar;\n        };\n\n        const entity_update_handler = (event: EntityUpdatedEvent) => {\n            if (event.deleted_components.includes(\"orthographic_lens\")) {\n                this.#setupCameraProjection();\n                return;\n            }\n\n            if (event.updated_components.includes(\"orthographic_lens\")) {\n                applyLens(cameraEntity.orthographic_lens!);\n            }\n        };\n\n        cameraEntity.addEventListener(\"on-entity-updated\", entity_update_handler, {\n            signal: this.#event_abort_controller.signal,\n        });\n\n        applyLens(orthographic_lens);\n        return orthographicCamera;\n    }\n\n    /**\n     *\n     */\n    draw({ output_canvas }: { output_canvas: OffscreenCanvas | null }): OffscreenCanvas | null {\n        const viewport_camera_projection = this.#viewport.camera_projection;\n        if (!viewport_camera_projection) {\n            return null;\n        }\n\n        this.#drawFrameForCamera({ viewport_camera_projection });\n\n        if (output_canvas) {\n            throw new Error(\"Not implemented\");\n        }\n\n        return this.#offscreenCanvas;\n    }\n\n    /**\n     *\n     */\n    #drawFrameForCamera({ viewport_camera_projection }: { viewport_camera_projection: CameraProjection }) {\n        // Here we MUST NOT use the transform of the camera entity, but the one from the camera projection.\n        this.#camera.position.fromArray(viewport_camera_projection.world_position);\n        this.#camera.quaternion.fromArray(viewport_camera_projection.world_orientation);\n        this.#camera.updateMatrix();\n        this.#camera.projectionMatrix.fromArray(viewport_camera_projection.clip_from_view_matrix);\n        this.#camera.projectionMatrixInverse.fromArray(viewport_camera_projection.view_from_clip_matrix);\n\n        this.#renderer.setViewport(0, 0, this.#viewport.width, this.#viewport.height);\n        this.#renderer.render(this.#scene, this.#camera);\n    }\n\n    /**\n     *\n     */\n    resize({ width, height }: { width: number; height: number }): void {\n        this.#offscreenCanvas.width = width;\n        this.#offscreenCanvas.height = height;\n        this.#renderer.setSize(width, height, false);\n    }\n\n    /**\n     *\n     */\n    release() {\n        this.#event_abort_controller.abort();\n        this.#renderer.dispose();\n    }\n}\n"],
  "mappings": "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",
  "names": ["THREE", "ThreeOverlay", "#scene", "#camera", "#viewport", "#renderer", "#offscreenCanvas", "#event_abort_controller", "viewport_camera_projection", "scene", "context", "#setupCameraProjection", "cameraEntity", "perspective_lens", "orthographic_lens", "#setupPerspectiveLens", "#setupOrthographicLens", "perspectiveCamera", "INFINITE_FAR_VALUE", "applyLens", "entity_update_handler", "event", "orthographicCamera", "output_canvas", "#drawFrameForCamera", "width", "height"]
}
