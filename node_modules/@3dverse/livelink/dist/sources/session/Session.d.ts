import type { SessionInterface, UUID } from "@3dverse/livelink.core";
import { Client } from "./Client";
import { SessionInfo } from "./SessionInfo";
import { TypedEventTarget } from "../TypedEventTarget";
import { SessionEvents } from "./SessionEvents";
/**
 * A session running a scene.
 *
 * A session is a running instance of a 3dverse server rendering a scene that can be joined by
 * multiple clients.
 *
 * A session can be transient or not.
 * A transient session is temporary and changes made to the entities in the scene are not saved.
 *
 * ### Usage
 * This class is not meant to be instantiated directly. Use the static methods to create or find
 * an existing session.
 *
 * A session can be created or joined:
 * - To create a new session, use the {@link Session.create} method.
 * - To find an existing session, use the {@link Session.find} method.
 * - Or if you know the session id, use the {@link Session.findById} method.
 *
 * ### Authentication
 * To create or find a session, you need a valid authentication token that has at least
 * read access to the scene the session will use.
 *
 * See: https://docs.3dverse.com/api/generate-user-token
 *
 * ### Events
 * - {@link ClientJoinedEvent} - Fired when a client joins the session.
 * - {@link ClientLeftEvent} - Fired when a client leaves the session.
 * - {@link InactivityWarningEvent} - Fired when the client is inactive for a certain amount of time.
 * - {@link ActivityDetectedEvent} - Fired when the client is active again.
 * - {@link DisconnectedEvent} - Fired when the session is disconnected.
 *
 * See: {@link SessionEvents} for more details.
 *
 * @category Session
 */
export declare class Session extends TypedEventTarget<SessionEvents> implements SessionInterface {
    #private;
    /**
     * Create a new session.
     *
     * @param params
     * @param params.scene_id - The unique identifier of the scene the session will launch.
     * @param params.token - The authentication token. This token must have at least read access to the scene.
     * @param params.is_transient - Whether the session is transient. Transient sessions are temporary and changes are not saved.
     *
     * @returns A promise that resolves to the created session.
     *
     * @throws Error if the session could not be created.
     */
    static create({ scene_id, token, is_transient, }: {
        scene_id: UUID;
        token: string;
        is_transient?: boolean;
    }): Promise<Session>;
    /**
     * Find an existing session running the specified scene.
     *
     * @param params
     * @param params.scene_id - The unique identifier of the scene the session must be running.
     * @param params.token - The authentication token. This token must have at least read access to the scene.
     * @param params.session_selector - A callback that selects a session from a list of candidate sessions.
     *
     * @returns A promise that resolves to the found session or null if no session was found or
     * if no session was selected by the session selector.
     */
    static find({ scene_id, token, session_selector, }: {
        scene_id: UUID;
        token: string;
        session_selector: SessionSelector;
    }): Promise<Session | null>;
    /**
     * Find an existing session by its unique identifier.
     *
     * @param params
     * @param params.session_id - The unique identifier of the session to find.
     * @param params.token - The authentication token. This token must have at least read access to the scene.
     *
     * @returns A promise that resolves to the found session or null if no session was found.
     */
    static findById({ session_id, token }: {
        session_id: UUID;
        token: string;
    }): Promise<Session | null>;
    /**
     * Find the session tied to a guest token.
     *
     * @param params
     * @param params.guest_token - The guest token generated by the [Generate Guest Token](https://docs.3dverse.com/api/generate-guest-token) endpoint.
     */
    static findByGuestToken({ guest_token }: {
        guest_token: string;
    }): Promise<Session | null>;
    /**
     * The information about the session.
     */
    readonly info: SessionInfo;
    /**
     * Whether the session has been created or joined by the current client.
     */
    readonly has_been_created: boolean;
    /**
     * The id of the client that is currently connected to the session.
     */
    client_id: UUID | null;
    /**
     * The authentication token.
     */
    readonly token: string;
    /**
     * Whether the authentication token is a guest token.
     */
    readonly is_guest: boolean;
    /**
     * The unique identifier of the scene the session is running.
     */
    get scene_id(): UUID;
    /**
     * The unique identifier of the session.
     */
    get session_id(): UUID;
    /**
     * The unique identifiers of all clients connected to the session.
     */
    get client_ids(): Array<UUID>;
    /**
     * All the clients connected to the session.
     */
    get clients(): Array<Client>;
    /**
     * All the clients connected to the session except the current client.
     */
    get other_clients(): Array<Client>;
    /**
     * The current client connected to the session.
     */
    get current_client(): Client | null;
    /**
     * Create a new session.
     *
     * @param params
     * @param params.token - The authentication token. This token must have at least read access to the scene.
     * @param params.session_info - The information about the session.
     * @param params.created - Whether the session has been created or found by the current client.
     */
    private constructor();
    /**
     * Whether the session is joinable.
     */
    isJoinable(): boolean;
    /**
     * Get a client by its unique identifier.
     *
     * @param params
     * @param params.client_id - The unique identifier of the client to look for.
     *
     * @returns The client or null if the client is not found.
     */
    getClient({ client_id }: {
        client_id: UUID;
    }): Client | null;
    /**
     * Evict a client from the session.
     *
     * The client will be disconnected.
     *
     * The token used to create the session must have manage access to the scene.
     *
     * Note that nothing prevents the client from reconnecting while the session is still running.
     *
     * @param params
     * @param params.client - The client to evict, either a {@link Client} object or the unique identifier of the client.
     *
     * @returns A promise that resolves to true if the client was evicted, false otherwise.
     */
    evictClient({ client }: {
        client: Client | UUID;
    }): Promise<boolean>;
}
//# sourceMappingURL=Session.d.ts.map