import type { UUID, ScriptDataObject, ComponentName, ComponentsManifest } from "@3dverse/livelink.core";
import { Entity } from "./Entity";
/**
 * Options for creating a new entity.
 *
 * @inline
 * @category Scene
 */
export type EntityCreationOptions = {
    /**
     * Whether to delete the entity when the client disconnects.
     */
    delete_on_client_disconnection?: boolean;
    /**
     * @deprecated
     * Whether to broadcast the entity automatically.
     */
    auto_broadcast?: boolean;
};
/**
 * The scene class.
 *
 * It is the main entry point to interact with the entities in the scene.
 * It is responsible for creating, finding, and deleting entities.
 *
 * This class is not meant to be instantiated directly.
 * Instead, it is created by the {@link Livelink} instance and can be accessed through the
 * {@link Livelink.scene} property.
 *
 * @category Scene
 */
export declare class Scene {
    #private;
    /**
     * Create a new entity.
     *
     * @param params
     * @param params.name - The name of the entity.
     * @param params.components - The components to add to the entity with their initial values.
     * If no initial values are provided, the default values are used.
     * @param params.options - Additional options for the entity creation.
     *
     * @returns A promise that resolves to the created entity.
     *
     * @example
     * ```typescript
     * const entity = await scene.newEntity({
     *     name: "My Entity",
     *     components: {
     *         local_transform: {
     *             position: [0, 2, 0],
     *             // default values are used for scale and orientation
     *         }
     *     },
     * });
     * ```
     */
    newEntity({ name, components, options, parent, }: {
        name: string;
        components: ComponentsManifest;
        options?: EntityCreationOptions;
        parent?: Entity | null;
    }): Promise<Entity>;
    /**
     * Create multiple entities at once.
     * This method is more efficient than calling `newEntity` multiple times.
     * It creates all entities in a single call to the core.
     *
     * @param params
     * @param params.components_array - An array of objects with the name and components of each entity.
     * @param params.options - Additional options for the entity creation.
     *
     * @returns A promise that resolves to an array of the created entities.
     */
    newEntities({ components_array, options, }: {
        components_array: Array<ComponentsManifest>;
        options?: EntityCreationOptions;
    }): Promise<Array<Entity>>;
    /**
     * Find an entity by its UUID and linkage.
     *
     * @param params
     * @param params.entity_uuid - The UUID of the entity to find.
     * @param params.linkage - The linkage of the entity to find.
     *
     * @returns A promise that resolves to the found entity or null if not found.
     */
    findEntity({ entity_uuid, linkage, }: {
        entity_uuid: UUID;
        linkage?: Array<UUID>;
    }): Promise<Entity | null>;
    /**
     * Find entities by their UUID.
     *
     * This can return multiple entities if the entity is a child of a {@link Components.SceneRef}
     * that is instanced multiple times.
     *
     * @param params
     * @param params.entity_uuid - The UUID of the entity to find.
     *
     * @returns A promise that resolves to an array of entities with the given UUID.
     */
    findEntities({ entity_uuid }: {
        entity_uuid: UUID;
    }): Promise<Array<Entity>>;
    /**
     * Delete a batch of entities.
     *
     * @param params
     * @param params.entities - The entities to delete.
     *
     * @returns A promise that resolves when the entities are deleted.
     */
    deleteEntities({ entities }: {
        entities: Array<Entity>;
    }): Promise<void>;
    /**
     * Highlight a batch of entities.
     *
     * @param params
     * @param params.entities - The entities to highlight.
     * @param params.keep_old_selection - Whether to keep the old selection or not.
     *
     * @returns A promise that resolves when the message is sent.
     */
    highlightEntities({ entities, keep_old_selection, }: {
        entities: Array<Entity>;
        keep_old_selection?: boolean;
    }): Promise<void>;
    /**
     * Fire a script event.
     *
     * @param params
     * @param params.event_map_id - The UUID of the event map.
     * @param params.event_name - The name of the event.
     * @param params.emitter_entity - The entity that emits the event.
     * @param params.target_entities - The entities that are the target of the event. Leave empty for global events.
     * @param params.data_object - The data object to pass with the event.
     *
     * @returns A promise that resolves when the message is sent.
     *
     * @experimental
     */
    fireEvent({ event_map_id, event_name, emitter_entity, target_entities, data_object, }: {
        event_map_id: UUID;
        event_name: string;
        emitter_entity?: Entity;
        target_entities?: Array<Entity>;
        data_object?: ScriptDataObject;
    }): void;
    /**
     * @experimental
     */
    setFilter({ name, value }: {
        name: string;
        value: string;
    }): void;
    /**
     * @experimental
     */
    toggleFilter({ name, enabled }: {
        name: string;
        enabled: boolean;
    }): void;
    /**
     * @experimental
     */
    removeFilter({ name }: {
        name: string;
    }): void;
    /**
     *  @deprecated
     */
    findEntitiesByNames({ entity_names }: {
        entity_names: Array<string>;
    }): Promise<Array<Entity>>;
    /**
     *  @deprecated
     */
    findEntitiesWithComponents({ mandatory_components, forbidden_components, }: {
        mandatory_components: Array<ComponentName>;
        forbidden_components?: Array<ComponentName>;
    }): Promise<Array<Entity>>;
}
//# sourceMappingURL=Scene.d.ts.map