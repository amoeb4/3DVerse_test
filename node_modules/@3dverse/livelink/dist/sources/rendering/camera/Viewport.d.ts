import type { Enums, Vec2, Vec3 } from "@3dverse/livelink.core";
import { Livelink } from "../../Livelink";
import { Entity } from "../../scene/Entity";
import { TypedEventTarget } from "../../TypedEventTarget";
import { RelativeRect } from "../surfaces/Rect";
import { OverlayInterface } from "../surfaces/OverlayInterface";
import { RenderingSurfaceBase } from "../surfaces/RenderingSurfaceBase";
import { CameraProjection } from "./CameraProjection";
import { ViewportEvents } from "./ViewportEvents";
/**
 * A viewport is a rendering area on a {@link RenderingSurfaceBase} that is associated with a
 * {@link CameraProjection}.
 *
 * It can have overlays that are rendered on top of the viewport. See {@link OverlayInterface}.
 *
 * Viewports can overlap each other, in which case the one with the highest z-index is rendered on top.
 *
 * @category Camera
 */
export declare class Viewport extends TypedEventTarget<ViewportEvents> {
    #private;
    /**
     * Whether the attached camera is controlled by the current client.
     */
    is_camera_controlled_by_current_client: boolean;
    /**
     * The rendering surface on which the viewport is displayed.
     */
    get rendering_surface(): RenderingSurfaceBase;
    /**
     * The camera projection used to render the scene.
     */
    get camera_projection(): CameraProjection | null;
    /**
     * The width of the viewport in pixels.
     */
    get width(): number;
    /**
     * The height of the viewport in pixels.
     */
    get height(): number;
    /**
     * The offset of the viewport in pixels.
     */
    get offset(): Vec2;
    /**
     * The aspect ratio of the viewport.
     */
    get aspect_ratio(): number;
    /**
     * The z-index of the viewport.
     */
    get z_index(): number;
    /**
     * The index of the render target that is rendered on the viewport.
     */
    get render_target_index(): number;
    /**
     * The relative position and size of the viewport in relation to the rendering surface.
     */
    get relative_rect(): RelativeRect;
    /**
     * DOM element attached to the viewport.
     */
    get dom_element(): HTMLElement;
    /**
     * The DOM elements of the overlays attached to the viewport.
     */
    get overlay_dom_elements(): Array<HTMLElement>;
    /**
     * Sets the z-index of the viewport.
     */
    set z_index(z_index: number);
    /**
     * Sets the relative position and size of the viewport in relation to the rendering surface.
     */
    set relative_rect(rect: RelativeRect);
    /**
     * Sets the camera projection used to render the scene.
     */
    set camera_projection(camera_projection: CameraProjection);
    /**
     * The index of the render target that is rendered on the viewport.
     *
     * -1 means the default render target as defined by the render graph assigned to the camera the viewport is using.
     */
    set render_target_index(render_target_index: number);
    /**
     * Creates a new viewport.
     *
     * @param params
     * @param params.core - The Livelink core used to send commands.
     * @param params.rendering_surface - The rendering surface on which the viewport is displayed.
     * @param params.options - The options for the viewport.
     * @param params.options.rect - The relative position and size of the viewport in relation to the rendering surface.
     * @param params.options.render_target_index - The index of the render target that is rendered on the viewport.
     * @param params.options.z_index - The z-index of the viewport.
     * @param params.options.dom_element - The DOM element used for picking.
     */
    constructor({ core, rendering_surface, options, }: {
        core: Livelink;
        rendering_surface: RenderingSurfaceBase;
        options?: {
            rect?: RelativeRect;
            render_target_index?: number;
            z_index?: number;
            dom_element?: HTMLElement;
        };
    });
    /**
     * Returns whether the viewport is valid.
     *
     * A viewport is valid if a camera projection is set on it.
     */
    isValid(): boolean;
    /**
     * Releases the resources used by the viewport.
     */
    release(): void;
    /**
     * Activates picking on the viewport.
     *
     * If picking is activated, the viewport will emit an `on-entity-picked` event when it is clicked.
     */
    activatePicking(): void;
    /**
     * Deactivates picking on the viewport.
     *
     * If picking is deactivated, the viewport will no longer emit an {@link EntityPickedEvent} event when it is clicked.
     */
    deactivatePicking(): void;
    /**
     * @experimental
     *
     * Activates entity hovering on the viewport.
     *
     * If hovering is activated, the viewport will emit an {@link EntityHoveredEvent} event when it is hovered.
     */
    activateHovering(): void;
    /**
     * @experimental
     *
     * Deactivates entity hovering on the viewport.
     *
     * If hovering is deactivated, the viewport will no longer emit an `on-entity-hovered` event when it is hovered.
     */
    deactivateHovering(): void;
    /**
     * Casts a screen space ray and returns the **first** entity and world space position and normal that the ray
     * intersects.
     * If no entity is intersected, null is returned.
     *
     * Note that transparent objects will be picked if they are in front of opaque objects even if their
     * opacity is set to 0.
     *
     * Do **not** use this method for picking objects using the mouse cursor.
     * Instead activate picking on the viewport using {@link activatePicking} and listen for the
     * `on-entity-picked` event.
     *
     * @param params
     * @param params.screen_position - The screen space position to cast the ray from.
     * @param params.mode - The highlight mode to use.
     *
     * @returns The entity and world space position and normal that the ray intersects, or null if no entity is
     * intersected.
     */
    castScreenSpaceRay({ screen_position, mode, }: {
        screen_position: Vec2;
        mode: Enums.HighlightMode;
    }): Promise<{
        entity: Entity;
        world_position: Vec3;
        world_normal: Vec3;
    } | null>;
    /**
     * Projects a world space position to screen space.
     *
     * The position is projected using the camera projection set on the viewport.
     *
     * @param params
     * @param params.world_position - The position in world space to project.
     * @param params.out_screen_position - The output position in screen space.
     *
     * @returns The position in screen space.
     */
    projectWorldToScreen({ world_position, out_screen_position, }: {
        world_position: Vec3;
        out_screen_position?: Vec3;
    }): Vec3;
    /**
     * Adds an overlay to the viewport.
     *
     * @param params
     * @param params.overlay - The overlay to add. Must not have been added to the viewport before.
     */
    addOverlay({ overlay }: {
        overlay: OverlayInterface;
    }): void;
    /**
     * Removes an overlay from the viewport.
     *
     * The overlay is released and should not be used after this method is called.
     *
     * @param params
     * @param params.overlay - The overlay to remove. Must have been added to the viewport before.
     */
    removeOverlay({ overlay }: {
        overlay: OverlayInterface;
    }): void;
    /**
     * Return the screen position from a mouse event.
     *
     * @param params
     * @param params.event - The mouse event.
     *
     * @returns The screen position as a Vec2.
     * (0, 0) is the top-left corner of the viewport, (1, 1) is the bottom-right corner.
     */
    getScreenPositionFromEvent({ event }: {
        event: MouseEvent;
    }): Vec2;
}
//# sourceMappingURL=Viewport.d.ts.map