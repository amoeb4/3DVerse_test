import type { Mat4, Quat, Vec2, Vec3 } from "@3dverse/livelink.core";
import { Entity } from "../../scene/Entity";
import { Viewport } from "./Viewport";
/**
 * A ray in 3D space.
 *
 * @category Camera
 */
export type Ray = {
    origin: Vec3;
    direction: Vec3;
};
/**
 * Holds the projection and transform matrices associated to a camera entity.
 *
 * The data in this class is guaranteed to be synchronized with the frame being rendered.
 * It accounts for the delays that occur between the remote server and the client.
 * The data it holds come from the frame meta data that are provided along with the frame sent by the server.
 *
 * As for the transform values in the camera entity, they are not guaranteed to be synchronized
 * with the frame being rendered. This is because the camera entity can be updated at any time,
 * and might be too recent to be used in the current frame.
 *
 * In short, camera controllers should use the camera entity and frame drawers (RenderingSurface, Overlay, ...)
 * should use the CameraProjection.
 *
 * @category Camera
 */
export declare class CameraProjection {
    #private;
    /**
     * The entity that holds the camera and lens components.
     */
    readonly camera_entity: Entity;
    /**
     * The viewport in which the camera is rendered.
     */
    readonly viewport: Viewport;
    /**
     * Transformation matrix from view space to clip space, aka the projection matrix.
     */
    get clip_from_view_matrix(): Readonly<Mat4>;
    /**
     * Transformation matrix from clip space to view space, aka the inverse of the projection matrix.
     */
    get view_from_clip_matrix(): Readonly<Mat4>;
    /**
     * Transformation matrix from world space to clip space, aka the model-view-projection matrix.
     */
    get clip_from_world_matrix(): Readonly<Mat4>;
    /**
     * Transformation matrix from clip space to world space, aka the inverse of model-view-projection matrix.
     */
    get world_from_clip_matrix(): Readonly<Mat4>;
    /**
     * Transformation matrix from view space to world space, aka the inverse of the view matrix.
     */
    get world_from_view_matrix(): Readonly<Mat4>;
    /**
     * World space position of the camera as used to render the currently processed frame.
     */
    get world_position(): Readonly<Vec3>;
    /**
     * World space orientation of the camera as used to render the currently processed frame.
     */
    get world_orientation(): Readonly<Quat>;
    /**
     * World space orientation expressed as euler of the camera as used to render the currently processed frame.
     */
    get world_euler_orientation(): Readonly<Vec3>;
    /**
     * Creates a new CameraProjection instance for the given camera entity and viewport.
     *
     * @param params - The parameters for the CameraProjection instance.
     * @param params.camera_entity - The entity that holds the camera and lens components.
     * @param params.viewport - The viewport in which the camera is rendered.
     *
     * @throws Error if the camera entity does not have a camera or lens component.
     */
    constructor({ camera_entity, viewport }: {
        camera_entity: Entity;
        viewport: Viewport;
    });
    /**
     * Projects a world space position to clip space.
     *
     * @param params
     * @param params.world_position - The position in world space to project.
     * @param params.out_clip_position - The output position in clip space.
     *
     * @returns The position in clip space.
     */
    projectWorldToClip({ world_position, out_clip_position, }: {
        world_position: Vec3;
        out_clip_position?: Vec3;
    }): Vec3;
    /**
     * Projects a clip space position to world space.
     *
     * @param param
     * @param param.clip_position - The position in clip space to project.
     * @param param.out_world_position - The output position in world space.
     *
     * @returns The position in world space.
     */
    projectClipToWorld({ clip_position, out_world_position, }: {
        clip_position: Vec3;
        out_world_position?: Vec3;
    }): Vec3;
    /**
     * Computes a ray from the camera origin to the given screen coordinates.
     * (0, 0) is the top-left corner of the viewport, (1, 1) is the bottom-right corner.
     *
     * @param param
     * @param param.screen_position - The screen coordinates to compute the ray from.

     * @returns The ray.
     */
    computeRayFromScreenPosition({ screen_position }: {
        screen_position: Vec2;
    }): Ray;
    /**
     * Computes a ray from the camera origin to the given clip coordinates.
     * (-1, -1) is the bottom-left corner of the viewport, (1, 1) is the top-right corner.
     *
     * @param param
     * @param param.clip_position - The clip coordinates to compute the ray from.
     *
     * @returns The ray.
     */
    computeRayFromClipPosition({ clip_position }: {
        clip_position: Vec3;
    }): Ray;
    /**
     * Updates the projection matrix of the camera entity.
     * This method should be called whenever the camera entity or viewport changes.
     */
    updateProjectionMatrix(): void;
}
//# sourceMappingURL=CameraProjection.d.ts.map