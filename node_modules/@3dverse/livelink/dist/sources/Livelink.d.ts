import type { ActivityWatcher, Enums, Commands, UUID } from "@3dverse/livelink.core";
import { EncodedFrameConsumer } from "./rendering/streaming/EncodedFrameConsumer";
import { DecodedFrameConsumer } from "./rendering/streaming/DecodedFrameConsumer";
import { Viewport } from "./rendering/camera/Viewport";
import { Scene } from "./scene/Scene";
import { Entity } from "./scene/Entity";
import { Session, SessionSelector } from "./session/Session";
import { Mouse } from "./inputs/Mouse";
import { Keyboard } from "./inputs/Keyboard";
import { GamepadsRegistry } from "./inputs/GamepadsRegistry";
/**
 * This class represents the Livelink connection between the client and the 3dverse server holding
 * the session.
 * It holds access to the actual socket connection as well as a client local representation of the
 * rendered scene.
 *
 * This class is not directly instantiable, you need to use the provided static
 * functions to create an instance:
 * - {@link Livelink.start}: to start a new session.
 * - {@link Livelink.join}: to join an exisiting session.
 * - {@link Livelink.join_or_start}: to try joining an existing session if one if found or fallback
 * to starting a new one otherwise.
 *
 * ### Connection lifecycle
 * The connection lifecycle is as follows:
 * - {@link Livelink.start}, {@link Livelink.join} or {@link Livelink.join_or_start} to create a new
 * Livelink instance.
 * - {@link Livelink.configureRemoteServer} to configure the remote server with the desired codec.
 * - {@link Livelink.addViewports} to add the viewports to the remote rendering surface so that the
 * server knows the size of the encoded frames to send.
 * - {@link Livelink.setEncodedFrameConsumer} to set the encoded frame consumer that will process the
 * encoded frames received from the server.
 * - {@link Livelink.startStreaming} to start streaming the remotely rendered frames.
 *
 * ### Input devices
 * Input devices can be accessed from the Livelink instance using the {@link Livelink.devices} property.
 * They can be activated and deactivated using the appropriate methods.
 * An active input device will automatically send its state as it changes to the server.
 *
 * ### Session management
 * Starting a new session:
 *
 * ```typescript
 * const instance = await Livelink.start({
 *     scene_id: "00000000-0000-0000-0000-000000000000",
 *     token: "authentication-token",
 * });
 * ```
 *
 * Joining an existing session:
 *
 * ```typescript
 * const session = await Session.find({
 *    scene_id: "00000000-0000-0000-0000-000000000000",
 *    token: "authentication-token",
 * });
 * const instance = await Livelink.join({session});
 * ```
 *
 * Joining an existing session or starting a new one if none is found:
 *
 * ```typescript
 * const instance = await Livelink.join_or_start({
 *     scene_id: "00000000-0000-0000-0000-000000000000",
 *     token: "authentication-token",
 * });
 * ```
 *
 * @category Main
 */
export declare class Livelink {
    #private;
    /**
     * Start a new session on the specified scene.
     *
     * @param params
     * @param params.scene_id The id of the scene to start
     * @param params.token The public access token or the user token which must have at least read
     * access to the scene
     * @param params.is_transient  Whether the session should be transient or not.
     *
     * @returns A promise to a Livelink instance holding a session with the specified scene
     *
     * @throws If the session could not be started
     */
    static start({ scene_id, token, is_transient, }: {
        scene_id: UUID;
        token: string;
        is_transient?: boolean;
    }): Promise<Livelink>;
    /**
     * Try to join an existing session on the specified scene, if none is found
     * fallback to starting a new one.
     *
     * @param params
     * @param params.scene_id The id of the scene to join
     * @param params.token The public access token or the user token which must
     * have at least read access to the scene
     * @param params.session_selector A function to select the session to join
     * among the list of available sessions. If no session is found, the function should return
     * null to fallback to starting a new session.
     * @param params.is_transient  Whether the session should be transient or not.
     *
     * @returns A promise to a Livelink instance holding a session with the
     * specified scene
     *
     * @throws If the session could not be joined or started
     */
    static join_or_start({ scene_id, token, session_selector, is_transient, }: {
        scene_id: UUID;
        token: string;
        session_selector?: SessionSelector;
        is_transient?: boolean;
    }): Promise<Livelink>;
    /**
     * Join an existing session.
     *
     * @param params
     * @param params.session The session to join
     *
     * @returns A promise to a Livelink instance holding the specified session
     *
     * @throws If the session could not be joined
     */
    static join({ session }: {
        session: Session;
    }): Promise<Livelink>;
    /**
     * The session associated with this Livelink instance.
     */
    readonly session: Session;
    /**
     * The scene the current session is running.
     */
    readonly scene: Scene;
    /**
     * The default internal implementation of the {@link DecodedFrameConsumer} interface.
     *
     * If no custom decoded frame consumer is needed, this can be passed to instanciate {@link EncodedFrameConsumer}
     * implementations.
     */
    get default_decoded_frame_consumer(): DecodedFrameConsumer;
    /**
     * The activity watcher disconnects the session if no activity is detected for a certain amount
     * of time.
     */
    get activity_watcher(): ActivityWatcher;
    /**
     * The latency of the connection in milliseconds.
     */
    get latency(): number;
    /**
     * The viewports used to render the scene for the current client.
     */
    get viewports(): Array<Viewport>;
    /**
     * Constructs a new Livelink instance associated with the provided session.
     *
     * @param params
     * @param params.session The session to associate with the Livelink instance
     */
    private constructor();
    /**
     * Disconnect from the server and release all local resources.
     *
     * Note that the session is not closed, it can be reconnected later.
     */
    disconnect(): Promise<void>;
    /**
     * Add viewports to the remote rendering surface.
     *
     * @param params
     * @param params.viewports The viewports to add.
     */
    addViewports({ viewports }: {
        viewports: Array<Viewport>;
    }): void;
    /**
     * Remove viewports from the remote rendering surface.
     *
     * @param params
     * @param params.viewport The viewport to remove.
     */
    removeViewport({ viewport }: {
        viewport: Viewport;
    }): void;
    /**
     * Configure the remote server with the desired codec.
     *
     * The viewports must have been added using {@link Livelink.addViewports} before calling this
     * method.
     *
     * @param params
     * @param params.codec The codec to use for encoding the frames.
     *
     * @returns A promise to the client configuration response.
     */
    configureRemoteServer({ codec, }: {
        codec?: Enums.CodecType;
    }): Promise<Commands.ClientConfigResponse>;
    /**
     * Check if the client is configured.
     */
    isConfigured(): boolean;
    /**
     * Set the encoded frame consumer.
     */
    setEncodedFrameConsumer({ encoded_frame_consumer, }: {
        encoded_frame_consumer: EncodedFrameConsumer;
    }): Promise<void>;
    /**
     * Start streaming the viewports from the server.
     */
    startStreaming(): void;
    /**
     * Send a script event to the server to start the simulation.
     */
    startSimulation(): void;
    /**
     * Send a script event to the server to pause the simulation.
     */
    pauseSimulation(): void;
    /**
     * Send a script event to the server to stop the simulation.
     */
    stopSimulation(): void;
    /**
     * Send a partial skeleton pose targeting a specific animation controller.
     *
     * @param params
     * @param params.controller The entity having the animation controller component.
     * @param params.partial_pose The partial pose to send.
     */
    sendSkeletonPose({ controller, partial_pose, }: {
        controller: Entity;
        partial_pose: Commands.SkeletonPartialPose;
    }): void;
    /**
     * @experimental
     */
    get devices(): Readonly<{
        mouse: Mouse;
        keyboard: Keyboard;
        gamepads_registry: GamepadsRegistry;
    }>;
    /**
     * @experimental
     */
    configureHeadlessClient(): Promise<Commands.ClientConfigResponse>;
    /**
     * @deprecated
     */
    TO_REMOVE__setReadyCallback(callback: () => void): void;
    /**
     * @deprecated
     */
    TO_REMOVE__startIfReady(): void;
}
//# sourceMappingURL=Livelink.d.ts.map