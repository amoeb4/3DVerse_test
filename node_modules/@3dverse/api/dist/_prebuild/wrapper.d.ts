/**
 * 3dverse Asset API v1.0
 * # Getting Started
 *
 *Welcome to the 3dverse Asset API. This is the reference for the REST API endpoints.
 *
 *## NPM package
 *
 *We provide a TypeScript wrapper library to make typesafe API requests and get typed responses: [https://www.npmjs.com/package/@3dverse/api](https://www.npmjs.com/package/@3dverse/api).
 *
 *## Authentication
 *
 *To authenticate your API calls, you'll need to generate an API key via the [3dverse Console](https://console.3dverse.com) and send an `api_key` header with your API requests.
 *Alternatively, you can create a user, generate a token for the user and authenticate with a `user_token`.
 *
 *
 *---
 *
 *
 * Contact: 3dverse Support (support@3dverse.com)
 *
 * DO NOT EDIT THIS FILE MANUALLY.
 * This file has been generated automatically from its OpenAPI spec file.
 * See: https://gitlab.com/3dverse/platform/libs/js/openapi-client-library-generator
 */
import { AxiosPromise, AxiosRequestHeaders, AxiosProgressEvent } from 'axios';
type UnionKeys<T> = T extends T ? keyof T : never;
type StrictUnionHelper<T, TAll> = T extends any ? T & Partial<Record<Exclude<UnionKeys<TAll>, keyof T>, never>> : never;
type StrictUnion<T> = StrictUnionHelper<T, T>;
export declare const axiosInstance: import("axios").AxiosInstance;
export declare function setBaseURL(baseURL: string): void;
export type ListUsers_User_UserInfo = {
    user_id: string;
    username: string;
    registered_at: string;
};
/**
 * Retrieve a list of all users in the current application.
 */
export declare function listUsers({ offset, limit, }: {
    offset?: number;
    limit?: number;
}, headers?: AxiosRequestHeaders): AxiosPromise<Array<ListUsers_User_UserInfo>>;
export type RegisterUser_User_UserInfo = {
    user_id: string;
    username: string;
    registered_at: string;
};
/**
 * Registers the target user in the current application.
 */
export declare function registerUser({ username, }: {
    username: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<RegisterUser_User_UserInfo>;
export type GetUser_User_UserInfo = {
    user_id: string;
    username: string;
    registered_at: string;
};
/**
 * Retrieves details about the target user.
 */
export declare function getUser({ user_id, }: {
    user_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<GetUser_User_UserInfo>;
/**
 * Updates the details of the target user.
 */
export declare function updateUser({ user_id, username, }: {
    user_id: string;
    username: string;
}, headers?: AxiosRequestHeaders): Promise<import("axios").AxiosResponse<any, any>>;
export type DeleteUser_Object = {
    deleted_assets?: DeleteUser_Object;
};
/**
 * Deletes the target user.
 */
export declare function deleteUser({ user_id, }: {
    user_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<DeleteUser_Object>;
export type GenerateUserToken_Token = {
    user_token: string;
    expires_in: number;
    expires_on: number;
};
/**
 * Generates a user token. This user token identifies the user when making a request.
 */
export declare function generateUserToken({ user_id, scope, ttl, }: {
    user_id: string;
    scope: 'read' | 'write' | 'manage';
    ttl?: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<GenerateUserToken_Token>;
export type GetUserGroups_Group_GroupInfo = {
    group_id: string;
    name: string;
    description?: string;
    created_at: string;
    members: Array<GetUserGroups_GroupMember_GroupAccess>;
};
export type GetUserGroups_GroupMember_GroupAccess = {
    user_id: string;
    joined_at?: string;
    group_access: 'read' | 'write' | 'manage';
    folder_access: 'read' | 'write' | 'manage';
};
/**
 * Lists all user groups.
 */
export declare function getUserGroups({ user_id, }: {
    user_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<Array<GetUserGroups_Group_GroupInfo>>;
export type GetUserUploadTasks_UploadTask = {
    upload_task_id: string;
    folder_id: string;
    uploaded_at: string;
    uploaded_by: GetUserUploadTasks_Object;
    progress: number;
    download_progress?: number;
    status: StrictUnion<'waiting' | 'downloading' | 'pending' | 'converting' | 'error' | 'success' | 'rejected'> & string;
    conversion_tasks: Array<GetUserUploadTasks_ConversionTask>;
};
export type GetUserUploadTasks_Object = {
    user_id: string;
    username: string;
};
export type GetUserUploadTasks_ConversionTask = {
    asset_id: string;
    source_file_id: string;
    source_file_name: string;
    conversion_pipeline: 'auto-detect' | 'volume' | 'scene' | 'texture' | 'animation' | 'point-cloud';
    progress: number;
    status: StrictUnion<'pending' | 'converting' | 'error' | 'success'> & string;
};
/**
 * Lists all upload tasks of the target user.
 */
export declare function getUserUploadTasks({ user_id, offset, limit, }: {
    user_id: string;
    offset?: number;
    limit?: number;
}, headers?: AxiosRequestHeaders): AxiosPromise<Array<GetUserUploadTasks_UploadTask>>;
export type CreateGroup_GroupMember_GroupAccess = {
    user_id: string;
    group_access: 'read' | 'write' | 'manage';
    folder_access: 'read' | 'write' | 'manage';
};
export type CreateGroup_Group_GroupInfo = {
    group_id: string;
    name: string;
    description?: string;
    created_at: string;
    members: Array<CreateGroup_GroupMember_GroupAccess_Writable>;
};
export type CreateGroup_GroupMember_GroupAccess_Writable = {
    user_id: string;
    joined_at?: string;
    group_access: 'read' | 'write' | 'manage';
    folder_access: 'read' | 'write' | 'manage';
};
/**
 * Creates a new user group.
 */
export declare function createGroup({ name, description, members, }: {
    name: string;
    description?: string;
    members: Array<CreateGroup_GroupMember_GroupAccess>;
}, headers?: AxiosRequestHeaders): AxiosPromise<CreateGroup_Group_GroupInfo>;
export type GetGroup_Group_GroupInfo = {
    group_id: string;
    name: string;
    description?: string;
    created_at: string;
    members: Array<GetGroup_GroupMember_GroupAccess>;
};
export type GetGroup_GroupMember_GroupAccess = {
    user_id: string;
    joined_at?: string;
    group_access: 'read' | 'write' | 'manage';
    folder_access: 'read' | 'write' | 'manage';
};
/**
 * Gets a group details.
 */
export declare function getGroup({ group_id, }: {
    group_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<GetGroup_Group_GroupInfo>;
/**
 * Updates a group details.
 */
export declare function updateGroupDescription({ group_id, name, description, }: {
    group_id: string;
    name: string;
    description: string;
}, headers?: AxiosRequestHeaders): Promise<import("axios").AxiosResponse<any, any>>;
/**
 * Deletes a group and all its access rights.
 */
export declare function deleteGroup({ group_id, }: {
    group_id: string;
}, headers?: AxiosRequestHeaders): Promise<import("axios").AxiosResponse<any, any>>;
/**
 * Grants member access to the group.
 */
export declare function grantMemberAccessToGroup({ group_id, member_type, member_id, group_access, folder_access, }: {
    group_id: string;
    member_type: 'users' | 'groups';
    member_id: string;
    group_access: 'read' | 'write' | 'manage';
    folder_access: 'read' | 'write' | 'manage';
}, headers?: AxiosRequestHeaders): Promise<import("axios").AxiosResponse<any, any>>;
/**
 * Revoke requested user access to group.
 */
export declare function revokeMemberAccessToGroup({ group_id, member_type, member_id, }: {
    group_id: string;
    member_type: 'users' | 'groups';
    member_id: string;
}, headers?: AxiosRequestHeaders): Promise<import("axios").AxiosResponse<any, any>>;
export type ListFolders_Folder = {
    folder_id: string;
    parent_folder_id?: string;
    name: string;
    created_at?: string;
    created_by?: ListFolders_Object;
    subfolders?: Array<ListFolders_Folder>;
    source_file_count?: number;
    asset_count?: number;
};
export type ListFolders_Object = {
    user_id: string;
    username: string;
    registered_at: string;
};
/**
 * Lists all accessible folders.
 */
export declare function listFolders({ offset, limit, }: {
    offset?: number;
    limit?: number;
}, headers?: AxiosRequestHeaders): AxiosPromise<Array<ListFolders_Folder>>;
export type CreateFolder_Folder = {
    name: string;
    subfolders?: Array<CreateFolder_Folder>;
};
export type CreateFolder_Folder_Writable = {
    folder_id: string;
    parent_folder_id?: string;
    name: string;
    created_at?: string;
    created_by?: CreateFolder_Object;
    subfolders?: Array<CreateFolder_Folder_Writable>;
    source_file_count?: number;
    asset_count?: number;
};
export type CreateFolder_Object = {
    user_id: string;
    username: string;
    registered_at: string;
};
/**
 * Creates a folder.
 */
export declare function createFolder({ name, subfolders, }: {
    name: string;
    subfolders?: Array<CreateFolder_Folder>;
}, headers?: AxiosRequestHeaders): AxiosPromise<CreateFolder_Folder_Writable>;
export type GetFolderInfo_Folder = {
    folder_id: string;
    parent_folder_id?: string;
    name: string;
    created_at?: string;
    created_by?: GetFolderInfo_Object;
    subfolders?: Array<GetFolderInfo_Folder>;
    source_file_count?: number;
    asset_count?: number;
};
export type GetFolderInfo_Object = {
    user_id: string;
    username: string;
    registered_at: string;
};
/**
 * Gets the requested folder details.
 */
export declare function getFolderInfo({ folder_id, }: {
    folder_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<GetFolderInfo_Folder>;
/**
 * Move folders inside the specified folder.
 */
export declare function moveFolders({ folder_id, folder_ids, }: {
    folder_id: string;
    folder_ids: Array<string>;
}, headers?: AxiosRequestHeaders): Promise<import("axios").AxiosResponse<any, any>>;
/**
 * Updates the folder details.
 */
export declare function updateFolder({ folder_id, name, }: {
    folder_id: string;
    name?: string;
}, headers?: AxiosRequestHeaders): Promise<import("axios").AxiosResponse<any, any>>;
/**
 * Deletes the requested folder. The target folder must be empty.
 */
export declare function deleteFolder({ folder_id, }: {
    folder_id: string;
}, headers?: AxiosRequestHeaders): Promise<import("axios").AxiosResponse<any, any>>;
export type ListFolderAccesses_Object = {
    users?: Array<ListFolderAccesses_UserInfo_FolderAccess>;
    groups?: Array<ListFolderAccesses_GroupInfo_FolderAccess>;
};
export type ListFolderAccesses_UserInfo_FolderAccess = {
    user_id: string;
    username: string;
    access: 'read' | 'write' | 'manage';
};
export type ListFolderAccesses_GroupInfo_FolderAccess = {
    group_id: string;
    name: string;
    access: 'read' | 'write' | 'manage';
};
/**
 * List member access to the targeted folder.
 */
export declare function listFolderAccesses({ folder_id, }: {
    folder_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<ListFolderAccesses_Object>;
/**
 * Grants member access to the targeted folder.
 */
export declare function grantMemberAccessToFolder({ folder_id, member_type, member_id, access, }: {
    folder_id: string;
    member_type: 'users' | 'groups';
    member_id: string;
    access: 'read' | 'write' | 'manage';
}, headers?: AxiosRequestHeaders): Promise<import("axios").AxiosResponse<any, any>>;
/**
 * Revokes member access to a target folder.
 */
export declare function revokeMemberAccessToFolder({ folder_id, member_type, member_id, }: {
    folder_id: string;
    member_type: 'users' | 'groups';
    member_id: string;
}, headers?: AxiosRequestHeaders): Promise<import("axios").AxiosResponse<any, any>>;
export type CreateSubfolder_Folder = {
    name: string;
    subfolders?: Array<CreateSubfolder_Folder>;
};
export type CreateSubfolder_Folder_Writable = {
    folder_id: string;
    parent_folder_id?: string;
    name: string;
    created_at?: string;
    created_by?: CreateSubfolder_Object;
    subfolders?: Array<CreateSubfolder_Folder_Writable>;
    source_file_count?: number;
    asset_count?: number;
};
export type CreateSubfolder_Object = {
    user_id: string;
    username: string;
    registered_at: string;
};
/**
 * Creates a subfolder.
 */
export declare function createSubfolder({ folder_id, name, subfolders, }: {
    folder_id: string;
    name: string;
    subfolders?: Array<CreateSubfolder_Folder>;
}, headers?: AxiosRequestHeaders): AxiosPromise<CreateSubfolder_Folder_Writable>;
export type ListFolderSubFolders_Folder = {
    folder_id: string;
    parent_folder_id?: string;
    name: string;
    created_at?: string;
    created_by?: ListFolderSubFolders_Object;
    subfolders?: Array<ListFolderSubFolders_Folder>;
    source_file_count?: number;
    asset_count?: number;
};
export type ListFolderSubFolders_Object = {
    user_id: string;
    username: string;
    registered_at: string;
};
/**
 * Lists all subfolders of requested folder. This request can be recursive.
 */
export declare function listFolderSubFolders({ folder_id, }: {
    folder_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<Array<ListFolderSubFolders_Folder>>;
export type UploadSourceFiles_Object = {
    upload_task_id?: string;
};
/**
 * Uploads the specified source file(s).
 */
export declare function uploadSourceFiles({ folder_id, body, }: {
    folder_id: string;
    body: FormData;
}, onUploadProgress?: (progressEvent: AxiosProgressEvent) => void, headers?: AxiosRequestHeaders): AxiosPromise<UploadSourceFiles_Object>;
export type GetSourceFilesInFolder_Filters = {
    source_file_name?: string;
};
export type GetSourceFilesInFolder_SourceFile = {
    source_file_id: string;
    source_file_original_name: string;
    name: string;
    size: number;
};
/**
 * Lists all source files in a folder.
 */
export declare function getSourceFilesInFolder({ folder_id, offset, limit, filters, }: {
    folder_id: string;
    offset?: number;
    limit?: number;
    filters?: GetSourceFilesInFolder_Filters;
}, headers?: AxiosRequestHeaders): AxiosPromise<Array<GetSourceFilesInFolder_SourceFile>>;
/**
 * Move source files inside the specified folder.
 */
export declare function moveSourceFiles({ folder_id, source_file_ids, }: {
    folder_id: string;
    source_file_ids: Array<string>;
}, headers?: AxiosRequestHeaders): Promise<import("axios").AxiosResponse<any, any>>;
export type GetUploadTasksInFolder_UploadTask = {
    upload_task_id: string;
    folder_id: string;
    uploaded_at: string;
    uploaded_by: GetUploadTasksInFolder_Object;
    progress: number;
    download_progress?: number;
    status: StrictUnion<'waiting' | 'downloading' | 'pending' | 'converting' | 'error' | 'success' | 'rejected'> & string;
    conversion_tasks: Array<GetUploadTasksInFolder_ConversionTask>;
};
export type GetUploadTasksInFolder_Object = {
    user_id: string;
    username: string;
};
export type GetUploadTasksInFolder_ConversionTask = {
    asset_id: string;
    source_file_id: string;
    source_file_name: string;
    conversion_pipeline: 'auto-detect' | 'volume' | 'scene' | 'texture' | 'animation' | 'point-cloud';
    progress: number;
    status: StrictUnion<'pending' | 'converting' | 'error' | 'success'> & string;
};
/**
 * Lists all upload tasks in a folder.
 */
export declare function getUploadTasksInFolder({ folder_id, offset, limit, }: {
    folder_id: string;
    offset?: number;
    limit?: number;
}, headers?: AxiosRequestHeaders): AxiosPromise<Array<GetUploadTasksInFolder_UploadTask>>;
export type GetFolderAssets_Filters = {
    asset_name?: string;
    asset_type?: Array<'action_map' | 'algorithm' | 'animation' | 'animation_graph' | 'animation_sequence' | 'animation_set' | 'collision_geometry' | 'cubemap' | 'event_map' | 'material' | 'mesh' | 'module' | 'point_cloud' | 'render_graph' | 'scene' | 'script' | 'shader' | 'skeleton' | 'sound' | 'texture' | 'texture_1d' | 'texture_3d' | 'volume_material'> | 'action_map' | 'algorithm' | 'animation' | 'animation_graph' | 'animation_sequence' | 'animation_set' | 'collision_geometry' | 'cubemap' | 'event_map' | 'material' | 'mesh' | 'module' | 'point_cloud' | 'render_graph' | 'scene' | 'script' | 'shader' | 'skeleton' | 'sound' | 'texture' | 'texture_1d' | 'texture_3d' | 'volume_material';
    source_file?: Array<string> | string | 'exclude';
};
export type GetFolderAssets_AssetCount = {
    total: number;
    [asset_type: string]: number;
};
export type GetFolderAssets__index_AssetList_AssetList = {
    action_maps?: Array<GetFolderAssets_Object>;
    algorithms?: Array<GetFolderAssets_Object>;
    animation_graphs?: Array<GetFolderAssets_Object>;
    animation_sequences?: Array<GetFolderAssets_Object>;
    animation_sets?: Array<GetFolderAssets_Object>;
    animations?: Array<GetFolderAssets_Object>;
    collision_geometries?: Array<GetFolderAssets_Object>;
    cubemaps?: Array<GetFolderAssets_Object>;
    event_maps?: Array<GetFolderAssets_Object>;
    materials?: Array<GetFolderAssets_Object>;
    meshes?: Array<GetFolderAssets_Object>;
    modules?: Array<GetFolderAssets_Object>;
    point_clouds?: Array<GetFolderAssets_Object>;
    render_graphs?: Array<GetFolderAssets_Object>;
    scenes?: Array<GetFolderAssets_Object>;
    scripts?: Array<GetFolderAssets_Object>;
    shaders?: Array<GetFolderAssets_Object>;
    skeletons?: Array<GetFolderAssets_Object>;
    sounds?: Array<GetFolderAssets_Object>;
    textures?: Array<GetFolderAssets_Object>;
    textures_1d?: Array<GetFolderAssets_Object>;
    textures_3d?: Array<GetFolderAssets_Object>;
    volume_materials?: Array<GetFolderAssets_Object>;
};
export type GetFolderAssets_Object = {
    asset_id: string;
    name: string;
};
/**
 * Lists assets.
 */
export declare function getFolderAssets({ folder_id, offset, limit, filter, recursive, }: {
    folder_id: string;
    offset?: number;
    limit?: number;
    filter?: GetFolderAssets_Filters;
    recursive?: boolean;
}, headers?: AxiosRequestHeaders): AxiosPromise<GetFolderAssets__index_AssetList_AssetList>;
export type CreateAsset_NewAsset = {
    asset_type: 'action_map' | 'algorithm' | 'animation_graph' | 'animation_sequence' | 'cubemap' | 'event_map' | 'material' | 'module' | 'render_graph' | 'scene' | 'script' | 'shader' | 'volume_material';
    name: string;
};
export type CreateAsset_AssetDuplication = {
    asset_type: 'action_map' | 'algorithm' | 'animation' | 'animation_graph' | 'animation_sequence' | 'animation_set' | 'collision_geometry' | 'cubemap' | 'event_map' | 'material' | 'mesh' | 'module' | 'point_cloud' | 'render_graph' | 'scene' | 'script' | 'shader' | 'skeleton' | 'sound' | 'texture' | 'texture_1d' | 'texture_3d' | 'volume_material';
    copy_from_asset_id: string;
    new_asset_name?: string;
    options?: CreateAsset_DuplicationOptions;
};
export type CreateAsset_DuplicationOptions = {
    asset_types?: Array<'action_map' | 'algorithm' | 'animation' | 'animation_graph' | 'animation_sequence' | 'animation_set' | 'collision_geometry' | 'cubemap' | 'event_map' | 'material' | 'mesh' | 'module' | 'point_cloud' | 'render_graph' | 'scene' | 'script' | 'shader' | 'skeleton' | 'sound' | 'texture' | 'texture_1d' | 'texture_3d' | 'volume_material'>;
    max_depth?: number;
};
export type CreateAsset_AssetDuplicationResult = {
    asset_id: string;
    name: string;
    source_to_copy_asset_id_map?: CreateAsset_SourceToCopyAssetIdMap;
};
export type CreateAsset_SourceToCopyAssetIdMap = {
    [source_asset_id: string]: string;
};
/**
 * Creates a new asset.
 */
export declare function createAsset({ folder_id, asset_creation_options, }: {
    folder_id: string;
    asset_creation_options: StrictUnion<CreateAsset_NewAsset | CreateAsset_AssetDuplication>;
}, headers?: AxiosRequestHeaders): AxiosPromise<CreateAsset_AssetDuplicationResult>;
/**
 * Move assets inside the specified folder.
 */
export declare function moveAssets({ folder_id, asset_ids, }: {
    folder_id: string;
    asset_ids: Array<string>;
}, headers?: AxiosRequestHeaders): Promise<import("axios").AxiosResponse<any, any>>;
export type CreateMaterial_Object = {
    asset_id: string;
};
/**
 * Creates a material.
 */
export declare function createMaterial({ folder_id, dataJson, isDoubleSided, name, shaderRef, }: {
    folder_id: string;
    dataJson: object;
    isDoubleSided: boolean;
    name: string;
    shaderRef: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<CreateMaterial_Object>;
export type CreateCubemap_Object = {
    asset_id: string;
};
/**
 * Creates a cubemap.
 */
export declare function createCubemap({ folder_id, faces, name, }: {
    folder_id: string;
    faces: Array<string>;
    name: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<CreateCubemap_Object>;
export type ImportAssets__index_ImportAssetsResponse_ImportAssetsResponse = {
    asset_ids: ImportAssets_AssetIds;
    skipped_files?: Array<string>;
};
export type ImportAssets_AssetIds = {
    imported: Array<string>;
    overwritten: Array<string>;
    skipped: Array<string>;
};
/**
 * Imports or replaces multiple assets submitted as a package.
 * The package must be a zip archive containing the assets to import.
 * The package should contain the assets themselves at the root level of the archive with their descriptions in JSON format, and their payloads (e.g. textures, meshes, etc.)
 * and contain all the assets' dependencies if they do not already exist.
 * Supported assets are :
 *   - scene
 *   - mesh
 *   - material
 *   - animation
 *   - animation_set
 *   - animation_graph
 *   - skeleton
 *   - texture_1d
 *   - texture
 *   - texture_3d
 *   - collision_geometry
 *   - cubemap
 *   - volume_material
 *   - event_map
 *   - action_map
 *   - sound
 *   - point_cloud
 * The packaged assets' files should be named according to the following pattern:
 * ``` json
 * - desc.[asset_type].{uuid}
 * - payload.[mesh|texture|animation|skeleton|texture_1d|texture_3d|collision_geometry|sound].{uuid}
 * - payload.[texture_1d|texture|texture_3d].mips[0-16].{uuid}
 * - payload.point_cloud.[position|color].{uuid}
 * - payload.texture_3d.histogram.{uuid}
 * ```
 * The package may also contain an overwrite.json file that describes which assets to overwrite.
 * The overwrite.json file is only used if the overwrite query parameter is set to only-specified.
 */
export declare function importAssets({ folder_id, overwrite, body, }: {
    folder_id: string;
    overwrite?: StrictUnion<'never' | 'only-specified' | 'always'>;
    body: ArrayBuffer | ReadableStream;
}, onUploadProgress?: (progressEvent: AxiosProgressEvent) => void, headers?: AxiosRequestHeaders): AxiosPromise<ImportAssets__index_ImportAssetsResponse_ImportAssetsResponse>;
export type GetSessionsInFolder_Session = {
    session_id: string;
    scene_id: string;
    scene_name: string;
    folder_id: string;
    max_users: number;
    creator_user_id: string;
    created_at: string;
    country_code: string;
    continent_code: string;
    is_transient_session: boolean;
    clients: Array<GetSessionsInFolder_Client_UserInfo>;
};
export type GetSessionsInFolder_Client_UserInfo = {
    client_id?: string;
    client_type?: StrictUnion<'user' | 'guest'>;
    user_id: string;
    username: string;
};
/**
 * Lists all sessions running on scenes contained in a specified folder.
 */
export declare function getSessionsInFolder({ folder_id, }: {
    folder_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<Array<GetSessionsInFolder_Session>>;
export type ListSourceFiles_Filters = {
    source_file_name?: string;
};
export type ListSourceFiles_SourceFile = {
    source_file_id: string;
    source_file_original_name: string;
    name: string;
    size: number;
};
/**
 * List source files.
 */
export declare function listSourceFiles({ offset, limit, filters, }: {
    offset?: number;
    limit?: number;
    filters?: ListSourceFiles_Filters;
}, headers?: AxiosRequestHeaders): AxiosPromise<Array<ListSourceFiles_SourceFile>>;
/**
 * Deletes the target source files. Deleting a source file is permanent.
 */
export declare function deleteSourceFiles({ source_file_ids, delete_assets, }: {
    source_file_ids: Array<string>;
    delete_assets?: boolean;
}, headers?: AxiosRequestHeaders): Promise<import("axios").AxiosResponse<any, any>>;
/**
 * Downloads the target source file.
 */
export declare function downloadSourceFile<T extends 'arraybuffer' | 'stream' | 'json' | 'text' = 'arraybuffer'>({ source_file_id, }: {
    source_file_id: string;
}, headers?: AxiosRequestHeaders, responseType?: T): AxiosPromise<T extends 'arraybuffer' ? ArrayBuffer : T extends 'json' ? object : T extends 'text' ? string : T extends 'stream' ? ReadableStream : never>;
export type GetSourceFileDetails_SourceFile = {
    source_file_id: string;
    source_file_original_name: string;
    name: string;
    size: number;
};
/**
 * Get source file details.
 */
export declare function getSourceFileDetails({ source_file_id, }: {
    source_file_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<GetSourceFileDetails_SourceFile>;
/**
 * Updates details for a specific source file.
 */
export declare function updateSourceFileDetails({ source_file_id, name, }: {
    source_file_id: string;
    name: string;
}, headers?: AxiosRequestHeaders): Promise<import("axios").AxiosResponse<any, any>>;
export type GetSourceFileAssets__index_AssetList_AssetList = {
    action_maps?: Array<GetSourceFileAssets_Object>;
    algorithms?: Array<GetSourceFileAssets_Object>;
    animation_graphs?: Array<GetSourceFileAssets_Object>;
    animation_sequences?: Array<GetSourceFileAssets_Object>;
    animation_sets?: Array<GetSourceFileAssets_Object>;
    animations?: Array<GetSourceFileAssets_Object>;
    collision_geometries?: Array<GetSourceFileAssets_Object>;
    cubemaps?: Array<GetSourceFileAssets_Object>;
    event_maps?: Array<GetSourceFileAssets_Object>;
    materials?: Array<GetSourceFileAssets_Object>;
    meshes?: Array<GetSourceFileAssets_Object>;
    modules?: Array<GetSourceFileAssets_Object>;
    point_clouds?: Array<GetSourceFileAssets_Object>;
    render_graphs?: Array<GetSourceFileAssets_Object>;
    scenes?: Array<GetSourceFileAssets_Object>;
    scripts?: Array<GetSourceFileAssets_Object>;
    shaders?: Array<GetSourceFileAssets_Object>;
    skeletons?: Array<GetSourceFileAssets_Object>;
    sounds?: Array<GetSourceFileAssets_Object>;
    textures?: Array<GetSourceFileAssets_Object>;
    textures_1d?: Array<GetSourceFileAssets_Object>;
    textures_3d?: Array<GetSourceFileAssets_Object>;
    volume_materials?: Array<GetSourceFileAssets_Object>;
};
export type GetSourceFileAssets_Object = {
    asset_id: string;
    name: string;
};
/**
 * Lists all assets generated from the requested source file.
 */
export declare function getSourceFileAssets({ source_file_id, }: {
    source_file_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<GetSourceFileAssets__index_AssetList_AssetList>;
/**
 * Lists all upload tasks. These upload tasks relate to uploaded source files.
 */
export declare function getUploadTasks({ offset, limit, }: {
    offset?: number;
    limit?: number;
}, headers?: AxiosRequestHeaders): AxiosPromise<any>;
export type GetUploadTask_UploadTask = {
    upload_task_id: string;
    folder_id: string;
    uploaded_at: string;
    uploaded_by: GetUploadTask_Object;
    progress: number;
    download_progress?: number;
    status: StrictUnion<'waiting' | 'downloading' | 'pending' | 'converting' | 'error' | 'success' | 'rejected'> & string;
    conversion_tasks: Array<GetUploadTask_ConversionTask>;
};
export type GetUploadTask_Object = {
    user_id: string;
    username: string;
};
export type GetUploadTask_ConversionTask = {
    asset_id: string;
    source_file_id: string;
    source_file_name: string;
    conversion_pipeline: 'auto-detect' | 'volume' | 'scene' | 'texture' | 'animation' | 'point-cloud';
    progress: number;
    status: StrictUnion<'pending' | 'converting' | 'error' | 'success'> & string;
};
/**
 * Gets information related to an upload task. This upload task relates to uploaded source files.
 */
export declare function getUploadTask({ upload_task_id, }: {
    upload_task_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<GetUploadTask_UploadTask>;
/**
 * Gets metadata related to a conversion task. This metadata is produced by the conversion task.
 */
export declare function getConversionTaskMetadata<T extends 'arraybuffer' | 'stream' | 'json' | 'text' = 'arraybuffer'>({ conversion_task_id, filename, }: {
    conversion_task_id: string;
    filename: string;
}, headers?: AxiosRequestHeaders, responseType?: T): AxiosPromise<T extends 'arraybuffer' ? ArrayBuffer : T extends 'json' ? object : T extends 'text' ? string : T extends 'stream' ? ReadableStream : never>;
export type ListAssets_Filter = {
    asset_type?: Array<'action_map' | 'algorithm' | 'animation' | 'animation_graph' | 'animation_sequence' | 'animation_set' | 'collision_geometry' | 'cubemap' | 'event_map' | 'material' | 'mesh' | 'module' | 'point_cloud' | 'render_graph' | 'scene' | 'script' | 'shader' | 'skeleton' | 'sound' | 'texture' | 'texture_1d' | 'texture_3d' | 'volume_material'> | 'action_map' | 'algorithm' | 'animation' | 'animation_graph' | 'animation_sequence' | 'animation_set' | 'collision_geometry' | 'cubemap' | 'event_map' | 'material' | 'mesh' | 'module' | 'point_cloud' | 'render_graph' | 'scene' | 'script' | 'shader' | 'skeleton' | 'sound' | 'texture' | 'texture_1d' | 'texture_3d' | 'volume_material';
    asset_name?: string;
    include_public_assets?: boolean;
};
export type ListAssets__index_AssetList_AssetList = {
    action_maps?: Array<ListAssets_Object>;
    algorithms?: Array<ListAssets_Object>;
    animation_graphs?: Array<ListAssets_Object>;
    animation_sequences?: Array<ListAssets_Object>;
    animation_sets?: Array<ListAssets_Object>;
    animations?: Array<ListAssets_Object>;
    collision_geometries?: Array<ListAssets_Object>;
    cubemaps?: Array<ListAssets_Object>;
    event_maps?: Array<ListAssets_Object>;
    materials?: Array<ListAssets_Object>;
    meshes?: Array<ListAssets_Object>;
    modules?: Array<ListAssets_Object>;
    point_clouds?: Array<ListAssets_Object>;
    render_graphs?: Array<ListAssets_Object>;
    scenes?: Array<ListAssets_Object>;
    scripts?: Array<ListAssets_Object>;
    shaders?: Array<ListAssets_Object>;
    skeletons?: Array<ListAssets_Object>;
    sounds?: Array<ListAssets_Object>;
    textures?: Array<ListAssets_Object>;
    textures_1d?: Array<ListAssets_Object>;
    textures_3d?: Array<ListAssets_Object>;
    volume_materials?: Array<ListAssets_Object>;
};
export type ListAssets_Object = {
    asset_id: string;
    name: string;
};
/**
 * Returns a list of all assets.
 */
export declare function listAssets({ offset, limit, filter, }: {
    offset?: number;
    limit?: number;
    filter?: ListAssets_Filter;
}, headers?: AxiosRequestHeaders): AxiosPromise<ListAssets__index_AssetList_AssetList>;
/**
 * Batch delete assets. You **MUST NOT** reference assets.
 */
export declare function deleteAssets({ asset_ids, }: {
    asset_ids: Array<string>;
}, headers?: AxiosRequestHeaders): Promise<import("axios").AxiosResponse<any, any>>;
/**
 * Deletes the asset.
 */
export declare function deleteAsset({ asset_container, asset_id, }: {
    asset_container: 'action_maps' | 'algorithms' | 'animations' | 'animation_graphs' | 'animation_sequences' | 'animation_sets' | 'collision_geometries' | 'cubemaps' | 'event_maps' | 'materials' | 'meshes' | 'modules' | 'point_clouds' | 'render_graphs' | 'scenes' | 'scripts' | 'shaders' | 'skeletons' | 'sounds' | 'textures' | 'textures_1d' | 'textures_3d' | 'volume_materials';
    asset_id: string;
}, headers?: AxiosRequestHeaders): Promise<import("axios").AxiosResponse<any, any>>;
export type GetAssetSourceFile_SourceFile = {
    source_file_id: string;
    source_file_original_name: string;
    name: string;
    size: number;
};
/**
 * Gets the source file of the specified asset.
 */
export declare function getAssetSourceFile({ asset_container, asset_id, }: {
    asset_container: 'action_maps' | 'algorithms' | 'animations' | 'animation_graphs' | 'animation_sequences' | 'animation_sets' | 'collision_geometries' | 'cubemaps' | 'event_maps' | 'materials' | 'meshes' | 'modules' | 'point_clouds' | 'render_graphs' | 'scenes' | 'scripts' | 'shaders' | 'skeletons' | 'sounds' | 'textures' | 'textures_1d' | 'textures_3d' | 'volume_materials';
    asset_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<GetAssetSourceFile_SourceFile>;
export type GetAssetDetails__index_AssetDetails_AssetDetails = {
    asset_id: string;
    contributors?: Array<GetAssetDetails_Contributor>;
    created_at?: string;
    created_by?: GetAssetDetails_Object;
    last_edited_at?: string;
    last_edited_by?: GetAssetDetails_LastEditedBy;
    name: string;
    type: 'action_map' | 'algorithm' | 'animation' | 'animation_graph' | 'animation_sequence' | 'animation_set' | 'collision_geometry' | 'cubemap' | 'event_map' | 'material' | 'mesh' | 'module' | 'point_cloud' | 'render_graph' | 'scene' | 'script' | 'shader' | 'skeleton' | 'sound' | 'texture' | 'texture_1d' | 'texture_3d' | 'volume_material';
};
export type GetAssetDetails_Contributor = {
    contribution_count: number;
    user: GetAssetDetails_Object;
};
export type GetAssetDetails_Object = {
    registered_at: string;
    user_id: string;
    username: string;
};
export type GetAssetDetails_LastEditedBy = {
    registered_at: string;
    user_id: string;
    username: string;
};
/**
 * Gets the asset details from the specified asset.
 */
export declare function getAssetDetails({ asset_container, asset_id, }: {
    asset_container: 'action_maps' | 'algorithms' | 'animations' | 'animation_graphs' | 'animation_sequences' | 'animation_sets' | 'collision_geometries' | 'cubemaps' | 'event_maps' | 'materials' | 'meshes' | 'modules' | 'point_clouds' | 'render_graphs' | 'scenes' | 'scripts' | 'shaders' | 'skeletons' | 'sounds' | 'textures' | 'textures_1d' | 'textures_3d' | 'volume_materials';
    asset_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<GetAssetDetails__index_AssetDetails_AssetDetails>;
export type GetAssetFolder_Folder = {
    folder_id: string;
    parent_folder_id?: string;
    name: string;
    created_at?: string;
    created_by?: GetAssetFolder_Object;
    subfolders?: Array<GetAssetFolder_Folder>;
    source_file_count?: number;
    asset_count?: number;
};
export type GetAssetFolder_Object = {
    user_id: string;
    username: string;
    registered_at: string;
};
/**
 * Gets the asset folder from the specified asset.
 */
export declare function getAssetFolder({ asset_container, asset_id, }: {
    asset_container: 'action_maps' | 'algorithms' | 'animations' | 'animation_graphs' | 'animation_sequences' | 'animation_sets' | 'collision_geometries' | 'cubemaps' | 'event_maps' | 'materials' | 'meshes' | 'modules' | 'point_clouds' | 'render_graphs' | 'scenes' | 'scripts' | 'shaders' | 'skeletons' | 'sounds' | 'textures' | 'textures_1d' | 'textures_3d' | 'volume_materials';
    asset_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<GetAssetFolder_Folder>;
export type GetAssetDependencies_Filter = {
    with_asset_types?: Array<'action_map' | 'algorithm' | 'animation' | 'animation_graph' | 'animation_sequence' | 'animation_set' | 'collision_geometry' | 'cubemap' | 'event_map' | 'material' | 'mesh' | 'module' | 'point_cloud' | 'render_graph' | 'scene' | 'script' | 'shader' | 'skeleton' | 'sound' | 'texture' | 'texture_1d' | 'texture_3d' | 'volume_material'>;
    without_asset_types?: Array<'action_map' | 'algorithm' | 'animation' | 'animation_graph' | 'animation_sequence' | 'animation_set' | 'collision_geometry' | 'cubemap' | 'event_map' | 'material' | 'mesh' | 'module' | 'point_cloud' | 'render_graph' | 'scene' | 'script' | 'shader' | 'skeleton' | 'sound' | 'texture' | 'texture_1d' | 'texture_3d' | 'volume_material'>;
    public?: StrictUnion<'include' | 'exclude' | 'restrict-to'>;
};
export type GetAssetDependencies_Asset = {
    asset_id: string;
    asset_type: 'action_map' | 'algorithm' | 'animation' | 'animation_graph' | 'animation_sequence' | 'animation_set' | 'collision_geometry' | 'cubemap' | 'event_map' | 'material' | 'mesh' | 'module' | 'point_cloud' | 'render_graph' | 'scene' | 'script' | 'shader' | 'skeleton' | 'sound' | 'texture' | 'texture_1d' | 'texture_3d' | 'volume_material';
    properties?: GetAssetDependencies_Object;
};
export type GetAssetDependencies_Object = {
    name?: string;
    direct_count?: number;
    indirect_count?: number;
    is_public?: boolean;
    is_accessible?: boolean;
    payload_info?: GetAssetDependencies_PayloadInfo;
    dependencies?: Array<GetAssetDependencies_Dependency>;
};
export type GetAssetDependencies_PayloadInfo = {
    hash?: string;
    storage_id?: number;
};
export type GetAssetDependencies_Dependency = {
    asset_id: string;
    count: number;
};
/**
 * Gets the asset dependencies from the specified asset.
 */
export declare function getAssetDependencies({ asset_container, asset_id, offset, limit, depth, filters, properties, }: {
    asset_container: 'action_maps' | 'algorithms' | 'animations' | 'animation_graphs' | 'animation_sequences' | 'animation_sets' | 'collision_geometries' | 'cubemaps' | 'event_maps' | 'materials' | 'meshes' | 'modules' | 'point_clouds' | 'render_graphs' | 'scenes' | 'scripts' | 'shaders' | 'skeletons' | 'sounds' | 'textures' | 'textures_1d' | 'textures_3d' | 'volume_materials';
    asset_id: string;
    offset?: number;
    limit?: number;
    depth?: 'all' | 'direct' | number;
    filters?: GetAssetDependencies_Filter;
    properties?: Array<StrictUnion<'name' | 'dependencies' | 'count' | 'public' | 'accessible' | 'payload_info'>>;
}, headers?: AxiosRequestHeaders): AxiosPromise<Array<GetAssetDependencies_Asset>>;
export type GetAssetReferences_Asset = {
    asset_id: string;
    asset_type: 'action_map' | 'algorithm' | 'animation' | 'animation_graph' | 'animation_sequence' | 'animation_set' | 'collision_geometry' | 'cubemap' | 'event_map' | 'material' | 'mesh' | 'module' | 'point_cloud' | 'render_graph' | 'scene' | 'script' | 'shader' | 'skeleton' | 'sound' | 'texture' | 'texture_1d' | 'texture_3d' | 'volume_material';
    properties?: GetAssetReferences_Object;
};
export type GetAssetReferences_Object = {
    name?: string;
    direct_count?: number;
    is_public?: boolean;
};
/**
 * Gets the asset references from the specified asset.
 */
export declare function getAssetReferences({ asset_container, asset_id, offset, limit, properties, }: {
    asset_container: 'action_maps' | 'algorithms' | 'animations' | 'animation_graphs' | 'animation_sequences' | 'animation_sets' | 'collision_geometries' | 'cubemaps' | 'event_maps' | 'materials' | 'meshes' | 'modules' | 'point_clouds' | 'render_graphs' | 'scenes' | 'scripts' | 'shaders' | 'skeletons' | 'sounds' | 'textures' | 'textures_1d' | 'textures_3d' | 'volume_materials';
    asset_id: string;
    offset?: number;
    limit?: number;
    properties?: Array<StrictUnion<'name' | 'count' | 'public'>>;
}, headers?: AxiosRequestHeaders): AxiosPromise<Array<GetAssetReferences_Asset>>;
export type GetAssetDescription_ActionMap = {
    actions: GetAssetDescription_Object;
    name: string;
    uuid: string;
};
export type GetAssetDescription_Object = {
    [action_name: string]: object;
};
export type GetAssetDescription_Algorithm = {
    inputDescriptor: Array<object>;
    name: string;
    outputDescriptor: Array<object>;
    uuid: string;
};
export type GetAssetDescription_Animation = {
    animationEventTrack: GetAssetDescription_Object;
    durationInMs: number;
    name: string;
    payloadSize: number;
    skeletonRef?: string;
    uuid: string;
};
export type GetAssetDescription_AnimationGraph = {
    inputDescriptor: Array<object>;
    name: string;
    stateMachines: Array<GetAssetDescription_Object>;
    uuid: string;
};
export type GetAssetDescription_AnimationSequence = {
    durationInMs: number;
    name: string;
    uuid: string;
};
export type GetAssetDescription_AnimationSet = {
    animationGraphUUID: string;
    animationSet: Array<GetAssetDescription_Object>;
    boneMaskSet?: Array<GetAssetDescription_Object>;
    name: string;
    uuid: string;
};
export type GetAssetDescription_CollisionGeometry = {
    geometryType: StrictUnion<0 | 1>;
    name: string;
    payloadSize: number;
    uuid: string;
};
export type GetAssetDescription_Cubemap = {
    faces: Array<string>;
    name: string;
    uuid: string;
};
export type GetAssetDescription_EventMap = {
    events: GetAssetDescription_Object;
    name: string;
    uuid: string;
};
export type GetAssetDescription_Material = {
    dataJson: object;
    isDoubleSided: boolean;
    name: string;
    shaderRef: string;
    uuid: string;
};
export type GetAssetDescription_Mesh = {
    name: string;
    payloadSize: number;
    submeshes: Array<GetAssetDescription_Submesh>;
    uuid: string;
};
export type GetAssetDescription_Submesh = {
    aabb: GetAssetDescription_BoundingBox;
    channels: Array<GetAssetDescription_Channel>;
    indexCount: number;
    vertexCount: number;
};
export type GetAssetDescription_BoundingBox = {
    max: Array<number>;
    min: Array<number>;
};
export type GetAssetDescription_Channel = {
    dataOffset: number;
    dataSize: number;
    elementCount: number;
    elementSize: number;
    elementType: StrictUnion<0 | 1 | 2> & number;
    semantic: StrictUnion<'index' | 'position' | 'normal' | 'uv' | 'color' | 'bone_id' | 'weight'>;
};
export type GetAssetDescription_Module = {
    functions: GetAssetDescription_Object;
    name: string;
    uuid: string;
};
export type GetAssetDescription_PointCloud = {
    format: StrictUnion<0 | 1 | 2>;
    name: string;
    payloadTotalSize: number;
    pointCount: number;
    scale?: Array<number>;
    translation?: Array<number>;
    uuid: string;
};
export type GetAssetDescription_RenderGraph = {
    blendStates: Array<GetAssetDescription_Object>;
    defaultRenderTargetIndex?: number;
    graphOrder: Array<Array<number>>;
    inputDescriptor: Array<GetAssetDescription_Object>;
    name: string;
    nodeDataDescriptions: Array<GetAssetDescription_Object>;
    occlusionInputDepthRenderTargetIndex?: number;
    renderPassDescriptions: Array<GetAssetDescription_Object>;
    renderTargetDescriptions: Array<GetAssetDescription_Object>;
    stencilStates: Array<GetAssetDescription_Object>;
    uuid: string;
};
export type GetAssetDescription_Scene = {
    aabb: GetAssetDescription_Aabb;
    entities: Array<object>;
    name: string;
    settings?: object;
    triangleCount?: number;
    uuid: string;
};
export type GetAssetDescription_Aabb = {
    max: Array<number>;
    min: Array<number>;
};
export type GetAssetDescription_Script = {
    eventNames: Array<string>;
    inputDescriptor?: Array<GetAssetDescription_Object>;
    name: string;
    subScripts?: Array<string>;
    uuid: string;
};
export type GetAssetDescription_Shader = {
    blendMode?: StrictUnion<0 | 1 | 2 | 3>;
    localGroupCount?: Array<number>;
    materialDescriptor?: Array<GetAssetDescription_Object>;
    moduleDescriptions?: Array<GetAssetDescription_Object>;
    name: string;
    nodeDataDescriptor?: Array<GetAssetDescription_Object>;
    optGlobalGroupMultiplier?: Array<number>;
    optGlobalGroupReference?: StrictUnion<0 | 1 | 2 | 3 | 4>;
    payloadSize: number;
    shaderStages?: number;
    uuid: string;
    vertexDescriptor?: Array<GetAssetDescription_Object>;
};
export type GetAssetDescription_Skeleton = {
    bones: Array<GetAssetDescription_Object>;
    name: string;
    payloadSize: number;
    uuid: string;
};
export type GetAssetDescription_Sound = {
    bitDepth: number;
    channelCount: number;
    durationInMs: number;
    name: string;
    payloadSize: number;
    sampleCount: number;
    sampleFrequencyInHz: number;
    uuid: string;
};
export type GetAssetDescription_Texture = {
    format: StrictUnion<0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14> & any;
    mips: Array<GetAssetDescription_Object>;
    name: string;
    payloadTotalSize: number;
    uuid: string;
};
export type GetAssetDescription_Texture_1D = {
    format: StrictUnion<0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14> & any;
    mips: Array<GetAssetDescription_Object>;
    name: string;
    payloadTotalSize: number;
    uuid: string;
};
export type GetAssetDescription_Texture_3D = {
    format: StrictUnion<0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14> & any;
    mips: Array<GetAssetDescription_Object>;
    name: string;
    payloadTotalSize: number;
    uuid: string;
    voxelDimensions?: Array<number>;
};
export type GetAssetDescription_VolumeMaterial = {
    albedoLUT?: Array<GetAssetDescription_Object>;
    metallicLUT?: Array<GetAssetDescription_Object>;
    name: string;
    opacityLUT?: Array<GetAssetDescription_Object>;
    rangeMax: number;
    rangeMin: number;
    roughnessLUT?: Array<GetAssetDescription_Object>;
    uuid: string;
};
/**
 * Gets the asset description from the specified asset.
 */
export declare function getAssetDescription({ asset_container, asset_id, }: {
    asset_container: 'action_maps' | 'algorithms' | 'animations' | 'animation_graphs' | 'animation_sequences' | 'animation_sets' | 'collision_geometries' | 'cubemaps' | 'event_maps' | 'materials' | 'meshes' | 'modules' | 'point_clouds' | 'render_graphs' | 'scenes' | 'scripts' | 'shaders' | 'skeletons' | 'sounds' | 'textures' | 'textures_1d' | 'textures_3d' | 'volume_materials';
    asset_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<StrictUnion<GetAssetDescription_ActionMap | GetAssetDescription_Algorithm | GetAssetDescription_Animation | GetAssetDescription_AnimationGraph | GetAssetDescription_AnimationSequence | GetAssetDescription_AnimationSet | GetAssetDescription_CollisionGeometry | GetAssetDescription_Cubemap | GetAssetDescription_EventMap | GetAssetDescription_Material | GetAssetDescription_Mesh | GetAssetDescription_Module | GetAssetDescription_PointCloud | GetAssetDescription_RenderGraph | GetAssetDescription_Scene | GetAssetDescription_Script | GetAssetDescription_Shader | GetAssetDescription_Skeleton | GetAssetDescription_Sound | GetAssetDescription_Texture | GetAssetDescription_Texture_1D | GetAssetDescription_Texture_3D | GetAssetDescription_VolumeMaterial>>;
/**
 * Updates asset description. Supports only updating name.
 */
export declare function renameAsset({ asset_container, asset_id, name, }: {
    asset_container: 'action_maps' | 'algorithms' | 'animations' | 'animation_graphs' | 'animation_sequences' | 'animation_sets' | 'collision_geometries' | 'cubemaps' | 'event_maps' | 'materials' | 'meshes' | 'modules' | 'point_clouds' | 'render_graphs' | 'scenes' | 'scripts' | 'shaders' | 'skeletons' | 'sounds' | 'textures' | 'textures_1d' | 'textures_3d' | 'volume_materials';
    asset_id: string;
    name?: string;
}, headers?: AxiosRequestHeaders): Promise<import("axios").AxiosResponse<any, any>>;
/**
 * Gets the asset payload from the specified asset.
 */
export declare function getAssetPayload<T extends 'arraybuffer' | 'stream' | 'json' | 'text' = 'arraybuffer'>({ asset_container_with_payload, asset_id, sub_resource, }: {
    asset_container_with_payload: 'animations' | 'animation_sequences' | 'collision_geometries' | 'meshes' | 'point_clouds' | 'scripts' | 'shaders' | 'skeletons' | 'sounds' | 'textures' | 'textures_1d' | 'textures_3d';
    asset_id: string;
    sub_resource?: StrictUnion<string | 'histogram' | 'position' | 'color'>;
}, headers?: AxiosRequestHeaders, responseType?: T): AxiosPromise<T extends 'arraybuffer' ? ArrayBuffer : T extends 'json' ? object : T extends 'text' ? string : T extends 'stream' ? ReadableStream : never>;
/**
 * Gets the asset history from the specified asset.
 */
export declare function getAssetHistory({ asset_container, asset_id, }: {
    asset_container: 'action_maps' | 'algorithms' | 'animations' | 'animation_graphs' | 'animation_sequences' | 'animation_sets' | 'collision_geometries' | 'cubemaps' | 'event_maps' | 'materials' | 'meshes' | 'modules' | 'point_clouds' | 'render_graphs' | 'scenes' | 'scripts' | 'shaders' | 'skeletons' | 'sounds' | 'textures' | 'textures_1d' | 'textures_3d' | 'volume_materials';
    asset_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<object>;
/**
 * Gets the asset metadata from the specified asset.
 */
export declare function getAssetMeta({ asset_container, asset_id, }: {
    asset_container: 'action_maps' | 'algorithms' | 'animations' | 'animation_graphs' | 'animation_sequences' | 'animation_sets' | 'collision_geometries' | 'cubemaps' | 'event_maps' | 'materials' | 'meshes' | 'modules' | 'point_clouds' | 'render_graphs' | 'scenes' | 'scripts' | 'shaders' | 'skeletons' | 'sounds' | 'textures' | 'textures_1d' | 'textures_3d' | 'volume_materials';
    asset_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<object>;
/**
 * Gets the code of the specified asset.
 */
export declare function getAssetCode({ asset_container_with_code, asset_id, }: {
    asset_container_with_code: 'algorithms' | 'animation_sequences' | 'modules' | 'scripts' | 'shaders';
    asset_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<string>;
/**
 * Gets the asset thumbnail from the specified asset.
 */
export declare function getAssetThumbnail<T extends 'arraybuffer' | 'stream' | 'json' | 'text' = 'arraybuffer'>({ asset_container, asset_id, size, default_url, }: {
    asset_container: 'action_maps' | 'algorithms' | 'animations' | 'animation_graphs' | 'animation_sequences' | 'animation_sets' | 'collision_geometries' | 'cubemaps' | 'event_maps' | 'materials' | 'meshes' | 'modules' | 'point_clouds' | 'render_graphs' | 'scenes' | 'scripts' | 'shaders' | 'skeletons' | 'sounds' | 'textures' | 'textures_1d' | 'textures_3d' | 'volume_materials';
    asset_id: string;
    size: 'large' | 'medium' | 'small' | 'tiny';
    default_url?: string;
}, headers?: AxiosRequestHeaders, responseType?: T): AxiosPromise<T extends 'arraybuffer' ? ArrayBuffer : T extends 'json' ? object : T extends 'text' ? string : T extends 'stream' ? ReadableStream : never>;
/**
 * Assigns a thumbnail to the specified asset.
 */
export declare function setAssetThumbnail({ asset_container, asset_id, body, }: {
    asset_container: 'action_maps' | 'algorithms' | 'animations' | 'animation_graphs' | 'animation_sequences' | 'animation_sets' | 'collision_geometries' | 'cubemaps' | 'event_maps' | 'materials' | 'meshes' | 'modules' | 'point_clouds' | 'render_graphs' | 'scenes' | 'scripts' | 'shaders' | 'skeletons' | 'sounds' | 'textures' | 'textures_1d' | 'textures_3d' | 'volume_materials';
    asset_id: string;
    body: ArrayBuffer | ReadableStream;
}, contentType: 'image/jpg' | 'image/png', headers?: AxiosRequestHeaders): Promise<import("axios").AxiosResponse<any, any>>;
/**
 * Gets the asset custom types from the specified asset recursively.
 */
export declare function getAssetCustomTypes({ asset_container_with_custom_types, asset_id, }: {
    asset_container_with_custom_types: 'modules';
    asset_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<object>;
/**
 * Packages and downloads the target asset.
 */
export declare function packageAsset<T extends 'arraybuffer' | 'stream' | 'json' | 'text' = 'arraybuffer'>({ asset_container, asset_id, }: {
    asset_container: 'action_maps' | 'algorithms' | 'animations' | 'animation_graphs' | 'animation_sequences' | 'animation_sets' | 'collision_geometries' | 'cubemaps' | 'event_maps' | 'materials' | 'meshes' | 'modules' | 'point_clouds' | 'render_graphs' | 'scenes' | 'scripts' | 'shaders' | 'skeletons' | 'sounds' | 'textures' | 'textures_1d' | 'textures_3d' | 'volume_materials';
    asset_id: string;
}, headers?: AxiosRequestHeaders, responseType?: T): AxiosPromise<T extends 'arraybuffer' ? ArrayBuffer : T extends 'json' ? object : T extends 'text' ? string : T extends 'stream' ? ReadableStream : never>;
/**
 * Downloads an asset payload in a given format. Only mesh is supported for the moment. This endpoint requires special export permission.
 */
export declare function exportAsset<T extends 'arraybuffer' | 'stream' | 'json' | 'text' = 'arraybuffer'>({ asset_container_exportable, asset_id, format, scale, sub_mesh_index, }: {
    asset_container_exportable: 'meshes' | 'sounds';
    asset_id: string;
    format: 'obj' | 'stl';
    scale?: number;
    sub_mesh_index?: number;
}, headers?: AxiosRequestHeaders, responseType?: T): AxiosPromise<T extends 'arraybuffer' ? ArrayBuffer : T extends 'json' ? object : T extends 'text' ? string : T extends 'stream' ? ReadableStream : never>;
export type GetSceneSessions_Session = {
    session_id: string;
    scene_id: string;
    scene_name: string;
    folder_id: string;
    max_users: number;
    creator_user_id: string;
    created_at: string;
    country_code: string;
    continent_code: string;
    is_transient_session: boolean;
    clients: Array<GetSceneSessions_Client_UserInfo>;
};
export type GetSceneSessions_Client_UserInfo = {
    client_id?: string;
    client_type?: StrictUnion<'user' | 'guest'>;
    user_id: string;
    username: string;
};
/**
 * Lists all sessions running a specified scene.
 */
export declare function getSceneSessions({ scene_id, }: {
    scene_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<Array<GetSceneSessions_Session>>;
export type GetSceneAabb_Object = {
    max: Array<number>;
    min: Array<number>;
};
/**
 * Get the axis aligned bounding box of the specified scene.
 */
export declare function getSceneAABB({ scene_id, }: {
    scene_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<GetSceneAabb_Object>;
export type CreateEntity_animation_controller = {
    animation_controller: CreateEntity_AnimationController;
};
export type CreateEntity_AnimationController = {
    animationGraphRef: string;
    animationSetRef: string;
    dataJSON: object;
    rootBoneEntityRef: CreateEntity_EntityReference;
    rootMotionEnabled: boolean;
};
export type CreateEntity_EntityReference = {
    originalEUID: string;
    linkage: Array<string>;
};
export type CreateEntity_bone = {
    bone: CreateEntity_Bone;
};
export type CreateEntity_Bone = {
    boneIndex: number;
};
export type CreateEntity_box_geometry = {
    box_geometry: CreateEntity_BoxGeometry;
};
export type CreateEntity_BoxGeometry = {
    dimension?: Array<number>;
    isAdditive?: boolean;
    offset?: Array<number>;
};
export type CreateEntity_camera = {
    camera: CreateEntity_Camera;
};
export type CreateEntity_Camera = {
    renderGraphRef: string;
    renderTargetIndex?: number;
    dataJSON: object;
};
export type CreateEntity_capsule_geometry = {
    capsule_geometry: CreateEntity_CapsuleGeometry;
};
export type CreateEntity_CapsuleGeometry = {
    radius?: number;
    height?: number;
    axis?: number;
    isAdditive?: boolean;
    offset?: Array<number>;
};
export type CreateEntity_character_controller = {
    character_controller: CreateEntity_CharacterController;
};
export type CreateEntity_CharacterController = {
    stepOffset?: number;
    slopeLimit?: number;
    skinWidth?: number;
    velocity?: Array<number>;
};
export type CreateEntity_collision_geometry_ref = {
    collision_geometry_ref: CreateEntity_CollisionGeometryRef;
};
export type CreateEntity_CollisionGeometryRef = {
    collisionGeometryRef: string;
};
export type CreateEntity_cylinder_geometry = {
    cylinder_geometry: CreateEntity_CylinderGeometry;
};
export type CreateEntity_CylinderGeometry = {
    radius?: number;
    height?: number;
    axis?: number;
    isAdditive?: boolean;
    offset?: Array<number>;
};
export type CreateEntity_debug_name = {
    debug_name: CreateEntity_Name;
};
export type CreateEntity_Name = {
    value: string;
};
export type CreateEntity_decal_projector = {
    decal_projector: CreateEntity_DecalProjector;
};
export type CreateEntity_DecalProjector = {
    zIndex?: number;
};
export type CreateEntity_environment = {
    environment: CreateEntity_Environment;
};
export type CreateEntity_Environment = {
    skyboxUUID: string;
    radianceUUID: string;
    irradianceUUID: string;
};
export type CreateEntity_joint = {
    joint: CreateEntity_Joint;
};
export type CreateEntity_Joint = {
    constrainee: CreateEntity_EntityReference;
    constrainer: CreateEntity_EntityReference;
    breakForce?: number;
    breakTorque?: number;
};
export type CreateEntity_lineage = {
    lineage: CreateEntity_Lineage;
};
export type CreateEntity_Lineage = {
    parentUUID: string;
    ordinal?: number;
};
export type CreateEntity_local_aabb = {
    local_aabb: CreateEntity_LocalAxisAlignedBoundingBox;
};
export type CreateEntity_LocalAxisAlignedBoundingBox = {
    min: Array<number>;
    max: Array<number>;
};
export type CreateEntity_local_transform = {
    local_transform: CreateEntity_Transform;
};
export type CreateEntity_Transform = {
    position?: Array<number>;
    orientation?: Array<number>;
    scale?: Array<number>;
    eulerOrientation?: Array<number>;
    globalEulerOrientation?: Array<number>;
};
export type CreateEntity_material = {
    material: CreateEntity_Material;
};
export type CreateEntity_Material = {
    shaderRef: string;
    transparencyMode: number;
    isDoubleSided: boolean;
    dataJSON: object;
};
export type CreateEntity_material_ref = {
    material_ref: CreateEntity_MaterialReference;
};
export type CreateEntity_MaterialReference = {
    value: string;
    faceCulling?: number;
};
export type CreateEntity_mesh_ref = {
    mesh_ref: CreateEntity_MeshReference;
};
export type CreateEntity_MeshReference = {
    value: string;
    submeshIndex?: number;
};
export type CreateEntity_orthographic_lens = {
    orthographic_lens: CreateEntity_OrthographicLens;
};
export type CreateEntity_OrthographicLens = {
    left?: number;
    right?: number;
    top?: number;
    bottom?: number;
    zNear?: number;
    zFar?: number;
};
export type CreateEntity_overrider = {
    overrider: CreateEntity_Overrider;
};
export type CreateEntity_Overrider = {
    deleter?: boolean;
    entityRef: CreateEntity_EntityReference;
    componentsToDetach: Array<number>;
};
export type CreateEntity_perspective_lens = {
    perspective_lens: CreateEntity_PerspectiveLens;
};
export type CreateEntity_PerspectiveLens = {
    aspectRatio?: number;
    fovy?: number;
    nearPlane?: number;
    farPlane?: number;
};
export type CreateEntity_physics_material = {
    physics_material: CreateEntity_PhysicsMaterial;
};
export type CreateEntity_PhysicsMaterial = {
    staticFriction?: number;
    dynamicFriction?: number;
    restitution?: number;
    isTrigger?: boolean;
};
export type CreateEntity_plane_geometry = {
    plane_geometry: CreateEntity_PlaneGeometry;
};
export type CreateEntity_PlaneGeometry = {
    distance?: number;
    normal?: Array<number>;
};
export type CreateEntity_point_cloud_ref = {
    point_cloud_ref: CreateEntity_PointCloudReference;
};
export type CreateEntity_PointCloudReference = {
    value: string;
};
export type CreateEntity_point_light = {
    point_light: CreateEntity_Light;
};
export type CreateEntity_Light = {
    color?: Array<number>;
    intensity?: number;
    range?: number;
    isDirectional?: boolean;
    isSun?: boolean;
};
export type CreateEntity_reflection_probe = {
    reflection_probe: CreateEntity_ReflectionProbe;
};
export type CreateEntity_ReflectionProbe = {
    offset?: Array<number>;
    nearDist?: number;
    farDist?: number;
    quality?: number;
};
export type CreateEntity_revolute_joint = {
    revolute_joint: CreateEntity_RevoluteJoint;
};
export type CreateEntity_RevoluteJoint = {
    axis?: Array<number>;
    anchor?: Array<number>;
};
export type CreateEntity_rigid_body = {
    rigid_body: CreateEntity_RigidBody;
};
export type CreateEntity_RigidBody = {
    mass?: number;
    linearDamping?: number;
    angularDamping?: number;
    friction?: number;
    rollingFriction?: number;
    spinningFriction?: number;
    restitution?: number;
    linearSleepingThreshold?: number;
    angularSleepingThreshold?: number;
    isKinematic?: boolean;
};
export type CreateEntity_scene_ref = {
    scene_ref: CreateEntity_SceneReference;
};
export type CreateEntity_SceneReference = {
    value: string;
    maxRecursionCount?: number;
};
export type CreateEntity_script_element = {
    script_element: CreateEntity_ScriptElement;
};
export type CreateEntity_ScriptElement = {
    scriptRef: string;
    dataJSON: object;
};
export type CreateEntity_script_map = {
    script_map: CreateEntity_ScriptMap;
};
export type CreateEntity_ScriptMap = {
    elements: object;
};
export type CreateEntity_shadow_caster = {
    shadow_caster: CreateEntity_ShadowCaster;
};
export type CreateEntity_ShadowCaster = {
    bias?: number;
    nearDist?: number;
    farDist?: number;
    quality?: number;
    cascadeSplitLambda?: number;
    cascadeMaxZ?: number;
    accumulateShadowCascades?: boolean;
};
export type CreateEntity_skeleton_ref = {
    skeleton_ref: CreateEntity_SkeletonReference;
};
export type CreateEntity_SkeletonReference = {
    value: string;
};
export type CreateEntity_sound_ref = {
    sound_ref: CreateEntity_SoundReference;
};
export type CreateEntity_SoundReference = {
    value: string;
    volume?: number;
    pan?: number;
    playSpeed?: number;
    looping?: boolean;
};
export type CreateEntity_sphere_geometry = {
    sphere_geometry: CreateEntity_SphereGeometry;
};
export type CreateEntity_SphereGeometry = {
    radius?: number;
    isAdditive?: boolean;
    offset?: Array<number>;
};
export type CreateEntity_spot_light = {
    spot_light: CreateEntity_SpotLight;
};
export type CreateEntity_SpotLight = {
    cutoff?: number;
    IESProfile: string;
};
export type CreateEntity_stereoscopic_lens = {
    stereoscopic_lens: CreateEntity_StereoscopicPerspectiveLens;
};
export type CreateEntity_StereoscopicPerspectiveLens = {
    angleLeft?: number;
    angleRight?: number;
    angleUp?: number;
    angleDown?: number;
    nearPlane?: number;
    farPlane?: number;
    aspectRatio?: number;
};
export type CreateEntity_tags = {
    tags: CreateEntity_Tags;
};
export type CreateEntity_Tags = {
    value: Array<string>;
};
export type CreateEntity_volume_filter = {
    volume_filter: CreateEntity_VolumeFilter;
};
export type CreateEntity_VolumeFilter = {
    range?: Array<number>;
    applyGaussianFiltering?: boolean;
    sampleUnfiltered?: boolean;
    enableMPR?: boolean;
    enable3D?: boolean;
};
export type CreateEntity_volume_material_ref = {
    volume_material_ref: CreateEntity_VolumeMaterialReference;
};
export type CreateEntity_VolumeMaterialReference = {
    value: string;
};
export type CreateEntity_volume_ref = {
    volume_ref: CreateEntity_VolumeReference;
};
export type CreateEntity_VolumeReference = {
    texture3dRef: string;
};
export type CreateEntity_Object = {
    entity_id: string;
};
/**
 * Create a new entity in a scene.
 */
export declare function createEntity({ scene_id, entity_components, }: {
    scene_id: string;
    entity_components: CreateEntity_animation_controller | CreateEntity_bone | CreateEntity_box_geometry | CreateEntity_camera | CreateEntity_capsule_geometry | CreateEntity_character_controller | CreateEntity_collision_geometry_ref | CreateEntity_cylinder_geometry | CreateEntity_debug_name | CreateEntity_decal_projector | CreateEntity_environment | CreateEntity_joint | CreateEntity_lineage | CreateEntity_local_aabb | CreateEntity_local_transform | CreateEntity_material | CreateEntity_material_ref | CreateEntity_mesh_ref | CreateEntity_orthographic_lens | CreateEntity_overrider | CreateEntity_perspective_lens | CreateEntity_physics_material | CreateEntity_plane_geometry | CreateEntity_point_cloud_ref | CreateEntity_point_light | CreateEntity_reflection_probe | CreateEntity_revolute_joint | CreateEntity_rigid_body | CreateEntity_scene_ref | CreateEntity_script_element | CreateEntity_script_map | CreateEntity_shadow_caster | CreateEntity_skeleton_ref | CreateEntity_sound_ref | CreateEntity_sphere_geometry | CreateEntity_spot_light | CreateEntity_stereoscopic_lens | CreateEntity_tags | CreateEntity_volume_filter | CreateEntity_volume_material_ref | CreateEntity_volume_ref;
}, headers?: AxiosRequestHeaders): AxiosPromise<CreateEntity_Object>;
export type GetEntity_animation_controller = {
    animation_controller: GetEntity_AnimationController;
};
export type GetEntity_AnimationController = {
    animationGraphRef: string;
    animationSetRef: string;
    dataJSON: object;
    rootBoneEntityRef: GetEntity_EntityReference;
    rootMotionEnabled: boolean;
};
export type GetEntity_EntityReference = {
    originalEUID: string;
    linkage: Array<string>;
};
export type GetEntity_bone = {
    bone: GetEntity_Bone;
};
export type GetEntity_Bone = {
    boneIndex: number;
};
export type GetEntity_box_geometry = {
    box_geometry: GetEntity_BoxGeometry;
};
export type GetEntity_BoxGeometry = {
    dimension?: Array<number>;
    isAdditive?: boolean;
    offset?: Array<number>;
};
export type GetEntity_camera = {
    camera: GetEntity_Camera;
};
export type GetEntity_Camera = {
    renderGraphRef: string;
    renderTargetIndex?: number;
    dataJSON: object;
};
export type GetEntity_capsule_geometry = {
    capsule_geometry: GetEntity_CapsuleGeometry;
};
export type GetEntity_CapsuleGeometry = {
    radius?: number;
    height?: number;
    axis?: number;
    isAdditive?: boolean;
    offset?: Array<number>;
};
export type GetEntity_character_controller = {
    character_controller: GetEntity_CharacterController;
};
export type GetEntity_CharacterController = {
    stepOffset?: number;
    slopeLimit?: number;
    skinWidth?: number;
    velocity?: Array<number>;
};
export type GetEntity_collision_geometry_ref = {
    collision_geometry_ref: GetEntity_CollisionGeometryRef;
};
export type GetEntity_CollisionGeometryRef = {
    collisionGeometryRef: string;
};
export type GetEntity_cylinder_geometry = {
    cylinder_geometry: GetEntity_CylinderGeometry;
};
export type GetEntity_CylinderGeometry = {
    radius?: number;
    height?: number;
    axis?: number;
    isAdditive?: boolean;
    offset?: Array<number>;
};
export type GetEntity_debug_name = {
    debug_name: GetEntity_Name;
};
export type GetEntity_Name = {
    value: string;
};
export type GetEntity_decal_projector = {
    decal_projector: GetEntity_DecalProjector;
};
export type GetEntity_DecalProjector = {
    zIndex?: number;
};
export type GetEntity_environment = {
    environment: GetEntity_Environment;
};
export type GetEntity_Environment = {
    skyboxUUID: string;
    radianceUUID: string;
    irradianceUUID: string;
};
export type GetEntity_joint = {
    joint: GetEntity_Joint;
};
export type GetEntity_Joint = {
    constrainee: GetEntity_EntityReference;
    constrainer: GetEntity_EntityReference;
    breakForce?: number;
    breakTorque?: number;
};
export type GetEntity_lineage = {
    lineage: GetEntity_Lineage;
};
export type GetEntity_Lineage = {
    parentUUID: string;
    ordinal?: number;
};
export type GetEntity_local_aabb = {
    local_aabb: GetEntity_LocalAxisAlignedBoundingBox;
};
export type GetEntity_LocalAxisAlignedBoundingBox = {
    min: Array<number>;
    max: Array<number>;
};
export type GetEntity_local_transform = {
    local_transform: GetEntity_Transform;
};
export type GetEntity_Transform = {
    position?: Array<number>;
    orientation?: Array<number>;
    scale?: Array<number>;
    eulerOrientation?: Array<number>;
    globalEulerOrientation?: Array<number>;
};
export type GetEntity_material = {
    material: GetEntity_Material;
};
export type GetEntity_Material = {
    shaderRef: string;
    transparencyMode: number;
    isDoubleSided: boolean;
    dataJSON: object;
};
export type GetEntity_material_ref = {
    material_ref: GetEntity_MaterialReference;
};
export type GetEntity_MaterialReference = {
    value: string;
    faceCulling?: number;
};
export type GetEntity_mesh_ref = {
    mesh_ref: GetEntity_MeshReference;
};
export type GetEntity_MeshReference = {
    value: string;
    submeshIndex?: number;
};
export type GetEntity_orthographic_lens = {
    orthographic_lens: GetEntity_OrthographicLens;
};
export type GetEntity_OrthographicLens = {
    left?: number;
    right?: number;
    top?: number;
    bottom?: number;
    zNear?: number;
    zFar?: number;
};
export type GetEntity_overrider = {
    overrider: GetEntity_Overrider;
};
export type GetEntity_Overrider = {
    deleter?: boolean;
    entityRef: GetEntity_EntityReference;
    componentsToDetach: Array<number>;
};
export type GetEntity_perspective_lens = {
    perspective_lens: GetEntity_PerspectiveLens;
};
export type GetEntity_PerspectiveLens = {
    aspectRatio?: number;
    fovy?: number;
    nearPlane?: number;
    farPlane?: number;
};
export type GetEntity_physics_material = {
    physics_material: GetEntity_PhysicsMaterial;
};
export type GetEntity_PhysicsMaterial = {
    staticFriction?: number;
    dynamicFriction?: number;
    restitution?: number;
    isTrigger?: boolean;
};
export type GetEntity_plane_geometry = {
    plane_geometry: GetEntity_PlaneGeometry;
};
export type GetEntity_PlaneGeometry = {
    distance?: number;
    normal?: Array<number>;
};
export type GetEntity_point_cloud_ref = {
    point_cloud_ref: GetEntity_PointCloudReference;
};
export type GetEntity_PointCloudReference = {
    value: string;
};
export type GetEntity_point_light = {
    point_light: GetEntity_Light;
};
export type GetEntity_Light = {
    color?: Array<number>;
    intensity?: number;
    range?: number;
    isDirectional?: boolean;
    isSun?: boolean;
};
export type GetEntity_reflection_probe = {
    reflection_probe: GetEntity_ReflectionProbe;
};
export type GetEntity_ReflectionProbe = {
    offset?: Array<number>;
    nearDist?: number;
    farDist?: number;
    quality?: number;
};
export type GetEntity_revolute_joint = {
    revolute_joint: GetEntity_RevoluteJoint;
};
export type GetEntity_RevoluteJoint = {
    axis?: Array<number>;
    anchor?: Array<number>;
};
export type GetEntity_rigid_body = {
    rigid_body: GetEntity_RigidBody;
};
export type GetEntity_RigidBody = {
    mass?: number;
    linearDamping?: number;
    angularDamping?: number;
    friction?: number;
    rollingFriction?: number;
    spinningFriction?: number;
    restitution?: number;
    linearSleepingThreshold?: number;
    angularSleepingThreshold?: number;
    isKinematic?: boolean;
};
export type GetEntity_scene_ref = {
    scene_ref: GetEntity_SceneReference;
};
export type GetEntity_SceneReference = {
    value: string;
    maxRecursionCount?: number;
};
export type GetEntity_script_element = {
    script_element: GetEntity_ScriptElement;
};
export type GetEntity_ScriptElement = {
    scriptRef: string;
    dataJSON: object;
};
export type GetEntity_script_map = {
    script_map: GetEntity_ScriptMap;
};
export type GetEntity_ScriptMap = {
    elements: object;
};
export type GetEntity_shadow_caster = {
    shadow_caster: GetEntity_ShadowCaster;
};
export type GetEntity_ShadowCaster = {
    bias?: number;
    nearDist?: number;
    farDist?: number;
    quality?: number;
    cascadeSplitLambda?: number;
    cascadeMaxZ?: number;
    accumulateShadowCascades?: boolean;
};
export type GetEntity_skeleton_ref = {
    skeleton_ref: GetEntity_SkeletonReference;
};
export type GetEntity_SkeletonReference = {
    value: string;
};
export type GetEntity_sound_ref = {
    sound_ref: GetEntity_SoundReference;
};
export type GetEntity_SoundReference = {
    value: string;
    volume?: number;
    pan?: number;
    playSpeed?: number;
    looping?: boolean;
};
export type GetEntity_sphere_geometry = {
    sphere_geometry: GetEntity_SphereGeometry;
};
export type GetEntity_SphereGeometry = {
    radius?: number;
    isAdditive?: boolean;
    offset?: Array<number>;
};
export type GetEntity_spot_light = {
    spot_light: GetEntity_SpotLight;
};
export type GetEntity_SpotLight = {
    cutoff?: number;
    IESProfile: string;
};
export type GetEntity_stereoscopic_lens = {
    stereoscopic_lens: GetEntity_StereoscopicPerspectiveLens;
};
export type GetEntity_StereoscopicPerspectiveLens = {
    angleLeft?: number;
    angleRight?: number;
    angleUp?: number;
    angleDown?: number;
    nearPlane?: number;
    farPlane?: number;
    aspectRatio?: number;
};
export type GetEntity_tags = {
    tags: GetEntity_Tags;
};
export type GetEntity_Tags = {
    value: Array<string>;
};
export type GetEntity_volume_filter = {
    volume_filter: GetEntity_VolumeFilter;
};
export type GetEntity_VolumeFilter = {
    range?: Array<number>;
    applyGaussianFiltering?: boolean;
    sampleUnfiltered?: boolean;
    enableMPR?: boolean;
    enable3D?: boolean;
};
export type GetEntity_volume_material_ref = {
    volume_material_ref: GetEntity_VolumeMaterialReference;
};
export type GetEntity_VolumeMaterialReference = {
    value: string;
};
export type GetEntity_volume_ref = {
    volume_ref: GetEntity_VolumeReference;
};
export type GetEntity_VolumeReference = {
    texture3dRef: string;
};
export type GetEntity_Entity = {
    euid: GetEntity_EntityUid;
};
export type GetEntity_EntityUid = {
    value: string;
};
/**
 * Get a specific entity from a scene.
 */
export declare function getEntity({ scene_id, entity_id, compute_global_transform, }: {
    scene_id: string;
    entity_id: string;
    compute_global_transform?: boolean;
}, headers?: AxiosRequestHeaders): AxiosPromise<(GetEntity_animation_controller | GetEntity_bone | GetEntity_box_geometry | GetEntity_camera | GetEntity_capsule_geometry | GetEntity_character_controller | GetEntity_collision_geometry_ref | GetEntity_cylinder_geometry | GetEntity_debug_name | GetEntity_decal_projector | GetEntity_environment | GetEntity_joint | GetEntity_lineage | GetEntity_local_aabb | GetEntity_local_transform | GetEntity_material | GetEntity_material_ref | GetEntity_mesh_ref | GetEntity_orthographic_lens | GetEntity_overrider | GetEntity_perspective_lens | GetEntity_physics_material | GetEntity_plane_geometry | GetEntity_point_cloud_ref | GetEntity_point_light | GetEntity_reflection_probe | GetEntity_revolute_joint | GetEntity_rigid_body | GetEntity_scene_ref | GetEntity_script_element | GetEntity_script_map | GetEntity_shadow_caster | GetEntity_skeleton_ref | GetEntity_sound_ref | GetEntity_sphere_geometry | GetEntity_spot_light | GetEntity_stereoscopic_lens | GetEntity_tags | GetEntity_volume_filter | GetEntity_volume_material_ref | GetEntity_volume_ref) & GetEntity_Entity>;
export type UpdateEntity_animation_controller = {
    animation_controller: UpdateEntity_AnimationController;
};
export type UpdateEntity_AnimationController = {
    animationGraphRef: string;
    animationSetRef: string;
    dataJSON: object;
    rootBoneEntityRef: UpdateEntity_EntityReference;
    rootMotionEnabled: boolean;
};
export type UpdateEntity_EntityReference = {
    originalEUID: string;
    linkage: Array<string>;
};
export type UpdateEntity_bone = {
    bone: UpdateEntity_Bone;
};
export type UpdateEntity_Bone = {
    boneIndex: number;
};
export type UpdateEntity_box_geometry = {
    box_geometry: UpdateEntity_BoxGeometry;
};
export type UpdateEntity_BoxGeometry = {
    dimension?: Array<number>;
    isAdditive?: boolean;
    offset?: Array<number>;
};
export type UpdateEntity_camera = {
    camera: UpdateEntity_Camera;
};
export type UpdateEntity_Camera = {
    renderGraphRef: string;
    renderTargetIndex?: number;
    dataJSON: object;
};
export type UpdateEntity_capsule_geometry = {
    capsule_geometry: UpdateEntity_CapsuleGeometry;
};
export type UpdateEntity_CapsuleGeometry = {
    radius?: number;
    height?: number;
    axis?: number;
    isAdditive?: boolean;
    offset?: Array<number>;
};
export type UpdateEntity_character_controller = {
    character_controller: UpdateEntity_CharacterController;
};
export type UpdateEntity_CharacterController = {
    stepOffset?: number;
    slopeLimit?: number;
    skinWidth?: number;
    velocity?: Array<number>;
};
export type UpdateEntity_collision_geometry_ref = {
    collision_geometry_ref: UpdateEntity_CollisionGeometryRef;
};
export type UpdateEntity_CollisionGeometryRef = {
    collisionGeometryRef: string;
};
export type UpdateEntity_cylinder_geometry = {
    cylinder_geometry: UpdateEntity_CylinderGeometry;
};
export type UpdateEntity_CylinderGeometry = {
    radius?: number;
    height?: number;
    axis?: number;
    isAdditive?: boolean;
    offset?: Array<number>;
};
export type UpdateEntity_debug_name = {
    debug_name: UpdateEntity_Name;
};
export type UpdateEntity_Name = {
    value: string;
};
export type UpdateEntity_decal_projector = {
    decal_projector: UpdateEntity_DecalProjector;
};
export type UpdateEntity_DecalProjector = {
    zIndex?: number;
};
export type UpdateEntity_environment = {
    environment: UpdateEntity_Environment;
};
export type UpdateEntity_Environment = {
    skyboxUUID: string;
    radianceUUID: string;
    irradianceUUID: string;
};
export type UpdateEntity_joint = {
    joint: UpdateEntity_Joint;
};
export type UpdateEntity_Joint = {
    constrainee: UpdateEntity_EntityReference;
    constrainer: UpdateEntity_EntityReference;
    breakForce?: number;
    breakTorque?: number;
};
export type UpdateEntity_lineage = {
    lineage: UpdateEntity_Lineage;
};
export type UpdateEntity_Lineage = {
    parentUUID: string;
    ordinal?: number;
};
export type UpdateEntity_local_aabb = {
    local_aabb: UpdateEntity_LocalAxisAlignedBoundingBox;
};
export type UpdateEntity_LocalAxisAlignedBoundingBox = {
    min: Array<number>;
    max: Array<number>;
};
export type UpdateEntity_local_transform = {
    local_transform: UpdateEntity_Transform;
};
export type UpdateEntity_Transform = {
    position?: Array<number>;
    orientation?: Array<number>;
    scale?: Array<number>;
    eulerOrientation?: Array<number>;
    globalEulerOrientation?: Array<number>;
};
export type UpdateEntity_material = {
    material: UpdateEntity_Material;
};
export type UpdateEntity_Material = {
    shaderRef: string;
    transparencyMode: number;
    isDoubleSided: boolean;
    dataJSON: object;
};
export type UpdateEntity_material_ref = {
    material_ref: UpdateEntity_MaterialReference;
};
export type UpdateEntity_MaterialReference = {
    value: string;
    faceCulling?: number;
};
export type UpdateEntity_mesh_ref = {
    mesh_ref: UpdateEntity_MeshReference;
};
export type UpdateEntity_MeshReference = {
    value: string;
    submeshIndex?: number;
};
export type UpdateEntity_orthographic_lens = {
    orthographic_lens: UpdateEntity_OrthographicLens;
};
export type UpdateEntity_OrthographicLens = {
    left?: number;
    right?: number;
    top?: number;
    bottom?: number;
    zNear?: number;
    zFar?: number;
};
export type UpdateEntity_overrider = {
    overrider: UpdateEntity_Overrider;
};
export type UpdateEntity_Overrider = {
    deleter?: boolean;
    entityRef: UpdateEntity_EntityReference;
    componentsToDetach: Array<number>;
};
export type UpdateEntity_perspective_lens = {
    perspective_lens: UpdateEntity_PerspectiveLens;
};
export type UpdateEntity_PerspectiveLens = {
    aspectRatio?: number;
    fovy?: number;
    nearPlane?: number;
    farPlane?: number;
};
export type UpdateEntity_physics_material = {
    physics_material: UpdateEntity_PhysicsMaterial;
};
export type UpdateEntity_PhysicsMaterial = {
    staticFriction?: number;
    dynamicFriction?: number;
    restitution?: number;
    isTrigger?: boolean;
};
export type UpdateEntity_plane_geometry = {
    plane_geometry: UpdateEntity_PlaneGeometry;
};
export type UpdateEntity_PlaneGeometry = {
    distance?: number;
    normal?: Array<number>;
};
export type UpdateEntity_point_cloud_ref = {
    point_cloud_ref: UpdateEntity_PointCloudReference;
};
export type UpdateEntity_PointCloudReference = {
    value: string;
};
export type UpdateEntity_point_light = {
    point_light: UpdateEntity_Light;
};
export type UpdateEntity_Light = {
    color?: Array<number>;
    intensity?: number;
    range?: number;
    isDirectional?: boolean;
    isSun?: boolean;
};
export type UpdateEntity_reflection_probe = {
    reflection_probe: UpdateEntity_ReflectionProbe;
};
export type UpdateEntity_ReflectionProbe = {
    offset?: Array<number>;
    nearDist?: number;
    farDist?: number;
    quality?: number;
};
export type UpdateEntity_revolute_joint = {
    revolute_joint: UpdateEntity_RevoluteJoint;
};
export type UpdateEntity_RevoluteJoint = {
    axis?: Array<number>;
    anchor?: Array<number>;
};
export type UpdateEntity_rigid_body = {
    rigid_body: UpdateEntity_RigidBody;
};
export type UpdateEntity_RigidBody = {
    mass?: number;
    linearDamping?: number;
    angularDamping?: number;
    friction?: number;
    rollingFriction?: number;
    spinningFriction?: number;
    restitution?: number;
    linearSleepingThreshold?: number;
    angularSleepingThreshold?: number;
    isKinematic?: boolean;
};
export type UpdateEntity_scene_ref = {
    scene_ref: UpdateEntity_SceneReference;
};
export type UpdateEntity_SceneReference = {
    value: string;
    maxRecursionCount?: number;
};
export type UpdateEntity_script_element = {
    script_element: UpdateEntity_ScriptElement;
};
export type UpdateEntity_ScriptElement = {
    scriptRef: string;
    dataJSON: object;
};
export type UpdateEntity_script_map = {
    script_map: UpdateEntity_ScriptMap;
};
export type UpdateEntity_ScriptMap = {
    elements: object;
};
export type UpdateEntity_shadow_caster = {
    shadow_caster: UpdateEntity_ShadowCaster;
};
export type UpdateEntity_ShadowCaster = {
    bias?: number;
    nearDist?: number;
    farDist?: number;
    quality?: number;
    cascadeSplitLambda?: number;
    cascadeMaxZ?: number;
    accumulateShadowCascades?: boolean;
};
export type UpdateEntity_skeleton_ref = {
    skeleton_ref: UpdateEntity_SkeletonReference;
};
export type UpdateEntity_SkeletonReference = {
    value: string;
};
export type UpdateEntity_sound_ref = {
    sound_ref: UpdateEntity_SoundReference;
};
export type UpdateEntity_SoundReference = {
    value: string;
    volume?: number;
    pan?: number;
    playSpeed?: number;
    looping?: boolean;
};
export type UpdateEntity_sphere_geometry = {
    sphere_geometry: UpdateEntity_SphereGeometry;
};
export type UpdateEntity_SphereGeometry = {
    radius?: number;
    isAdditive?: boolean;
    offset?: Array<number>;
};
export type UpdateEntity_spot_light = {
    spot_light: UpdateEntity_SpotLight;
};
export type UpdateEntity_SpotLight = {
    cutoff?: number;
    IESProfile: string;
};
export type UpdateEntity_stereoscopic_lens = {
    stereoscopic_lens: UpdateEntity_StereoscopicPerspectiveLens;
};
export type UpdateEntity_StereoscopicPerspectiveLens = {
    angleLeft?: number;
    angleRight?: number;
    angleUp?: number;
    angleDown?: number;
    nearPlane?: number;
    farPlane?: number;
    aspectRatio?: number;
};
export type UpdateEntity_tags = {
    tags: UpdateEntity_Tags;
};
export type UpdateEntity_Tags = {
    value: Array<string>;
};
export type UpdateEntity_volume_filter = {
    volume_filter: UpdateEntity_VolumeFilter;
};
export type UpdateEntity_VolumeFilter = {
    range?: Array<number>;
    applyGaussianFiltering?: boolean;
    sampleUnfiltered?: boolean;
    enableMPR?: boolean;
    enable3D?: boolean;
};
export type UpdateEntity_volume_material_ref = {
    volume_material_ref: UpdateEntity_VolumeMaterialReference;
};
export type UpdateEntity_VolumeMaterialReference = {
    value: string;
};
export type UpdateEntity_volume_ref = {
    volume_ref: UpdateEntity_VolumeReference;
};
export type UpdateEntity_VolumeReference = {
    texture3dRef: string;
};
/**
 * Update a specific entity from a scene.
 */
export declare function updateEntity({ scene_id, entity_id, entity_components, }: {
    scene_id: string;
    entity_id: string;
    entity_components: UpdateEntity_animation_controller | UpdateEntity_bone | UpdateEntity_box_geometry | UpdateEntity_camera | UpdateEntity_capsule_geometry | UpdateEntity_character_controller | UpdateEntity_collision_geometry_ref | UpdateEntity_cylinder_geometry | UpdateEntity_debug_name | UpdateEntity_decal_projector | UpdateEntity_environment | UpdateEntity_joint | UpdateEntity_lineage | UpdateEntity_local_aabb | UpdateEntity_local_transform | UpdateEntity_material | UpdateEntity_material_ref | UpdateEntity_mesh_ref | UpdateEntity_orthographic_lens | UpdateEntity_overrider | UpdateEntity_perspective_lens | UpdateEntity_physics_material | UpdateEntity_plane_geometry | UpdateEntity_point_cloud_ref | UpdateEntity_point_light | UpdateEntity_reflection_probe | UpdateEntity_revolute_joint | UpdateEntity_rigid_body | UpdateEntity_scene_ref | UpdateEntity_script_element | UpdateEntity_script_map | UpdateEntity_shadow_caster | UpdateEntity_skeleton_ref | UpdateEntity_sound_ref | UpdateEntity_sphere_geometry | UpdateEntity_spot_light | UpdateEntity_stereoscopic_lens | UpdateEntity_tags | UpdateEntity_volume_filter | UpdateEntity_volume_material_ref | UpdateEntity_volume_ref;
}, headers?: AxiosRequestHeaders): Promise<import("axios").AxiosResponse<any, any>>;
/**
 * Delete a specific entity from a scene.
 */
export declare function deleteEntity({ scene_id, entity_id, }: {
    scene_id: string;
    entity_id: string;
}, headers?: AxiosRequestHeaders): Promise<import("axios").AxiosResponse<any, any>>;
/**
 * Get the settings of a scene.
 */
export declare function getSceneSettings({ scene_id, }: {
    scene_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<object>;
export type GetRunningSessions_Filter = {
    user_id?: string;
    scene_id?: string;
    folder_id?: string;
};
export type GetRunningSessions_Session = {
    session_id: string;
    scene_id: string;
    scene_name: string;
    folder_id: string;
    max_users: number;
    creator_user_id: string;
    created_at: string;
    country_code: string;
    continent_code: string;
    is_transient_session: boolean;
    clients: Array<GetRunningSessions_Client_UserInfo>;
};
export type GetRunningSessions_Client_UserInfo = {
    client_id?: string;
    client_type?: StrictUnion<'user' | 'guest'>;
    user_id: string;
    username: string;
};
/**
 * Lists all running rendering sessions.
 */
export declare function getRunningSessions({ filters, }: {
    filters?: GetRunningSessions_Filter;
}, headers?: AxiosRequestHeaders): AxiosPromise<Array<GetRunningSessions_Session>>;
export type CreateSession_Object = {
    session_id: string;
};
/**
 * Create a new rendering session.
 */
export declare function createSession({ scene_id, renderer_version, is_transient, options, }: {
    scene_id: string;
    renderer_version?: string;
    is_transient?: boolean;
    options?: object;
}, headers?: AxiosRequestHeaders): AxiosPromise<CreateSession_Object>;
export type GetSession_Session = {
    session_id: string;
    scene_id: string;
    scene_name: string;
    folder_id: string;
    max_users: number;
    creator_user_id: string;
    created_at: string;
    country_code: string;
    continent_code: string;
    is_transient_session: boolean;
    clients: Array<GetSession_Client_UserInfo>;
};
export type GetSession_Client_UserInfo = {
    client_id?: string;
    client_type?: StrictUnion<'user' | 'guest'>;
    user_id: string;
    username: string;
};
/**
 * Retrieves details about the target session.
 */
export declare function getSession({ session_id, }: {
    session_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<GetSession_Session>;
/**
 * Forcefully terminates a session.
 */
export declare function killSession({ session_id, }: {
    session_id: string;
}, headers?: AxiosRequestHeaders): Promise<import("axios").AxiosResponse<any, any>>;
export type JoinSession_SessionToken = {
    session_token: string;
    endpoint_info: JoinSession_Object;
};
export type JoinSession_Object = {
    ip: string;
    port: number;
    ssl_port: number;
};
/**
 * Creates a new client for the user and returns a token to join the session.
 */
export declare function joinSession({ session_id, }: {
    session_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<JoinSession_SessionToken>;
export type GetClient_Client_UserInfo = {
    client_id?: string;
    client_type?: StrictUnion<'user' | 'guest'>;
    user_id: string;
    username: string;
};
/**
 * Retrieves details about the target client.
 */
export declare function getClient({ session_id, client_id, }: {
    session_id: string;
    client_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<GetClient_Client_UserInfo>;
/**
 * Kick a client from a running session.
 */
export declare function kickClientFromSession({ session_id, client_id, }: {
    session_id: string;
    client_id: string;
}, headers?: AxiosRequestHeaders): Promise<import("axios").AxiosResponse<any, any>>;
export type JoinSessionAsGuest_SessionToken = {
    session_token: string;
    endpoint_info: JoinSessionAsGuest_Object;
};
export type JoinSessionAsGuest_Object = {
    ip: string;
    port: number;
    ssl_port: number;
};
/**
 * Join a session as guest.
 */
export declare function joinSessionAsGuest(headers?: AxiosRequestHeaders): AxiosPromise<JoinSessionAsGuest_SessionToken>;
export type GenerateGuestToken_GuestToken = {
    guest_token?: string;
};
/**
 * Generates a token to join the session as a guest.
 */
export declare function generateGuestToken({ session_id, }: {
    session_id: string;
}, headers?: AxiosRequestHeaders): AxiosPromise<GenerateGuestToken_GuestToken>;
export {};
