/**
 * DO NOT EDIT THIS FILE MANUALLY.
 * This file has been generated automatically from ftl-schemas
 */
import type { EntityRef, AssetRef, AnimationGraphDataObject, RenderGraphDataObject, ShaderDataObject, ScriptDataObject, RTID, UUID, Mat4, Quat, Vec3, Vec2, Float, Int32, UInt32, Int8, UInt8 } from "../../sources/types";
import type * as Assets from "./assets";
/**
 * Unique identifier for an entity.
 */
export type Euid = {
    /**
     * Unique identifier value.
     */
    value: UUID;
    /**
     * Runtime id of this entity, needed to differentiate between cloned entities.
     */
    rtid: RTID;
};
/**
 * Animation controller with reference to an animation graph and an animation set. Enables skeletal animation on its skinned mesh descendents whose skeleton is compatible with the animations in the animation set.
 */
export type AnimationController = {
    /**
     * UUID of the referenced animation graph.
     */
    animationGraphRef: AssetRef<Assets.AnimationGraph>;
    /**
     * UUID of the referenced animation set.
     */
    animationSetRef: AssetRef<Assets.AnimationSet>;
    /**
     * Input values as described in the referenced animation graph in their original JSON format.
     */
    dataJSON: AnimationGraphDataObject;
    /**
     * Reference to the entity with the bone component that corresponds the root bone of the skeleton.
     */
    rootBoneEntityRef: EntityRef;
    /**
     * Whether or not root motion is enabled.
     * @defaultValue false
     */
    rootMotionEnabled: boolean;
};
/**
 * Animation sequence controller with reference to an animation sequence and assigned entities.
 */
export type AnimationSequenceController = {
    /**
     * A reference to an animation sequence.
     */
    animationSequenceRef: AssetRef<Assets.AnimationSequence>;
    /**
     * Track to entity map. Key is track uuid, value is the entity to assign to it.
     */
    entities: Record<UUID, EntityRef>;
    /**
     * The speed at which to play the animation sequence. The sequence will go in reverse if set to a value lower than 0.
     * @defaultValue 1
     */
    playbackSpeed: Float;
    /**
     * The normalized offset at which to start the playback.
     * @defaultValue 0
     */
    startOffset: Float;
    /**
     * The normalized offset at which to stop the playback (or loop back to start offset).
     * @defaultValue 1
     */
    stopOffset: Float;
    /**
     * Whether or not the animation loops when it reaches the end of the sequence.
     * @defaultValue false
     */
    loop: boolean;
    /**
     * The play state of the animation.
     * @defaultValue 0
     */
    playState: Int32;
    /**
     * The offset to seek at next frame. Must be in the [0, 1] range.
     * @defaultValue -1
     */
    seekOffset: Float;
};
/**
 * Links entity to bone in skeleton.
 */
export type Bone = {
    /**
     * Index of bone in skeleton.
     */
    boneIndex: UInt32;
};
/**
 * Box geometry.
 */
export type BoxGeometry = {
    /**
     * Width, height and depth of the box.
     * @defaultValue 1,1,1
     */
    dimension: Vec3;
    /**
     * Geometry offset.
     * @defaultValue 0,0,0
     */
    offset: Vec3;
};
/**
 * Virtual camera.
 */
export type Camera = {
    /**
     * UUID of the referenced render graph this camera should use.
     */
    renderGraphRef: AssetRef<Assets.RenderGraph>;
    /**
     * Index of the render target to blit.
     * @defaultValue -1
     */
    renderTargetIndex: Int32;
    /**
     * Input values as described in the referenced render graph in their original JSON format.
     */
    dataJSON: RenderGraphDataObject;
};
/**
 * Capsule geometry.
 */
export type CapsuleGeometry = {
    /**
     * Radius of the spheres at each end of the capsule.
     * @defaultValue 0.5
     */
    radius: Float;
    /**
     * Height of the cylindrical part of the capsule.
     * @defaultValue 1
     */
    height: Float;
    /**
     * Alignment axis. 0 for X, 1 for Y, 2 for Z.
     * @defaultValue 1
     */
    axis: Int32;
    /**
     * Geometry offset.
     * @defaultValue 0,0,0
     */
    offset: Vec3;
};
/**
 * Character controller used for movement constrained by collisions without having to deal with a rigid body. A character controller is kinematic, and so is not affected by forces. It uses its own tweaked collision algorithm to give a good feeling while controlling the character.
 */
export type CharacterController = {
    /**
     * Step offset. If the height of a step is greater than stepOffset, the controller cannot climb automatically and gets stuck.
     * @defaultValue 0
     */
    stepOffset: Float;
    /**
     * Slope limit in degrees. A slope steeper than the slopeLimit will not be walkable by the controller.
     * @defaultValue 45
     */
    slopeLimit: Float;
    /**
     * The character's collision skin width.
     * @defaultValue 0
     */
    skinWidth: Float;
    /**
     * Displacement vector for current frame.
     * @defaultValue 0,0,0
     */
    displacement: Vec3;
};
/**
 * Reference to a collision geometry.
 */
export type CollisionGeometryRef = {
    /**
     * UUID of the referenced collision geometry.
     */
    collisionGeometryRef: AssetRef<Assets.CollisionGeometry>;
};
/**
 * A physics constraint that can be configured along 6 degrees of freedom. In its default state it behaves as a fixed constraint - that is, it rigidly fixes the constraint frames of its two entities. However, individual degrees of freedom may be unlocked to permit any combination of rotation around the x-, y- and z- axes, and translation along these axes.
 */
export type Constraint = {
    /**
     * Motion along the X axis
     * @defaultValue 0
     */
    motionAlongX: Int32;
    /**
     * Motion along the Y axis
     * @defaultValue 0
     */
    motionAlongY: Int32;
    /**
     * Motion along the Z axis
     * @defaultValue 0
     */
    motionAlongZ: Int32;
    /**
     * Motion around the X axis
     * @defaultValue 0
     */
    motionAroundX: Int32;
    /**
     * Motion around the Y axis
     * @defaultValue 0
     */
    motionAroundY: Int32;
    /**
     * Motion around the Z axis
     * @defaultValue 0
     */
    motionAroundZ: Int32;
    /**
     * The lower distance of the limit.
     * @defaultValue 0,0,0
     */
    motionLowerLimit: Vec3;
    /**
     * The upper distance of the limit.
     * @defaultValue 0,0,0
     */
    motionUpperLimit: Vec3;
    /**
     * If greater than zero, the limit is soft, i.e. a spring pulls the joint back to the limit.
     * @defaultValue 0,0,0
     */
    motionLimitSpringStiffness: Vec3;
    /**
     * If greater than zero, this is the damping of the limit spring.
     * @defaultValue 0,0,0
     */
    motionLimitSpringDamping: Vec3;
    /**
     * The limit angle from the Y-axis and the Z-axis of the constraint frame. The cone limit is used if either or both swing axes are limited. The extents are symmetrical and measured in the frame of the parent. If only one swing degree of freedom is limited, the corresponding value from the cone limit defines the limit range.
     * @defaultValue 0,0
     */
    swingLimitAngle: Vec2;
    /**
     * If greater than zero, the limit is soft, i.e. a spring pulls the joint back to the limit.
     * @defaultValue 0
     */
    swingSpringStiffness: Float;
    /**
     * If greater than zero, this is the damping of the limit spring.
     * @defaultValue 0
     */
    swingSpringDamping: Float;
    /**
     * The twist limit controls the range of motion around the twist axis. The limit angle range is (-360, 360).
     * @defaultValue 0,0
     */
    twistLimitAngle: Vec2;
    /**
     * If greater than zero, the limit is soft, i.e. a spring pulls the joint back to the limit.
     * @defaultValue 0
     */
    twistSpringStiffness: Float;
    /**
     * If greater than zero, this is the damping of the limit spring.
     * @defaultValue 0
     */
    twistSpringDamping: Float;
    /**
     * If greater than zero, the limit is soft, i.e. a spring pulls the joint back to the limit.
     * @defaultValue 0,0,0
     */
    linearDriveStiffness: Vec3;
    /**
     * If greater than zero, this is the damping of the limit spring.
     * @defaultValue 0,0,0
     */
    linearDriveDamping: Vec3;
    /**
     * The maximum impulse or force that can be exerted by the drive. -1 for no limit.
     * @defaultValue -1,-1,-1
     */
    linearDriveForceLimit: Vec3;
    /**
     * If greater than zero, the limit is soft, i.e. a spring pulls the joint back to the limit.
     * @defaultValue 0,0,0
     */
    angularDriveStiffness: Vec3;
    /**
     * If greater than zero, this is the damping of the limit spring.
     * @defaultValue 0,0,0
     */
    angularDriveDamping: Vec3;
    /**
     * The maximum impulse or force that can be exerted by the drive. -1 for no limit.
     * @defaultValue -1,-1,-1
     */
    angularDriveForceLimit: Vec3;
    /**
     * The drive type
     * @defaultValue 1
     */
    driveType: Int8;
    /**
     * The goal velocity for linear drive.
     * @defaultValue 0,0,0
     */
    driveLinearVelocity: Vec3;
    /**
     * The goal velocity for angular drive.
     * @defaultValue 0,0,0
     */
    driveAngularVelocity: Vec3;
};
/**
 * Culling geometry. Add this component in addition to another geometry component (e.g. box geometry, sphere geometry, etc.) to enable culling geometry.
 */
export type CullingGeometry = {
    /**
     * Additive geometry will only display elements (vertices or voxels) inside the geometry. Subtractive will only display elements outside the geometry.
     * @defaultValue true
     */
    isAdditive: boolean;
};
/**
 * Cylinder geometry.
 */
export type CylinderGeometry = {
    /**
     * Radius of the cylinder.
     * @defaultValue 0.5
     */
    radius: Float;
    /**
     * Height of the cylinder.
     * @defaultValue 1
     */
    height: Float;
    /**
     * Alignment axis. 0 for X, 1 for Y, 2 for Z.
     * @defaultValue 1
     */
    axis: Int32;
    /**
     * Geometry offset.
     * @defaultValue 0,0,0
     */
    offset: Vec3;
};
/**
 * Name of the entity.
 */
export type DebugName = {
    /**
     * Entity name.
     */
    value: string;
};
/**
 * Decal Projector.
 */
export type DecalProjector = {
    /**
     * Z-Index order of the decal projection. The higher index will render on top of the lower ones.
     * @defaultValue 0
     */
    zIndex: Int32;
};
/**
 * The environment of a scene. Used to give a scene a skybox.
 */
export type Environment = {
    /**
     * UUID of the skybox cubemap.
     */
    skyboxUUID: AssetRef<Assets.Cubemap>;
    /**
     * Reference to the radiance cubemap.
     */
    radianceUUID: AssetRef<Assets.Cubemap>;
    /**
     * Reference to the irradiance cubemap.
     */
    irradianceUUID: AssetRef<Assets.Cubemap>;
};
/**
 * Base component of all the other joint components (revolute_joint, etc.). By itself it will lock the orientations and distances of the constrainer and constrainee.
 */
export type Joint = {
    /**
     * An entity that is a rigid body.
     */
    constrainee: EntityRef;
    /**
     * An entity that is a rigid or static body, or simply null.
     */
    constrainer: EntityRef;
    /**
     * The force that needs to be applied for this joint to break.
     * @defaultValue 10
     */
    breakForce: Float;
    /**
     * The torque that needs to be applied for this joint to break.
     * @defaultValue 10
     */
    breakTorque: Float;
    /**
     * Whether to enable collision between constrainer and constrainee.
     * @defaultValue false
     */
    enableCollision: boolean;
};
/**
 * Display a label in the 3d view.
 */
export type Label = {
    /**
     * Title of the label.
     */
    title: string;
    /**
     * Description of the label.
     */
    description: string;
    /**
     * Camera distance from the label.
     * @defaultValue 0,0,0,0,0,0,1
     */
    camera: Array<Float>;
    /**
     * Travel speed in units per second.
     * @defaultValue 15
     */
    speed: Float;
};
/**
 * Lineage of the entity through linkers.
 */
export type Lineage = {
    /**
     * UUIDs of the hierarchy of linkers that brought this entity.
     */
    readonly value: Array<UUID>;
    /**
     * UUID of the parent of this entity (default is root).
     */
    parentUUID: UUID;
    /**
     * Ordinal number of this entity in respect of its siblings.
     * @defaultValue 0
     */
    ordinal: Int32;
};
/**
 * Local Axis Aligned Bounding Box of the entity.
 */
export type LocalAabb = {
    /**
     * Minimum point of the box.
     */
    min: Vec3;
    /**
     * Maximum point of the box.
     */
    max: Vec3;
};
/**
 * Local transform of the entity.
 */
export type LocalTransform = {
    /**
     * x, y, z position of the entity.
     * @defaultValue 0,0,0
     */
    position: Vec3;
    /**
     * Orientation of the entity expressed as a quaternion.
     * @defaultValue 0,0,0,1
     */
    orientation: Quat;
    /**
     * x, y, z scale of the entity.
     * @defaultValue 1,1,1
     */
    scale: Vec3;
    /**
     * Orientation of the entity expressed as euler angles.
     * @defaultValue 0,0,0
     */
    eulerOrientation: Vec3;
    /**
     * Last global orientation of the entity expressed as euler angles submitted by a user. This value may not be valid, and should be checked.
     * @defaultValue 0,0,0
     */
    globalEulerOrientation: Vec3;
};
/**
 * References a shader and specifies input values if needed.
 */
export type Material = {
    /**
     * UUID of the referenced shader.
     */
    shaderRef: AssetRef<Assets.Shader>;
    /**
     * Whether the material is double sided or not.
     * @defaultValue false
     */
    isDoubleSided: boolean;
    /**
     * Input values as described in the referenced shader in their original JSON format.
     */
    dataJSON: ShaderDataObject;
    /**
     * Specialization constants values as described in the referenced shader in their original JSON format.
     */
    constantsJSON: ShaderDataObject;
};
/**
 * Reference to a material.
 */
export type MaterialRef = {
    /**
     * UUID of the referenced material.
     */
    value: AssetRef<Assets.Material>;
    /**
     * Face culling mode. 0 to inherit from material, 1 for single sided, 2 for double sided.
     * @defaultValue 0
     */
    faceCulling: Int32;
};
/**
 * Display a measure in the 3d view.
 */
export type Measure = {
    /**
     * Define the type of the measure.
     * @defaultValue 0
     */
    type: UInt32;
    /**
     * Color of the measure
     * @defaultValue 1,1,1
     */
    color: Vec3;
};
/**
 * Reference to a mesh.
 */
export type MeshRef = {
    /**
     * UUID of the referenced mesh.
     */
    value: AssetRef<Assets.Mesh>;
    /**
     * Index of the submesh inside the mesh's submesh array.
     * @defaultValue 0
     */
    submeshIndex: Int32;
    /**
     * Whether or not this mesh casts shadows.
     * @defaultValue 1
     */
    shadowCastingMode: UInt8;
};
/**
 * A lens that applies an orthographic projection.
 */
export type OrthographicLens = {
    /**
     * Zoom factor to apply to the projection.
     * @defaultValue 1,1
     */
    zoomFactor: Vec2;
    /**
     * Near plane.
     * @defaultValue 0
     */
    zNear: Float;
    /**
     * Far plane.
     * @defaultValue 100
     */
    zFar: Float;
};
/**
 * Overrides a given entity in a sub scene.
 */
export type Overrider = {
    /**
     * Mark the overridden entity as deleted.
     * @defaultValue false
     */
    deleter: boolean;
    /**
     * Entity to override.
     */
    entityRef: EntityRef;
    /**
     * Hashes of the components to detach from the overridden entity.
     */
    componentsToDetach: Array<Int32>;
};
/**
 * A lens that applies a perspective projection.
 */
export type PerspectiveLens = {
    /**
     * Field of view angle in the y direction.
     * @defaultValue 60
     */
    fovy: Float;
    /**
     * Distance from the viewer to the near clipping plane.
     * @defaultValue 0.01
     */
    nearPlane: Float;
    /**
     * Distance from the viewer to the far clipping plane.
     * @defaultValue 0
     */
    farPlane: Float;
    /**
     * Offset of the projection for stereoscopic rendering.
     * @defaultValue 0,0
     */
    offset: Vec2;
};
/**
 * Physics material which represents a set of physical surface properties.
 */
export type PhysicsMaterial = {
    /**
     * The friction coefficient applied between this surface and another surface if they are not moving lateral to each other. Usually a value from 0 to 1. A value of zero feels like ice, a value of 1 will make it very hard to get the object moving. Resulting static friction of a physics body colliding with another is determined by the average of both bodies' static friction coefficient.
     * @defaultValue 0.5
     */
    staticFriction: Float;
    /**
     * The friction coefficient applied between this surface and another surface if they are moving relative to each other. Usually a value from 0 to 1. A value of zero feels like ice, a value of 1 will make it very hard to get the object moving. If set to greater than staticFriction, the effective value of staticFriction will be increased to match. Resulting dynamic friction of a physics body colliding with another is determined by the average of both bodies' dynamic friction coefficient.
     * @defaultValue 0.5
     */
    dynamicFriction: Float;
    /**
     * Restitution coefficient, or bounciness of surface. A coefficient of 0 indicates as little bounce as possible, higher values up to 1.0 result in more bounce. Should be in the range [0,1]. Resulting bounciness of a physics body colliding with another is determined by the average of both bodies' restitution.
     * @defaultValue 0
     */
    restitution: Float;
    /**
     * The velocity applied to the contact between this physics body and another body. Only applies if modifyContact is true.
     * @defaultValue 0,0,0
     */
    contactVelocity: Vec3;
    /**
     * Whether to modify the contact when this physics body collides with another body.
     * @defaultValue false
     */
    modifyContact: boolean;
    /**
     * Whether to consider the geometry associated to this physics material as a trigger or not.
     * @defaultValue false
     */
    isTrigger: boolean;
};
/**
 * Plane geometry.
 */
export type PlaneGeometry = {
    /**
     * Distance from the origin in the plane's normal direction.
     * @defaultValue 0
     */
    distance: Float;
    /**
     * Normal of the plane.
     * @defaultValue 0,1,0
     */
    normal: Vec3;
};
/**
 * Reference to a point cloud.
 */
export type PointCloudRef = {
    /**
     * UUID of the referenced point cloud.
     */
    value: AssetRef<Assets.PointCloud>;
};
/**
 * A light with color and intensity. A point light by default, add a spot light component to add a cutoff. Can be parameterized to simulate the atmosphere sun.
 */
export type PointLight = {
    /**
     * Light color.
     * @defaultValue 1,1,1
     */
    color: Vec3;
    /**
     * Light intensity.
     * @defaultValue 1
     */
    intensity: Float;
    /**
     * The range for the point light. If the range is 0, then physically correct point light attenuation function is used.
     * @defaultValue 0
     */
    range: Float;
    /**
     * Make this light directional, position is ignored in this case.
     * @defaultValue false
     */
    isDirectional: boolean;
    /**
     * Make this light direction control the atmosphere sun direction. If more than one light is marked to be a sun results are undefined.
     * @defaultValue false
     */
    isSun: boolean;
};
/**
 * Omni directional reflection probe parameters, used for local cubemap reflection generation.
 */
export type ReflectionProbe = {
    /**
     * x, y, z offset of the probe reflection origin.
     * @defaultValue 0,0,0
     */
    offset: Vec3;
    /**
     * Distance to the near plane.
     * @defaultValue 0.1
     */
    nearDist: Float;
    /**
     * Distance to the far plane.
     * @defaultValue 100
     */
    farDist: Float;
    /**
     * Resolution of the reflection map.
     * @defaultValue 128
     */
    quality: Int32;
};
/**
 * Rigid body parameters.
 */
export type RigidBody = {
    /**
     * Mass of the rigid body. A value of 0 is interpreted as infinite mass.
     * @defaultValue 1
     */
    mass: Float;
    /**
     * Center of mass. Relative to the entity's transform.
     * @defaultValue 0,0,0
     */
    centerOfMass: Vec3;
    /**
     * Linear damping coefficient. Used to slow down the rigid body's linear velocity. Zero represents no damping. Must be non-negative.
     * @defaultValue 0
     */
    linearDamping: Float;
    /**
     * Angular damping coefficient. Used to slow down the rigid body's angular velocity, i.e. how much it rotates. Zero represents no damping. Must be non-negative.
     * @defaultValue 0.05
     */
    angularDamping: Float;
    /**
     *
     * @defaultValue 0,0,0
     */
    force: Vec3;
    /**
     *
     * @defaultValue 0,0,0
     */
    torque: Vec3;
    /**
     * The type of collision detection to use for this rigid body.
     * @defaultValue 0
     */
    collisionDetection: Int32;
    /**
     * Controls whether rigid body is affected by gravity.
     * @defaultValue true
     */
    useGravity: boolean;
    /**
     * Specifies if rigid body is kinematic. Kinematic rigid bodies are not affected by forces such as gravity.
     * @defaultValue false
     */
    isKinematic: boolean;
};
/**
 * Reference to a scene.
 */
export type SceneRef = {
    /**
     * UUID of the referenced scene.
     */
    value: AssetRef<Assets.Scene>;
    /**
     * Maximum number of times a scene appears when it references itself.
     * @defaultValue 1
     */
    maxRecursionCount: UInt32;
};
/**
 * References a script and specifies input values if needed.
 */
export type ScriptElement = {
    /**
     * UUID of the referenced script.
     */
    scriptRef: AssetRef<Assets.Script>;
    /**
     * Input values as described in the referenced script in their original JSON format.
     */
    dataJSON: ScriptDataObject;
};
/**
 * References multiple scripts.
 */
export type ScriptMap = {
    /**
     * List of scripts.
     */
    elements: Record<UUID, ScriptElement>;
};
/**
 * Enables a light to cast shadows.
 */
export type ShadowCaster = {
    /**
     * Bias to apply to avoid self shadowing artifacts.
     * @defaultValue 0.002
     */
    bias: Float;
    /**
     * Distance to the near plane.
     * @defaultValue 0.1
     */
    nearDist: Float;
    /**
     * Distance to the far plane.
     * @defaultValue 100
     */
    farDist: Float;
    /**
     * Resolution of the shadow map.
     * @defaultValue 1024
     */
    quality: Int32;
    /**
     * For directional lights, adjusts the distribution of cascade splits in Cascaded Shadow Mapping for directional lights. A value of 0 results in uniform (linear) splits across the view frustum, while a value of 1 skews the splits toward the camera, providing higher shadow resolution near the viewer and lower resolution in the distance. Intermediate values blend linear and logarithmic distributions for a balanced result. The value ranges from 0 to 1.
     * @defaultValue 0.94
     */
    cascadeSplitLambda: Float;
    /**
     * For directional lights, number of cascades.
     * @defaultValue 4
     */
    cascadeCount: Int8;
    /**
     * For directional lights, accumulate all shadow cascades.
     * @defaultValue true
     */
    accumulateShadowCascades: boolean;
};
/**
 * Reference to a skeleton.
 */
export type SkeletonRef = {
    /**
     * UUID of the referenced skeleton.
     */
    value: AssetRef<Assets.Skeleton>;
};
/**
 * Reference to a sound.
 */
export type SoundRef = {
    /**
     * UUID of the referenced sound.
     */
    value: AssetRef<Assets.Sound>;
    /**
     * Volume from 0.0f to 1.0f.
     * @defaultValue 1
     */
    volume: Float;
    /**
     * Pan. -1.0f is left, 1.0f is right.
     * @defaultValue 0
     */
    pan: Float;
    /**
     * The speed at which the sound will play. 1.0f is normal.
     * @defaultValue 1
     */
    playSpeed: Float;
    /**
     * Whether or not the sound loops.
     * @defaultValue false
     */
    looping: boolean;
    /**
     * The play state of the sound.
     * @defaultValue 0
     */
    playState: Int32;
};
/**
 * Sphere geometry.
 */
export type SphereGeometry = {
    /**
     * Radius of the sphere.
     * @defaultValue 0.5
     */
    radius: Float;
    /**
     * Geometry offset.
     * @defaultValue 0,0,0
     */
    offset: Vec3;
};
/**
 * Display a spline in the 3d view.
 */
export type Spline = {
    /**
     * Define the type of the curve.
     * @defaultValue 0
     */
    type: UInt32;
    /**
     * Color of the curve.
     * @defaultValue 1,1,1
     */
    color: Vec3;
    /**
     * When type is catmullrom, defines catmullrom's tension.
     * @defaultValue 0.5
     */
    tension: Float;
};
/**
 * Adds a cutoff to a point light to simulate a spot light.
 */
export type SpotLight = {
    /**
     * Cutoff angle.
     * @defaultValue 30
     */
    cutoff: Float;
    /**
     * Reference to a IES 2d texture.
     */
    IESProfile: AssetRef<Assets.Texture>;
};
/**
 * A lens that applies a custom projection.
 */
export type StereoscopicLens = {
    /**
     * Projection matrix.
     */
    cs_from_vs: Mat4;
};
/**
 * Tags used to filter entities.
 */
export type Tags = {
    /**
     * Tag list.
     */
    value: Array<string>;
};
/**
 * Vehicle Controller parameters.
 */
export type VehicleController = {
    /**
     * The chassis.
     */
    chassis: EntityRef;
    /**
     * The front left wheel.
     */
    frontLeftWheel: EntityRef;
    /**
     * The front right wheel.
     */
    frontRightWheel: EntityRef;
    /**
     * The rear left wheel.
     */
    rearLeftWheel: EntityRef;
    /**
     * The rear right wheel.
     */
    rearRightWheel: EntityRef;
};
/**
 * Filtering properties applied to the volume.
 */
export type VolumeFilter = {
    /**
     * Voxel intensity range displayed, not applicable if outside volume material range.
     * @defaultValue 0,1
     */
    range: Vec2;
    /**
     * Apply gaussian filtering on voxels.
     * @defaultValue false
     */
    applyGaussianFiltering: boolean;
    /**
     * Are texel values from the voxel texture sampled unfiltered.
     * @defaultValue false
     */
    sampleUnfiltered: boolean;
    /**
     * Whether or not this volume is visible in the MPR view.
     * @defaultValue true
     */
    enableMPR: boolean;
    /**
     * Whether or not this volume is visible in the 3D view.
     * @defaultValue true
     */
    enable3D: boolean;
};
/**
 * Reference to a material to use with a volume.
 */
export type VolumeMaterialRef = {
    /**
     * UUID of the referenced volume material.
     */
    value: AssetRef<Assets.VolumeMaterial>;
};
/**
 * Reference to a volume made of voxels.
 */
export type VolumeRef = {
    /**
     * UUID of the referenced 3D texture.
     */
    texture3dRef: AssetRef<Assets.Texture3D>;
};
