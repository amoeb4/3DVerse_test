import {
  P
} from "./chunk-NQ2JU7GK.js";
import {
  Ce,
  Ir,
  dt,
  es,
  ls
} from "./chunk-WVKORRBU.js";
import "./chunk-ZZFADQC5.js";
import {
  require_react
} from "./chunk-JMDNRDFR.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __toESM,
  init_buffer,
  init_process
} from "./chunk-O5XV4B72.js";

// node_modules/@3dverse/livelink-webxr/dist/index.mjs
init_process();
init_buffer();

// node_modules/threejs-math/build/threejs-math.module.js
init_process();
init_buffer();
var SRGBColorSpace = "srgb";
var LinearSRGBColorSpace = "srgb-linear";
var Vector2 = class _Vector2 {
  constructor(x = 0, y = 0) {
    _Vector2.prototype.isVector2 = true;
    this.x = x;
    this.y = y;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  cross(v) {
    return this.x * v.y - this.y * v.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  // fromBufferAttribute( attribute, index ) {
  // 	this.x = attribute.getX( index );
  // 	this.y = attribute.getY( index );
  // 	return this;
  // }
  rotateAround(center, angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    const x = this.x - center.x;
    const y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
};
var _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
var _seed = 1234567;
var DEG2RAD = Math.PI / 180;
var RAD2DEG = 180 / Math.PI;
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toLowerCase();
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function euclideanModulo(n, m) {
  return (n % m + m) % m;
}
function mapLinear(x, a1, a2, b1, b2) {
  return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
}
function inverseLerp(x, y, value) {
  if (x !== y) {
    return (value - x) / (y - x);
  } else {
    return 0;
  }
}
function lerp(x, y, t) {
  return (1 - t) * x + t * y;
}
function damp(x, y, lambda, dt2) {
  return lerp(x, y, 1 - Math.exp(-lambda * dt2));
}
function pingpong(x, length = 1) {
  return length - Math.abs(euclideanModulo(x, length * 2) - length);
}
function smoothstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * (3 - 2 * x);
}
function smootherstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * x * (x * (x * 6 - 15) + 10);
}
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}
function randFloat(low, high) {
  return low + Math.random() * (high - low);
}
function randFloatSpread(range) {
  return range * (0.5 - Math.random());
}
function seededRandom(s) {
  if (s !== void 0) _seed = s;
  let t = _seed += 1831565813;
  t = Math.imul(t ^ t >>> 15, t | 1);
  t ^= t + Math.imul(t ^ t >>> 7, t | 61);
  return ((t ^ t >>> 14) >>> 0) / 4294967296;
}
function degToRad(degrees) {
  return degrees * DEG2RAD;
}
function radToDeg(radians) {
  return radians * RAD2DEG;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q, a, b, c, order) {
  const cos = Math.cos;
  const sin = Math.sin;
  const c2 = cos(b / 2);
  const s2 = sin(b / 2);
  const c13 = cos((a + c) / 2);
  const s13 = sin((a + c) / 2);
  const c1_3 = cos((a - c) / 2);
  const s1_3 = sin((a - c) / 2);
  const c3_1 = cos((c - a) / 2);
  const s3_1 = sin((c - a) / 2);
  switch (order) {
    case "XYX":
      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
      break;
    case "YZY":
      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
      break;
    case "ZXZ":
      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
      break;
    case "XZX":
      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
      break;
    case "YXY":
      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
      break;
    case "ZYZ":
      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
  }
}
function denormalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint16Array:
      return value / 65535;
    case Uint8Array:
      return value / 255;
    case Int16Array:
      return Math.max(value / 32767, -1);
    case Int8Array:
      return Math.max(value / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint16Array:
      return Math.round(value * 65535);
    case Uint8Array:
      return Math.round(value * 255);
    case Int16Array:
      return Math.round(value * 32767);
    case Int8Array:
      return Math.round(value * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
var MathUtils$1 = Object.freeze({
  __proto__: null,
  DEG2RAD,
  RAD2DEG,
  generateUUID,
  clamp,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp,
  damp,
  pingpong,
  smoothstep,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad,
  radToDeg,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler,
  normalize,
  denormalize
});
var Quaternion = class {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.isQuaternion = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }
      const tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir;
      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update) {
    const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y / 2);
    const s3 = sin(z / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update !== false) this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m) {
    const te2 = m.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r = vFrom.dot(vTo) + 1;
    if (r < Number.EPSILON) {
      r = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }
    return this.normalize();
  }
  angleTo(q) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
  }
  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0) return this;
    const t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l = this.length();
    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q) {
    return this.multiplyQuaternions(this, q);
  }
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  multiplyQuaternions(a, b) {
    const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(qb);
    const x = this._x, y = this._y, z = this._z, w = this._w;
    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      this.normalize();
      this._onChangeCallback();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa2, qb, t) {
    return this.copy(qa2).slerp(qb, t);
  }
  random() {
    const u1 = Math.random();
    const sqrt1u1 = Math.sqrt(1 - u1);
    const sqrtu1 = Math.sqrt(u1);
    const u2 = 2 * Math.PI * Math.random();
    const u3 = 2 * Math.PI * Math.random();
    return this.set(
      sqrt1u1 * Math.cos(u2),
      sqrtu1 * Math.sin(u3),
      sqrtu1 * Math.cos(u3),
      sqrt1u1 * Math.sin(u2)
    );
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  // fromBufferAttribute( attribute, index ) {
  // 	this._x = attribute.getX( index );
  // 	this._y = attribute.getY( index );
  // 	this._z = attribute.getZ( index );
  // 	this._w = attribute.getW( index );
  // 	return this;
  // }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._w;
  }
};
var Vector3 = class _Vector3 {
  constructor(x = 0, y = 0, z = 0) {
    _Vector3.prototype.isVector3 = true;
    this.x = x;
    this.y = y;
    this.z = z;
  }
  set(x, y, z) {
    if (z === void 0) z = this.z;
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }
  applyEuler(euler) {
    return this.applyQuaternion(_quaternion$1.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$1.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  }
  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  }
  applyQuaternion(q) {
    const x = this.x, y = this.y, z = this.z;
    const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
    const ix = qw * x + qy * z - qz * y;
    const iy = qw * y + qz * x - qx * z;
    const iz = qw * z + qx * y - qy * x;
    const iw = -qx * x - qy * y - qz * z;
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  }
  // project( camera ) {
  // 	return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );
  // }
  // unproject( camera ) {
  // 	return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );
  // }
  transformDirection(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  cross(v) {
    return this.crossVectors(this, v);
  }
  crossVectors(a, b) {
    const ax = a.x, ay = a.y, az = a.z;
    const bx = b.x, by = b.y, bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0) return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector$3.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$3);
  }
  reflect(normal) {
    return this.sub(_vector$3.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  }
  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }
  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }
  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4);
  }
  setFromMatrix3Column(m, index) {
    return this.fromArray(m.elements, index * 3);
  }
  setFromEuler(e) {
    this.x = e._x;
    this.y = e._y;
    this.z = e._z;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  // fromBufferAttribute( attribute, index ) {
  // 	this.x = attribute.getX( index );
  // 	this.y = attribute.getY( index );
  // 	this.z = attribute.getZ( index );
  // 	return this;
  // }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  randomDirection() {
    const u2 = (Math.random() - 0.5) * 2;
    const t = Math.random() * Math.PI * 2;
    const f = Math.sqrt(1 - u2 ** 2);
    this.x = f * Math.cos(t);
    this.y = f * Math.sin(t);
    this.z = u2;
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
};
var _vector$3 = new Vector3();
var _quaternion$1 = new Quaternion();
var _vector$2 = new Vector2();
var Box3 = class {
  constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.isBox3 = true;
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromArray(array) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i = 0, l = array.length; i < l; i += 3) {
      const x = array[i];
      const y = array[i + 1];
      const z = array[i + 2];
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (z < minZ) minZ = z;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      if (z > maxZ) maxZ = z;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  // setFromBufferAttribute( attribute ) {
  // 	let minX = + Infinity;
  // 	let minY = + Infinity;
  // 	let minZ = + Infinity;
  // 	let maxX = - Infinity;
  // 	let maxY = - Infinity;
  // 	let maxZ = - Infinity;
  // 	for ( let i = 0, l = attribute.count; i < l; i ++ ) {
  // 		const x = attribute.getX( i );
  // 		const y = attribute.getY( i );
  // 		const z = attribute.getZ( i );
  // 		if ( x < minX ) minX = x;
  // 		if ( y < minY ) minY = y;
  // 		if ( z < minZ ) minZ = z;
  // 		if ( x > maxX ) maxX = x;
  // 		if ( y > maxY ) maxY = y;
  // 		if ( z > maxZ ) maxZ = z;
  // 	}
  // 	this.min.set( minX, minY, minZ );
  // 	this.max.set( maxX, maxY, maxZ );
  // 	return this;
  // }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$1.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object, precise = false) {
    this.makeEmpty();
    return this.expandByObject(object, precise);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target = new Vector3()) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target = new Vector3()) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  // expandByObject( object, precise = false ) {
  // 	// Computes the world-axis-aligned bounding box of an object (including its children),
  // 	// accounting for both the object's, and children's, world transforms
  // 	object.updateWorldMatrix( false, false );
  // 	const geometry = object.geometry;
  // 	if ( geometry !== undefined ) {
  // 		if ( precise && geometry.attributes != undefined && geometry.attributes.position !== undefined ) {
  // 			const position = geometry.attributes.position;
  // 			for ( let i = 0, l = position.count; i < l; i ++ ) {
  // 				_vector.fromBufferAttribute( position, i ).applyMatrix4( object.matrixWorld );
  // 				this.expandByPoint( _vector );
  // 			}
  // 		} else {
  // 			if ( geometry.boundingBox === null ) {
  // 				geometry.computeBoundingBox();
  // 			}
  // 			_box.copy( geometry.boundingBox );
  // 			_box.applyMatrix4( object.matrixWorld );
  // 			this.union( _box );
  // 		}
  // 	}
  // 	const children = object.children;
  // 	for ( let i = 0, l = children.length; i < l; i ++ ) {
  // 		this.expandByObject( children[ i ], precise );
  // 	}
  // 	return this;
  // }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y),
      (point.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$1);
    return _vector$1.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$1.subVectors(triangle.a, _center);
    _v1$3.subVectors(triangle.b, _center);
    _v2$1.subVectors(triangle.c, _center);
    _f0.subVectors(_v1$3, _v0$1);
    _f1.subVectors(_v2$1, _v1$3);
    _f2.subVectors(_v0$1, _v2$1);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0$1, _v1$3, _v2$1, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$1, _v1$3, _v2$1, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$1, _v1$3, _v2$1, _extents);
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    const clampedPoint = _vector$1.copy(point).clamp(this.min, this.max);
    return clampedPoint.sub(point).length();
  }
  getBoundingSphere(target) {
    this.getCenter(target.center);
    target.radius = this.getSize(_vector$1).length() * 0.5;
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty()) this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty()) return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
};
var _points = [
  new Vector3(),
  new Vector3(),
  new Vector3(),
  new Vector3(),
  new Vector3(),
  new Vector3(),
  new Vector3(),
  new Vector3()
];
var _vector$1 = new Vector3();
var _box$1 = new Box3();
var _v0$1 = new Vector3();
var _v1$3 = new Vector3();
var _v2$1 = new Vector3();
var _f0 = new Vector3();
var _f1 = new Vector3();
var _f2 = new Vector3();
var _center = new Vector3();
var _extents = new Vector3();
var _triangleNormal = new Vector3();
var _testAxis = new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i = 0, j2 = axes.length - 3; i <= j2; i += 3) {
    _testAxis.fromArray(axes, i);
    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      return false;
    }
  }
  return true;
}
function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
var FN = {
  [SRGBColorSpace]: { [LinearSRGBColorSpace]: SRGBToLinear },
  [LinearSRGBColorSpace]: { [SRGBColorSpace]: LinearToSRGB }
};
var ColorManagement = {
  legacyMode: true,
  get workingColorSpace() {
    return LinearSRGBColorSpace;
  },
  set workingColorSpace(colorSpace) {
    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
  },
  convert: function(color, sourceColorSpace, targetColorSpace) {
    if (this.legacyMode || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
      return color;
    }
    if (FN[sourceColorSpace] && FN[sourceColorSpace][targetColorSpace] !== void 0) {
      const fn2 = FN[sourceColorSpace][targetColorSpace];
      color.r = fn2(color.r);
      color.g = fn2(color.g);
      color.b = fn2(color.b);
      return color;
    }
    throw new Error("Unsupported color space conversion.");
  },
  fromWorkingColorSpace: function(color, targetColorSpace) {
    return this.convert(color, this.workingColorSpace, targetColorSpace);
  },
  toWorkingColorSpace: function(color, sourceColorSpace) {
    return this.convert(color, sourceColorSpace, this.workingColorSpace);
  }
};
var _colorKeywords = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
var _rgb = { r: 0, g: 0, b: 0 };
var _hslA = { h: 0, s: 0, l: 0 };
var _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}
function toComponents(source, target) {
  target.r = source.r;
  target.g = source.g;
  target.b = source.b;
  return target;
}
var Color = class {
  constructor(r, g, b) {
    this.isColor = true;
    this.r = 1;
    this.g = 1;
    this.b = 1;
    if (g === void 0 && b === void 0) {
      return this.set(r);
    }
    return this.setRGB(r, g, b);
  }
  set(value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === "number") {
      this.setHex(value);
    } else if (typeof value === "string") {
      this.setStyle(value);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex, colorSpace = SRGBColorSpace) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {
    this.r = r;
    this.g = g;
    this.b = b;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {
    h = euclideanModulo(h, 1);
    s = clamp(s, 0, 1);
    l = clamp(l, 0, 1);
    if (s === 0) {
      this.r = this.g = this.b = l;
    } else {
      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      const q = 2 * l - p;
      this.r = hue2rgb(q, p, h + 1 / 3);
      this.g = hue2rgb(q, p, h);
      this.b = hue2rgb(q, p, h - 1 / 3);
    }
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setStyle(style, colorSpace = SRGBColorSpace) {
    function handleAlpha(string) {
      if (string === void 0) return;
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m;
    if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
      let color;
      const name = m[1];
      const components = m[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            ColorManagement.toWorkingColorSpace(this, colorSpace);
            handleAlpha(color[4]);
            return this;
          }
          if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            ColorManagement.toWorkingColorSpace(this, colorSpace);
            handleAlpha(color[4]);
            return this;
          }
          break;
        case "hsl":
        case "hsla":
          if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            const h = parseFloat(color[1]) / 360;
            const s = parseFloat(color[2]) / 100;
            const l = parseFloat(color[3]) / 100;
            handleAlpha(color[4]);
            return this.setHSL(h, s, l, colorSpace);
          }
          break;
      }
    } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m[1];
      const size = hex.length;
      if (size === 3) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        ColorManagement.toWorkingColorSpace(this, colorSpace);
        return this;
      } else if (size === 6) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        ColorManagement.toWorkingColorSpace(this, colorSpace);
        return this;
      }
    }
    if (style && style.length > 0) {
      return this.setColorName(style, colorSpace);
    }
    return this;
  }
  setColorName(style, colorSpace = SRGBColorSpace) {
    const hex = _colorKeywords[style.toLowerCase()];
    if (hex !== void 0) {
      this.setHex(hex, colorSpace);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }
  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }
  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
    return clamp(_rgb.r * 255, 0, 255) << 16 ^ clamp(_rgb.g * 255, 0, 255) << 8 ^ clamp(_rgb.b * 255, 0, 255) << 0;
  }
  getHexString(colorSpace = SRGBColorSpace) {
    return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
  }
  getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
    const r = _rgb.r, g = _rgb.g, b = _rgb.b;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let hue, saturation;
    const lightness = (min + max) / 2;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;
        case g:
          hue = (b - r) / delta + 2;
          break;
        case b:
          hue = (r - g) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
    target.r = _rgb.r;
    target.g = _rgb.g;
    target.b = _rgb.b;
    return target;
  }
  getStyle(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
    if (colorSpace !== SRGBColorSpace) {
      return `color(${colorSpace} ${_rgb.r} ${_rgb.g} ${_rgb.b})`;
    }
    return `rgb(${_rgb.r * 255 | 0},${_rgb.g * 255 | 0},${_rgb.b * 255 | 0})`;
  }
  offsetHSL(h, s, l) {
    this.getHSL(_hslA);
    _hslA.h += h;
    _hslA.s += s;
    _hslA.l += l;
    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
    return this;
  }
  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  }
  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }
  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }
  multiplyScalar(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  }
  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h = lerp(_hslA.h, _hslB.h, alpha);
    const s = lerp(_hslA.s, _hslB.s, alpha);
    const l = lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h, s, l);
    return this;
  }
  equals(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  }
  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
  // fromBufferAttribute( attribute, index ) {
  // 	this.r = attribute.getX( index );
  // 	this.g = attribute.getY( index );
  // 	this.b = attribute.getZ( index );
  // 	if ( attribute.normalized === true ) {
  // 		// assuming Uint8Array
  // 		this.r /= 255;
  // 		this.g /= 255;
  // 		this.b /= 255;
  // 	}
  // 	return this;
  // }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r;
    yield this.g;
    yield this.b;
  }
};
Color.NAMES = _colorKeywords;
var Matrix4 = class _Matrix4 {
  constructor() {
    _Matrix4.prototype.isMatrix4 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te2 = this.elements;
    te2[0] = n11;
    te2[4] = n12;
    te2[8] = n13;
    te2[12] = n14;
    te2[1] = n21;
    te2[5] = n22;
    te2[9] = n23;
    te2[13] = n24;
    te2[2] = n31;
    te2[6] = n32;
    te2[10] = n33;
    te2[14] = n34;
    te2[3] = n41;
    te2[7] = n42;
    te2[11] = n43;
    te2[15] = n44;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  clone() {
    return new _Matrix4().fromArray(this.elements);
  }
  copy(m) {
    const te2 = this.elements;
    const me2 = m.elements;
    te2[0] = me2[0];
    te2[1] = me2[1];
    te2[2] = me2[2];
    te2[3] = me2[3];
    te2[4] = me2[4];
    te2[5] = me2[5];
    te2[6] = me2[6];
    te2[7] = me2[7];
    te2[8] = me2[8];
    te2[9] = me2[9];
    te2[10] = me2[10];
    te2[11] = me2[11];
    te2[12] = me2[12];
    te2[13] = me2[13];
    te2[14] = me2[14];
    te2[15] = me2[15];
    return this;
  }
  copyPosition(m) {
    const te2 = this.elements, me2 = m.elements;
    te2[12] = me2[12];
    te2[13] = me2[13];
    te2[14] = me2[14];
    return this;
  }
  setFromMatrix3(m) {
    const me2 = m.elements;
    this.set(
      me2[0],
      me2[3],
      me2[6],
      0,
      me2[1],
      me2[4],
      me2[7],
      0,
      me2[2],
      me2[5],
      me2[8],
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(
      xAxis.x,
      yAxis.x,
      zAxis.x,
      0,
      xAxis.y,
      yAxis.y,
      zAxis.y,
      0,
      xAxis.z,
      yAxis.z,
      zAxis.z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractRotation(m) {
    const te2 = this.elements;
    const me2 = m.elements;
    const scaleX = 1 / _v1$2.setFromMatrixColumn(m, 0).length();
    const scaleY = 1 / _v1$2.setFromMatrixColumn(m, 1).length();
    const scaleZ = 1 / _v1$2.setFromMatrixColumn(m, 2).length();
    te2[0] = me2[0] * scaleX;
    te2[1] = me2[1] * scaleX;
    te2[2] = me2[2] * scaleX;
    te2[3] = 0;
    te2[4] = me2[4] * scaleY;
    te2[5] = me2[5] * scaleY;
    te2[6] = me2[6] * scaleY;
    te2[7] = 0;
    te2[8] = me2[8] * scaleZ;
    te2[9] = me2[9] * scaleZ;
    te2[10] = me2[10] * scaleZ;
    te2[11] = 0;
    te2[12] = 0;
    te2[13] = 0;
    te2[14] = 0;
    te2[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    const te2 = this.elements;
    const x = euler.x, y = euler.y, z = euler.z;
    const a = Math.cos(x), b = Math.sin(x);
    const c = Math.cos(y), d = Math.sin(y);
    const e = Math.cos(z), f = Math.sin(z);
    if (euler.order === "XYZ") {
      const ae2 = a * e, af = a * f, be2 = b * e, bf = b * f;
      te2[0] = c * e;
      te2[4] = -c * f;
      te2[8] = d;
      te2[1] = af + be2 * d;
      te2[5] = ae2 - bf * d;
      te2[9] = -b * c;
      te2[2] = bf - ae2 * d;
      te2[6] = be2 + af * d;
      te2[10] = a * c;
    } else if (euler.order === "YXZ") {
      const ce2 = c * e, cf = c * f, de2 = d * e, df = d * f;
      te2[0] = ce2 + df * b;
      te2[4] = de2 * b - cf;
      te2[8] = a * d;
      te2[1] = a * f;
      te2[5] = a * e;
      te2[9] = -b;
      te2[2] = cf * b - de2;
      te2[6] = df + ce2 * b;
      te2[10] = a * c;
    } else if (euler.order === "ZXY") {
      const ce2 = c * e, cf = c * f, de2 = d * e, df = d * f;
      te2[0] = ce2 - df * b;
      te2[4] = -a * f;
      te2[8] = de2 + cf * b;
      te2[1] = cf + de2 * b;
      te2[5] = a * e;
      te2[9] = df - ce2 * b;
      te2[2] = -a * d;
      te2[6] = b;
      te2[10] = a * c;
    } else if (euler.order === "ZYX") {
      const ae2 = a * e, af = a * f, be2 = b * e, bf = b * f;
      te2[0] = c * e;
      te2[4] = be2 * d - af;
      te2[8] = ae2 * d + bf;
      te2[1] = c * f;
      te2[5] = bf * d + ae2;
      te2[9] = af * d - be2;
      te2[2] = -d;
      te2[6] = b * c;
      te2[10] = a * c;
    } else if (euler.order === "YZX") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te2[0] = c * e;
      te2[4] = bd - ac * f;
      te2[8] = bc * f + ad;
      te2[1] = f;
      te2[5] = a * e;
      te2[9] = -b * e;
      te2[2] = -d * e;
      te2[6] = ad * f + bc;
      te2[10] = ac - bd * f;
    } else if (euler.order === "XZY") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te2[0] = c * e;
      te2[4] = -f;
      te2[8] = d * e;
      te2[1] = ac * f + bd;
      te2[5] = a * e;
      te2[9] = ad * f - bc;
      te2[2] = bc * f - ad;
      te2[6] = b * e;
      te2[10] = bd * f + ac;
    }
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = 0;
    te2[12] = 0;
    te2[13] = 0;
    te2[14] = 0;
    te2[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }
  lookAt(eye, target, up) {
    const te2 = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te2[0] = _x.x;
    te2[4] = _y.x;
    te2[8] = _z.x;
    te2[1] = _x.y;
    te2[5] = _y.y;
    te2[9] = _z.y;
    te2[2] = _x.z;
    te2[6] = _y.z;
    te2[10] = _z.z;
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae2 = a.elements;
    const be2 = b.elements;
    const te2 = this.elements;
    const a11 = ae2[0], a12 = ae2[4], a13 = ae2[8], a14 = ae2[12];
    const a21 = ae2[1], a22 = ae2[5], a23 = ae2[9], a24 = ae2[13];
    const a31 = ae2[2], a32 = ae2[6], a33 = ae2[10], a34 = ae2[14];
    const a41 = ae2[3], a42 = ae2[7], a43 = ae2[11], a44 = ae2[15];
    const b11 = be2[0], b12 = be2[4], b13 = be2[8], b14 = be2[12];
    const b21 = be2[1], b22 = be2[5], b23 = be2[9], b24 = be2[13];
    const b31 = be2[2], b32 = be2[6], b33 = be2[10], b34 = be2[14];
    const b41 = be2[3], b42 = be2[7], b43 = be2[11], b44 = be2[15];
    te2[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te2[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te2[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te2[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te2[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te2[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te2[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te2[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te2[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te2[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te2[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te2[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te2[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te2[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te2[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te2[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s) {
    const te2 = this.elements;
    te2[0] *= s;
    te2[4] *= s;
    te2[8] *= s;
    te2[12] *= s;
    te2[1] *= s;
    te2[5] *= s;
    te2[9] *= s;
    te2[13] *= s;
    te2[2] *= s;
    te2[6] *= s;
    te2[10] *= s;
    te2[14] *= s;
    te2[3] *= s;
    te2[7] *= s;
    te2[11] *= s;
    te2[15] *= s;
    return this;
  }
  determinant() {
    const te2 = this.elements;
    const n11 = te2[0], n12 = te2[4], n13 = te2[8], n14 = te2[12];
    const n21 = te2[1], n22 = te2[5], n23 = te2[9], n24 = te2[13];
    const n31 = te2[2], n32 = te2[6], n33 = te2[10], n34 = te2[14];
    const n41 = te2[3], n42 = te2[7], n43 = te2[11], n44 = te2[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te2 = this.elements;
    let tmp;
    tmp = te2[1];
    te2[1] = te2[4];
    te2[4] = tmp;
    tmp = te2[2];
    te2[2] = te2[8];
    te2[8] = tmp;
    tmp = te2[6];
    te2[6] = te2[9];
    te2[9] = tmp;
    tmp = te2[3];
    te2[3] = te2[12];
    te2[12] = tmp;
    tmp = te2[7];
    te2[7] = te2[13];
    te2[13] = tmp;
    tmp = te2[11];
    te2[11] = te2[14];
    te2[14] = tmp;
    return this;
  }
  setPosition(x, y, z) {
    const te2 = this.elements;
    if (x.isVector3) {
      te2[12] = x.x;
      te2[13] = x.y;
      te2[14] = x.z;
    } else {
      te2[12] = x;
      te2[13] = y;
      te2[14] = z;
    }
    return this;
  }
  invert() {
    const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n41 = te2[3], n12 = te2[4], n22 = te2[5], n32 = te2[6], n42 = te2[7], n13 = te2[8], n23 = te2[9], n33 = te2[10], n43 = te2[11], n14 = te2[12], n24 = te2[13], n34 = te2[14], n44 = te2[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te2[0] = t11 * detInv;
    te2[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te2[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te2[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te2[4] = t12 * detInv;
    te2[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te2[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te2[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te2[8] = t13 * detInv;
    te2[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te2[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te2[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te2[12] = t14 * detInv;
    te2[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te2[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te2[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v) {
    const te2 = this.elements;
    const x = v.x, y = v.y, z = v.z;
    te2[0] *= x;
    te2[4] *= y;
    te2[8] *= z;
    te2[1] *= x;
    te2[5] *= y;
    te2[9] *= z;
    te2[2] *= x;
    te2[6] *= y;
    te2[10] *= z;
    te2[3] *= x;
    te2[7] *= y;
    te2[11] *= z;
    return this;
  }
  getMaxScaleOnAxis() {
    const te2 = this.elements;
    const scaleXSq = te2[0] * te2[0] + te2[1] * te2[1] + te2[2] * te2[2];
    const scaleYSq = te2[4] * te2[4] + te2[5] * te2[5] + te2[6] * te2[6];
    const scaleZSq = te2[8] * te2[8] + te2[9] * te2[9] + te2[10] * te2[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x, y, z) {
    this.set(
      1,
      0,
      0,
      x,
      0,
      1,
      0,
      y,
      0,
      0,
      1,
      z,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationX(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      1,
      0,
      0,
      0,
      0,
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationY(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      0,
      s,
      0,
      0,
      1,
      0,
      0,
      -s,
      0,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationZ(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x, y = axis.y, z = axis.z;
    const tx = t * x, ty = t * y;
    this.set(
      tx * x + c,
      tx * y - s * z,
      tx * z + s * y,
      0,
      tx * y + s * z,
      ty * y + c,
      ty * z - s * x,
      0,
      tx * z - s * y,
      ty * z + s * x,
      t * z * z + c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x, y, z) {
    this.set(
      x,
      0,
      0,
      0,
      0,
      y,
      0,
      0,
      0,
      0,
      z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(
      1,
      yx,
      zx,
      0,
      xy,
      1,
      zy,
      0,
      xz,
      yz,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  compose(position, quaternion, scale) {
    const te2 = this.elements;
    const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
    const x2 = x + x, y2 = y + y, z2 = z + z;
    const xx = x * x2, xy = x * y2, xz = x * z2;
    const yy = y * y2, yz = y * z2, zz = z * z2;
    const wx = w * x2, wy = w * y2, wz = w * z2;
    const sx = scale.x, sy = scale.y, sz = scale.z;
    te2[0] = (1 - (yy + zz)) * sx;
    te2[1] = (xy + wz) * sx;
    te2[2] = (xz - wy) * sx;
    te2[3] = 0;
    te2[4] = (xy - wz) * sy;
    te2[5] = (1 - (xx + zz)) * sy;
    te2[6] = (yz + wx) * sy;
    te2[7] = 0;
    te2[8] = (xz + wy) * sz;
    te2[9] = (yz - wx) * sz;
    te2[10] = (1 - (xx + yy)) * sz;
    te2[11] = 0;
    te2[12] = position.x;
    te2[13] = position.y;
    te2[14] = position.z;
    te2[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale) {
    const te2 = this.elements;
    let sx = _v1$2.set(te2[0], te2[1], te2[2]).length();
    const sy = _v1$2.set(te2[4], te2[5], te2[6]).length();
    const sz = _v1$2.set(te2[8], te2[9], te2[10]).length();
    const det = this.determinant();
    if (det < 0) sx = -sx;
    position.x = te2[12];
    position.y = te2[13];
    position.z = te2[14];
    _m1.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1.elements[0] *= invSX;
    _m1.elements[1] *= invSX;
    _m1.elements[2] *= invSX;
    _m1.elements[4] *= invSY;
    _m1.elements[5] *= invSY;
    _m1.elements[6] *= invSY;
    _m1.elements[8] *= invSZ;
    _m1.elements[9] *= invSZ;
    _m1.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far) {
    const te2 = this.elements;
    const x = 2 * near / (right - left);
    const y = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    const c = -(far + near) / (far - near);
    const d = -2 * far * near / (far - near);
    te2[0] = x;
    te2[4] = 0;
    te2[8] = a;
    te2[12] = 0;
    te2[1] = 0;
    te2[5] = y;
    te2[9] = b;
    te2[13] = 0;
    te2[2] = 0;
    te2[6] = 0;
    te2[10] = c;
    te2[14] = d;
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = -1;
    te2[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far) {
    const te2 = this.elements;
    const w = 1 / (right - left);
    const h = 1 / (top - bottom);
    const p = 1 / (far - near);
    const x = (right + left) * w;
    const y = (top + bottom) * h;
    const z = (far + near) * p;
    te2[0] = 2 * w;
    te2[4] = 0;
    te2[8] = 0;
    te2[12] = -x;
    te2[1] = 0;
    te2[5] = 2 * h;
    te2[9] = 0;
    te2[13] = -y;
    te2[2] = 0;
    te2[6] = 0;
    te2[10] = -2 * p;
    te2[14] = -z;
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = 0;
    te2[15] = 1;
    return this;
  }
  equals(matrix) {
    const te2 = this.elements;
    const me2 = matrix.elements;
    for (let i = 0; i < 16; i++) {
      if (te2[i] !== me2[i]) return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te2 = this.elements;
    array[offset] = te2[0];
    array[offset + 1] = te2[1];
    array[offset + 2] = te2[2];
    array[offset + 3] = te2[3];
    array[offset + 4] = te2[4];
    array[offset + 5] = te2[5];
    array[offset + 6] = te2[6];
    array[offset + 7] = te2[7];
    array[offset + 8] = te2[8];
    array[offset + 9] = te2[9];
    array[offset + 10] = te2[10];
    array[offset + 11] = te2[11];
    array[offset + 12] = te2[12];
    array[offset + 13] = te2[13];
    array[offset + 14] = te2[14];
    array[offset + 15] = te2[15];
    return array;
  }
};
var _v1$2 = new Vector3();
var _m1 = new Matrix4();
var _zero = new Vector3(0, 0, 0);
var _one = new Vector3(1, 1, 1);
var _x = new Vector3();
var _y = new Vector3();
var _z = new Vector3();
var _matrix = new Matrix4();
var _quaternion = new Quaternion();
var Euler = class _Euler {
  constructor(x = 0, y = 0, z = 0, order = _Euler.DefaultOrder) {
    this.isEuler = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x, y, z, order = this._order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m, order = this._order, update = true) {
    const te2 = m.elements;
    const m11 = te2[0], m12 = te2[4], m13 = te2[8];
    const m21 = te2[1], m22 = te2[5], m23 = te2[9];
    const m31 = te2[2], m32 = te2[6], m33 = te2[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update === true) this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q, order, update) {
    _matrix.makeRotationFromQuaternion(q);
    return this.setFromRotationMatrix(_matrix, order, update);
  }
  setFromVector3(v, order = this._order) {
    return this.set(v.x, v.y, v.z, order);
  }
  reorder(newOrder) {
    _quaternion.setFromEuler(this);
    return this.setFromQuaternion(_quaternion, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0) this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._order;
  }
  // @deprecated since r138, 02cf0df1cb4575d5842fef9c85bb5a89fe020d53
  toVector3() {
    console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
  }
};
Euler.DefaultOrder = "XYZ";
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
var _startP = new Vector3();
var _startEnd = new Vector3();
var Matrix3 = class _Matrix3 {
  constructor() {
    _Matrix3.prototype.isMatrix3 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te2 = this.elements;
    te2[0] = n11;
    te2[1] = n21;
    te2[2] = n31;
    te2[3] = n12;
    te2[4] = n22;
    te2[5] = n32;
    te2[6] = n13;
    te2[7] = n23;
    te2[8] = n33;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    );
    return this;
  }
  copy(m) {
    const te2 = this.elements;
    const me2 = m.elements;
    te2[0] = me2[0];
    te2[1] = me2[1];
    te2[2] = me2[2];
    te2[3] = me2[3];
    te2[4] = me2[4];
    te2[5] = me2[5];
    te2[6] = me2[6];
    te2[7] = me2[7];
    te2[8] = me2[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m) {
    const me2 = m.elements;
    this.set(
      me2[0],
      me2[4],
      me2[8],
      me2[1],
      me2[5],
      me2[9],
      me2[2],
      me2[6],
      me2[10]
    );
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae2 = a.elements;
    const be2 = b.elements;
    const te2 = this.elements;
    const a11 = ae2[0], a12 = ae2[3], a13 = ae2[6];
    const a21 = ae2[1], a22 = ae2[4], a23 = ae2[7];
    const a31 = ae2[2], a32 = ae2[5], a33 = ae2[8];
    const b11 = be2[0], b12 = be2[3], b13 = be2[6];
    const b21 = be2[1], b22 = be2[4], b23 = be2[7];
    const b31 = be2[2], b32 = be2[5], b33 = be2[8];
    te2[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te2[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te2[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te2[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te2[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te2[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te2[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te2[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te2[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s) {
    const te2 = this.elements;
    te2[0] *= s;
    te2[3] *= s;
    te2[6] *= s;
    te2[1] *= s;
    te2[4] *= s;
    te2[7] *= s;
    te2[2] *= s;
    te2[5] *= s;
    te2[8] *= s;
    return this;
  }
  determinant() {
    const te2 = this.elements;
    const a = te2[0], b = te2[1], c = te2[2], d = te2[3], e = te2[4], f = te2[5], g = te2[6], h = te2[7], i = te2[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  }
  invert() {
    const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n12 = te2[3], n22 = te2[4], n32 = te2[5], n13 = te2[6], n23 = te2[7], n33 = te2[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te2[0] = t11 * detInv;
    te2[1] = (n31 * n23 - n33 * n21) * detInv;
    te2[2] = (n32 * n21 - n31 * n22) * detInv;
    te2[3] = t12 * detInv;
    te2[4] = (n33 * n11 - n31 * n13) * detInv;
    te2[5] = (n31 * n12 - n32 * n11) * detInv;
    te2[6] = t13 * detInv;
    te2[7] = (n21 * n13 - n23 * n11) * detInv;
    te2[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp;
    const m = this.elements;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(
      sx * c,
      sx * s,
      -sx * (c * cx + s * cy) + cx + tx,
      -sy * s,
      sy * c,
      -sy * (-s * cx + c * cy) + cy + ty,
      0,
      0,
      1
    );
    return this;
  }
  //
  scale(sx, sy) {
    this.premultiply(_m3.makeScale(sx, sy));
    return this;
  }
  rotate(theta) {
    this.premultiply(_m3.makeRotation(-theta));
    return this;
  }
  translate(tx, ty) {
    this.premultiply(_m3.makeTranslation(tx, ty));
    return this;
  }
  // for 2D Transforms
  makeTranslation(x, y) {
    this.set(
      1,
      0,
      x,
      0,
      1,
      y,
      0,
      0,
      1
    );
    return this;
  }
  makeRotation(theta) {
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    this.set(
      c,
      -s,
      0,
      s,
      c,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x, y) {
    this.set(
      x,
      0,
      0,
      0,
      y,
      0,
      0,
      0,
      1
    );
    return this;
  }
  //
  equals(matrix) {
    const te2 = this.elements;
    const me2 = matrix.elements;
    for (let i = 0; i < 9; i++) {
      if (te2[i] !== me2[i]) return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te2 = this.elements;
    array[offset] = te2[0];
    array[offset + 1] = te2[1];
    array[offset + 2] = te2[2];
    array[offset + 3] = te2[3];
    array[offset + 4] = te2[4];
    array[offset + 5] = te2[5];
    array[offset + 6] = te2[6];
    array[offset + 7] = te2[7];
    array[offset + 8] = te2[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
var _m3 = new Matrix3();
var _vector1 = new Vector3();
var _vector2 = new Vector3();
var _normalMatrix = new Matrix3();
var _vector = new Vector3();
var _segCenter = new Vector3();
var _segDir = new Vector3();
var _diff = new Vector3();
var _edge1 = new Vector3();
var _edge2 = new Vector3();
var _normal = new Vector3();
var _box = new Box3();
var _v1$1 = new Vector3();
var _toFarthestPoint = new Vector3();
var _toPoint = new Vector3();
var _v0 = new Vector3();
var _v1 = new Vector3();
var _v2 = new Vector3();
var _v3 = new Vector3();
var _vab = new Vector3();
var _vac = new Vector3();
var _vbc = new Vector3();
var _vap = new Vector3();
var _vbp = new Vector3();
var _vcp = new Vector3();

// node_modules/@3dverse/livelink-webxr/dist/index.mjs
var import_react = __toESM(require_react(), 1);
var ur = Object.defineProperty;
var G = (r, e) => {
  for (var n in e) ur(r, n, { get: e[n], enumerable: true });
};
var R = 1e-6;
var P2 = typeof Float32Array < "u" ? Float32Array : Array;
var N = Math.random;
var Ja = Math.PI / 180;
Math.hypot || (Math.hypot = function() {
  for (var r = 0, e = arguments.length; e--; ) r += arguments[e] * arguments[e];
  return Math.sqrt(r);
});
function sr() {
  var r = new P2(9);
  return P2 != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[5] = 0, r[6] = 0, r[7] = 0), r[0] = 1, r[4] = 1, r[8] = 1, r;
}
var D = {};
G(D, { add: () => Ce2, adjoint: () => ve, clone: () => ne, copy: () => ae, create: () => ee, determinant: () => le, equals: () => We, exactEquals: () => De, frob: () => qe, fromQuat: () => be, fromQuat2: () => Re, fromRotation: () => ge, fromRotationTranslation: () => lr, fromRotationTranslationScale: () => Se, fromRotationTranslationScaleOrigin: () => Pe, fromScaling: () => de, fromTranslation: () => me, fromValues: () => ie, fromXRotation: () => _e, fromYRotation: () => ye, fromZRotation: () => we, frustum: () => Le, getRotation: () => Ee, getScaling: () => hr, getTranslation: () => Ae, identity: () => cr, invert: () => ce, lookAt: () => Fe, mul: () => Ue, multiply: () => vr, multiplyScalar: () => Ye, multiplyScalarAndAdd: () => ke, ortho: () => Xe, orthoNO: () => or, orthoZO: () => Oe, perspective: () => Te, perspectiveFromFieldOfView: () => Ie, perspectiveNO: () => fr, perspectiveZO: () => ze, rotate: () => oe, rotateX: () => pe, rotateY: () => xe, rotateZ: () => Me, scale: () => fe, set: () => te, str: () => Ve, sub: () => Ge, subtract: () => pr, targetTo: () => Ne, translate: () => he, transpose: () => se });
function ee() {
  var r = new P2(16);
  return P2 != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0), r[0] = 1, r[5] = 1, r[10] = 1, r[15] = 1, r;
}
function ne(r) {
  var e = new P2(16);
  return e[0] = r[0], e[1] = r[1], e[2] = r[2], e[3] = r[3], e[4] = r[4], e[5] = r[5], e[6] = r[6], e[7] = r[7], e[8] = r[8], e[9] = r[9], e[10] = r[10], e[11] = r[11], e[12] = r[12], e[13] = r[13], e[14] = r[14], e[15] = r[15], e;
}
function ae(r, e) {
  return r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[4] = e[4], r[5] = e[5], r[6] = e[6], r[7] = e[7], r[8] = e[8], r[9] = e[9], r[10] = e[10], r[11] = e[11], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15], r;
}
function ie(r, e, n, a, i, t, s, c, v, l, h, f, x, p, m, M) {
  var o = new P2(16);
  return o[0] = r, o[1] = e, o[2] = n, o[3] = a, o[4] = i, o[5] = t, o[6] = s, o[7] = c, o[8] = v, o[9] = l, o[10] = h, o[11] = f, o[12] = x, o[13] = p, o[14] = m, o[15] = M, o;
}
function te(r, e, n, a, i, t, s, c, v, l, h, f, x, p, m, M, o) {
  return r[0] = e, r[1] = n, r[2] = a, r[3] = i, r[4] = t, r[5] = s, r[6] = c, r[7] = v, r[8] = l, r[9] = h, r[10] = f, r[11] = x, r[12] = p, r[13] = m, r[14] = M, r[15] = o, r;
}
function cr(r) {
  return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
}
function se(r, e) {
  if (r === e) {
    var n = e[1], a = e[2], i = e[3], t = e[6], s = e[7], c = e[11];
    r[1] = e[4], r[2] = e[8], r[3] = e[12], r[4] = n, r[6] = e[9], r[7] = e[13], r[8] = a, r[9] = t, r[11] = e[14], r[12] = i, r[13] = s, r[14] = c;
  } else r[0] = e[0], r[1] = e[4], r[2] = e[8], r[3] = e[12], r[4] = e[1], r[5] = e[5], r[6] = e[9], r[7] = e[13], r[8] = e[2], r[9] = e[6], r[10] = e[10], r[11] = e[14], r[12] = e[3], r[13] = e[7], r[14] = e[11], r[15] = e[15];
  return r;
}
function ce(r, e) {
  var n = e[0], a = e[1], i = e[2], t = e[3], s = e[4], c = e[5], v = e[6], l = e[7], h = e[8], f = e[9], x = e[10], p = e[11], m = e[12], M = e[13], o = e[14], d = e[15], A = n * c - a * s, w = n * v - i * s, g = n * l - t * s, _ = a * v - i * c, y = a * l - t * c, S = i * l - t * v, b = h * M - f * m, L = h * o - x * m, T = h * d - p * m, z = f * o - x * M, I = f * d - p * M, X = x * d - p * o, E = A * X - w * I + g * z + _ * T - y * L + S * b;
  return E ? (E = 1 / E, r[0] = (c * X - v * I + l * z) * E, r[1] = (i * I - a * X - t * z) * E, r[2] = (M * S - o * y + d * _) * E, r[3] = (x * y - f * S - p * _) * E, r[4] = (v * T - s * X - l * L) * E, r[5] = (n * X - i * T + t * L) * E, r[6] = (o * g - m * S - d * w) * E, r[7] = (h * S - x * g + p * w) * E, r[8] = (s * I - c * T + l * b) * E, r[9] = (a * T - n * I - t * b) * E, r[10] = (m * y - M * g + d * A) * E, r[11] = (f * g - h * y - p * A) * E, r[12] = (c * L - s * z - v * b) * E, r[13] = (n * z - a * L + i * b) * E, r[14] = (M * w - m * _ - o * A) * E, r[15] = (h * _ - f * w + x * A) * E, r) : null;
}
function ve(r, e) {
  var n = e[0], a = e[1], i = e[2], t = e[3], s = e[4], c = e[5], v = e[6], l = e[7], h = e[8], f = e[9], x = e[10], p = e[11], m = e[12], M = e[13], o = e[14], d = e[15];
  return r[0] = c * (x * d - p * o) - f * (v * d - l * o) + M * (v * p - l * x), r[1] = -(a * (x * d - p * o) - f * (i * d - t * o) + M * (i * p - t * x)), r[2] = a * (v * d - l * o) - c * (i * d - t * o) + M * (i * l - t * v), r[3] = -(a * (v * p - l * x) - c * (i * p - t * x) + f * (i * l - t * v)), r[4] = -(s * (x * d - p * o) - h * (v * d - l * o) + m * (v * p - l * x)), r[5] = n * (x * d - p * o) - h * (i * d - t * o) + m * (i * p - t * x), r[6] = -(n * (v * d - l * o) - s * (i * d - t * o) + m * (i * l - t * v)), r[7] = n * (v * p - l * x) - s * (i * p - t * x) + h * (i * l - t * v), r[8] = s * (f * d - p * M) - h * (c * d - l * M) + m * (c * p - l * f), r[9] = -(n * (f * d - p * M) - h * (a * d - t * M) + m * (a * p - t * f)), r[10] = n * (c * d - l * M) - s * (a * d - t * M) + m * (a * l - t * c), r[11] = -(n * (c * p - l * f) - s * (a * p - t * f) + h * (a * l - t * c)), r[12] = -(s * (f * o - x * M) - h * (c * o - v * M) + m * (c * x - v * f)), r[13] = n * (f * o - x * M) - h * (a * o - i * M) + m * (a * x - i * f), r[14] = -(n * (c * o - v * M) - s * (a * o - i * M) + m * (a * v - i * c)), r[15] = n * (c * x - v * f) - s * (a * x - i * f) + h * (a * v - i * c), r;
}
function le(r) {
  var e = r[0], n = r[1], a = r[2], i = r[3], t = r[4], s = r[5], c = r[6], v = r[7], l = r[8], h = r[9], f = r[10], x = r[11], p = r[12], m = r[13], M = r[14], o = r[15], d = e * s - n * t, A = e * c - a * t, w = e * v - i * t, g = n * c - a * s, _ = n * v - i * s, y = a * v - i * c, S = l * m - h * p, b = l * M - f * p, L = l * o - x * p, T = h * M - f * m, z = h * o - x * m, I = f * o - x * M;
  return d * I - A * z + w * T + g * L - _ * b + y * S;
}
function vr(r, e, n) {
  var a = e[0], i = e[1], t = e[2], s = e[3], c = e[4], v = e[5], l = e[6], h = e[7], f = e[8], x = e[9], p = e[10], m = e[11], M = e[12], o = e[13], d = e[14], A = e[15], w = n[0], g = n[1], _ = n[2], y = n[3];
  return r[0] = w * a + g * c + _ * f + y * M, r[1] = w * i + g * v + _ * x + y * o, r[2] = w * t + g * l + _ * p + y * d, r[3] = w * s + g * h + _ * m + y * A, w = n[4], g = n[5], _ = n[6], y = n[7], r[4] = w * a + g * c + _ * f + y * M, r[5] = w * i + g * v + _ * x + y * o, r[6] = w * t + g * l + _ * p + y * d, r[7] = w * s + g * h + _ * m + y * A, w = n[8], g = n[9], _ = n[10], y = n[11], r[8] = w * a + g * c + _ * f + y * M, r[9] = w * i + g * v + _ * x + y * o, r[10] = w * t + g * l + _ * p + y * d, r[11] = w * s + g * h + _ * m + y * A, w = n[12], g = n[13], _ = n[14], y = n[15], r[12] = w * a + g * c + _ * f + y * M, r[13] = w * i + g * v + _ * x + y * o, r[14] = w * t + g * l + _ * p + y * d, r[15] = w * s + g * h + _ * m + y * A, r;
}
function he(r, e, n) {
  var a = n[0], i = n[1], t = n[2], s, c, v, l, h, f, x, p, m, M, o, d;
  return e === r ? (r[12] = e[0] * a + e[4] * i + e[8] * t + e[12], r[13] = e[1] * a + e[5] * i + e[9] * t + e[13], r[14] = e[2] * a + e[6] * i + e[10] * t + e[14], r[15] = e[3] * a + e[7] * i + e[11] * t + e[15]) : (s = e[0], c = e[1], v = e[2], l = e[3], h = e[4], f = e[5], x = e[6], p = e[7], m = e[8], M = e[9], o = e[10], d = e[11], r[0] = s, r[1] = c, r[2] = v, r[3] = l, r[4] = h, r[5] = f, r[6] = x, r[7] = p, r[8] = m, r[9] = M, r[10] = o, r[11] = d, r[12] = s * a + h * i + m * t + e[12], r[13] = c * a + f * i + M * t + e[13], r[14] = v * a + x * i + o * t + e[14], r[15] = l * a + p * i + d * t + e[15]), r;
}
function fe(r, e, n) {
  var a = n[0], i = n[1], t = n[2];
  return r[0] = e[0] * a, r[1] = e[1] * a, r[2] = e[2] * a, r[3] = e[3] * a, r[4] = e[4] * i, r[5] = e[5] * i, r[6] = e[6] * i, r[7] = e[7] * i, r[8] = e[8] * t, r[9] = e[9] * t, r[10] = e[10] * t, r[11] = e[11] * t, r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15], r;
}
function oe(r, e, n, a) {
  var i = a[0], t = a[1], s = a[2], c = Math.hypot(i, t, s), v, l, h, f, x, p, m, M, o, d, A, w, g, _, y, S, b, L, T, z, I, X, E, F;
  return c < R ? null : (c = 1 / c, i *= c, t *= c, s *= c, v = Math.sin(n), l = Math.cos(n), h = 1 - l, f = e[0], x = e[1], p = e[2], m = e[3], M = e[4], o = e[5], d = e[6], A = e[7], w = e[8], g = e[9], _ = e[10], y = e[11], S = i * i * h + l, b = t * i * h + s * v, L = s * i * h - t * v, T = i * t * h - s * v, z = t * t * h + l, I = s * t * h + i * v, X = i * s * h + t * v, E = t * s * h - i * v, F = s * s * h + l, r[0] = f * S + M * b + w * L, r[1] = x * S + o * b + g * L, r[2] = p * S + d * b + _ * L, r[3] = m * S + A * b + y * L, r[4] = f * T + M * z + w * I, r[5] = x * T + o * z + g * I, r[6] = p * T + d * z + _ * I, r[7] = m * T + A * z + y * I, r[8] = f * X + M * E + w * F, r[9] = x * X + o * E + g * F, r[10] = p * X + d * E + _ * F, r[11] = m * X + A * E + y * F, e !== r && (r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r);
}
function pe(r, e, n) {
  var a = Math.sin(n), i = Math.cos(n), t = e[4], s = e[5], c = e[6], v = e[7], l = e[8], h = e[9], f = e[10], x = e[11];
  return e !== r && (r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[4] = t * i + l * a, r[5] = s * i + h * a, r[6] = c * i + f * a, r[7] = v * i + x * a, r[8] = l * i - t * a, r[9] = h * i - s * a, r[10] = f * i - c * a, r[11] = x * i - v * a, r;
}
function xe(r, e, n) {
  var a = Math.sin(n), i = Math.cos(n), t = e[0], s = e[1], c = e[2], v = e[3], l = e[8], h = e[9], f = e[10], x = e[11];
  return e !== r && (r[4] = e[4], r[5] = e[5], r[6] = e[6], r[7] = e[7], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = t * i - l * a, r[1] = s * i - h * a, r[2] = c * i - f * a, r[3] = v * i - x * a, r[8] = t * a + l * i, r[9] = s * a + h * i, r[10] = c * a + f * i, r[11] = v * a + x * i, r;
}
function Me(r, e, n) {
  var a = Math.sin(n), i = Math.cos(n), t = e[0], s = e[1], c = e[2], v = e[3], l = e[4], h = e[5], f = e[6], x = e[7];
  return e !== r && (r[8] = e[8], r[9] = e[9], r[10] = e[10], r[11] = e[11], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = t * i + l * a, r[1] = s * i + h * a, r[2] = c * i + f * a, r[3] = v * i + x * a, r[4] = l * i - t * a, r[5] = h * i - s * a, r[6] = f * i - c * a, r[7] = x * i - v * a, r;
}
function me(r, e) {
  return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = e[0], r[13] = e[1], r[14] = e[2], r[15] = 1, r;
}
function de(r, e) {
  return r[0] = e[0], r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = e[1], r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = e[2], r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
}
function ge(r, e, n) {
  var a = n[0], i = n[1], t = n[2], s = Math.hypot(a, i, t), c, v, l;
  return s < R ? null : (s = 1 / s, a *= s, i *= s, t *= s, c = Math.sin(e), v = Math.cos(e), l = 1 - v, r[0] = a * a * l + v, r[1] = i * a * l + t * c, r[2] = t * a * l - i * c, r[3] = 0, r[4] = a * i * l - t * c, r[5] = i * i * l + v, r[6] = t * i * l + a * c, r[7] = 0, r[8] = a * t * l + i * c, r[9] = i * t * l - a * c, r[10] = t * t * l + v, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r);
}
function _e(r, e) {
  var n = Math.sin(e), a = Math.cos(e);
  return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = a, r[6] = n, r[7] = 0, r[8] = 0, r[9] = -n, r[10] = a, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
}
function ye(r, e) {
  var n = Math.sin(e), a = Math.cos(e);
  return r[0] = a, r[1] = 0, r[2] = -n, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = n, r[9] = 0, r[10] = a, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
}
function we(r, e) {
  var n = Math.sin(e), a = Math.cos(e);
  return r[0] = a, r[1] = n, r[2] = 0, r[3] = 0, r[4] = -n, r[5] = a, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
}
function lr(r, e, n) {
  var a = e[0], i = e[1], t = e[2], s = e[3], c = a + a, v = i + i, l = t + t, h = a * c, f = a * v, x = a * l, p = i * v, m = i * l, M = t * l, o = s * c, d = s * v, A = s * l;
  return r[0] = 1 - (p + M), r[1] = f + A, r[2] = x - d, r[3] = 0, r[4] = f - A, r[5] = 1 - (h + M), r[6] = m + o, r[7] = 0, r[8] = x + d, r[9] = m - o, r[10] = 1 - (h + p), r[11] = 0, r[12] = n[0], r[13] = n[1], r[14] = n[2], r[15] = 1, r;
}
function Re(r, e) {
  var n = new P2(3), a = -e[0], i = -e[1], t = -e[2], s = e[3], c = e[4], v = e[5], l = e[6], h = e[7], f = a * a + i * i + t * t + s * s;
  return f > 0 ? (n[0] = (c * s + h * a + v * t - l * i) * 2 / f, n[1] = (v * s + h * i + l * a - c * t) * 2 / f, n[2] = (l * s + h * t + c * i - v * a) * 2 / f) : (n[0] = (c * s + h * a + v * t - l * i) * 2, n[1] = (v * s + h * i + l * a - c * t) * 2, n[2] = (l * s + h * t + c * i - v * a) * 2), lr(r, e, n), r;
}
function Ae(r, e) {
  return r[0] = e[12], r[1] = e[13], r[2] = e[14], r;
}
function hr(r, e) {
  var n = e[0], a = e[1], i = e[2], t = e[4], s = e[5], c = e[6], v = e[8], l = e[9], h = e[10];
  return r[0] = Math.hypot(n, a, i), r[1] = Math.hypot(t, s, c), r[2] = Math.hypot(v, l, h), r;
}
function Ee(r, e) {
  var n = new P2(3);
  hr(n, e);
  var a = 1 / n[0], i = 1 / n[1], t = 1 / n[2], s = e[0] * a, c = e[1] * i, v = e[2] * t, l = e[4] * a, h = e[5] * i, f = e[6] * t, x = e[8] * a, p = e[9] * i, m = e[10] * t, M = s + h + m, o = 0;
  return M > 0 ? (o = Math.sqrt(M + 1) * 2, r[3] = 0.25 * o, r[0] = (f - p) / o, r[1] = (x - v) / o, r[2] = (c - l) / o) : s > h && s > m ? (o = Math.sqrt(1 + s - h - m) * 2, r[3] = (f - p) / o, r[0] = 0.25 * o, r[1] = (c + l) / o, r[2] = (x + v) / o) : h > m ? (o = Math.sqrt(1 + h - s - m) * 2, r[3] = (x - v) / o, r[0] = (c + l) / o, r[1] = 0.25 * o, r[2] = (f + p) / o) : (o = Math.sqrt(1 + m - s - h) * 2, r[3] = (c - l) / o, r[0] = (x + v) / o, r[1] = (f + p) / o, r[2] = 0.25 * o), r;
}
function Se(r, e, n, a) {
  var i = e[0], t = e[1], s = e[2], c = e[3], v = i + i, l = t + t, h = s + s, f = i * v, x = i * l, p = i * h, m = t * l, M = t * h, o = s * h, d = c * v, A = c * l, w = c * h, g = a[0], _ = a[1], y = a[2];
  return r[0] = (1 - (m + o)) * g, r[1] = (x + w) * g, r[2] = (p - A) * g, r[3] = 0, r[4] = (x - w) * _, r[5] = (1 - (f + o)) * _, r[6] = (M + d) * _, r[7] = 0, r[8] = (p + A) * y, r[9] = (M - d) * y, r[10] = (1 - (f + m)) * y, r[11] = 0, r[12] = n[0], r[13] = n[1], r[14] = n[2], r[15] = 1, r;
}
function Pe(r, e, n, a, i) {
  var t = e[0], s = e[1], c = e[2], v = e[3], l = t + t, h = s + s, f = c + c, x = t * l, p = t * h, m = t * f, M = s * h, o = s * f, d = c * f, A = v * l, w = v * h, g = v * f, _ = a[0], y = a[1], S = a[2], b = i[0], L = i[1], T = i[2], z = (1 - (M + d)) * _, I = (p + g) * _, X = (m - w) * _, E = (p - g) * y, F = (1 - (x + d)) * y, Y = (o + A) * y, k = (m + w) * S, ir = (o - A) * S, tr = (1 - (x + M)) * S;
  return r[0] = z, r[1] = I, r[2] = X, r[3] = 0, r[4] = E, r[5] = F, r[6] = Y, r[7] = 0, r[8] = k, r[9] = ir, r[10] = tr, r[11] = 0, r[12] = n[0] + b - (z * b + E * L + k * T), r[13] = n[1] + L - (I * b + F * L + ir * T), r[14] = n[2] + T - (X * b + Y * L + tr * T), r[15] = 1, r;
}
function be(r, e) {
  var n = e[0], a = e[1], i = e[2], t = e[3], s = n + n, c = a + a, v = i + i, l = n * s, h = a * s, f = a * c, x = i * s, p = i * c, m = i * v, M = t * s, o = t * c, d = t * v;
  return r[0] = 1 - f - m, r[1] = h + d, r[2] = x - o, r[3] = 0, r[4] = h - d, r[5] = 1 - l - m, r[6] = p + M, r[7] = 0, r[8] = x + o, r[9] = p - M, r[10] = 1 - l - f, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
}
function Le(r, e, n, a, i, t, s) {
  var c = 1 / (n - e), v = 1 / (i - a), l = 1 / (t - s);
  return r[0] = t * 2 * c, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = t * 2 * v, r[6] = 0, r[7] = 0, r[8] = (n + e) * c, r[9] = (i + a) * v, r[10] = (s + t) * l, r[11] = -1, r[12] = 0, r[13] = 0, r[14] = s * t * 2 * l, r[15] = 0, r;
}
function fr(r, e, n, a, i) {
  var t = 1 / Math.tan(e / 2), s;
  return r[0] = t / n, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = t, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = -1, r[12] = 0, r[13] = 0, r[15] = 0, i != null && i !== 1 / 0 ? (s = 1 / (a - i), r[10] = (i + a) * s, r[14] = 2 * i * a * s) : (r[10] = -1, r[14] = -2 * a), r;
}
var Te = fr;
function ze(r, e, n, a, i) {
  var t = 1 / Math.tan(e / 2), s;
  return r[0] = t / n, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = t, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = -1, r[12] = 0, r[13] = 0, r[15] = 0, i != null && i !== 1 / 0 ? (s = 1 / (a - i), r[10] = i * s, r[14] = i * a * s) : (r[10] = -1, r[14] = -a), r;
}
function Ie(r, e, n, a) {
  var i = Math.tan(e.upDegrees * Math.PI / 180), t = Math.tan(e.downDegrees * Math.PI / 180), s = Math.tan(e.leftDegrees * Math.PI / 180), c = Math.tan(e.rightDegrees * Math.PI / 180), v = 2 / (s + c), l = 2 / (i + t);
  return r[0] = v, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = l, r[6] = 0, r[7] = 0, r[8] = -((s - c) * v * 0.5), r[9] = (i - t) * l * 0.5, r[10] = a / (n - a), r[11] = -1, r[12] = 0, r[13] = 0, r[14] = a * n / (n - a), r[15] = 0, r;
}
function or(r, e, n, a, i, t, s) {
  var c = 1 / (e - n), v = 1 / (a - i), l = 1 / (t - s);
  return r[0] = -2 * c, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = -2 * v, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 2 * l, r[11] = 0, r[12] = (e + n) * c, r[13] = (i + a) * v, r[14] = (s + t) * l, r[15] = 1, r;
}
var Xe = or;
function Oe(r, e, n, a, i, t, s) {
  var c = 1 / (e - n), v = 1 / (a - i), l = 1 / (t - s);
  return r[0] = -2 * c, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = -2 * v, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = l, r[11] = 0, r[12] = (e + n) * c, r[13] = (i + a) * v, r[14] = t * l, r[15] = 1, r;
}
function Fe(r, e, n, a) {
  var i, t, s, c, v, l, h, f, x, p, m = e[0], M = e[1], o = e[2], d = a[0], A = a[1], w = a[2], g = n[0], _ = n[1], y = n[2];
  return Math.abs(m - g) < R && Math.abs(M - _) < R && Math.abs(o - y) < R ? cr(r) : (h = m - g, f = M - _, x = o - y, p = 1 / Math.hypot(h, f, x), h *= p, f *= p, x *= p, i = A * x - w * f, t = w * h - d * x, s = d * f - A * h, p = Math.hypot(i, t, s), p ? (p = 1 / p, i *= p, t *= p, s *= p) : (i = 0, t = 0, s = 0), c = f * s - x * t, v = x * i - h * s, l = h * t - f * i, p = Math.hypot(c, v, l), p ? (p = 1 / p, c *= p, v *= p, l *= p) : (c = 0, v = 0, l = 0), r[0] = i, r[1] = c, r[2] = h, r[3] = 0, r[4] = t, r[5] = v, r[6] = f, r[7] = 0, r[8] = s, r[9] = l, r[10] = x, r[11] = 0, r[12] = -(i * m + t * M + s * o), r[13] = -(c * m + v * M + l * o), r[14] = -(h * m + f * M + x * o), r[15] = 1, r);
}
function Ne(r, e, n, a) {
  var i = e[0], t = e[1], s = e[2], c = a[0], v = a[1], l = a[2], h = i - n[0], f = t - n[1], x = s - n[2], p = h * h + f * f + x * x;
  p > 0 && (p = 1 / Math.sqrt(p), h *= p, f *= p, x *= p);
  var m = v * x - l * f, M = l * h - c * x, o = c * f - v * h;
  return p = m * m + M * M + o * o, p > 0 && (p = 1 / Math.sqrt(p), m *= p, M *= p, o *= p), r[0] = m, r[1] = M, r[2] = o, r[3] = 0, r[4] = f * o - x * M, r[5] = x * m - h * o, r[6] = h * M - f * m, r[7] = 0, r[8] = h, r[9] = f, r[10] = x, r[11] = 0, r[12] = i, r[13] = t, r[14] = s, r[15] = 1, r;
}
function Ve(r) {
  return "mat4(" + r[0] + ", " + r[1] + ", " + r[2] + ", " + r[3] + ", " + r[4] + ", " + r[5] + ", " + r[6] + ", " + r[7] + ", " + r[8] + ", " + r[9] + ", " + r[10] + ", " + r[11] + ", " + r[12] + ", " + r[13] + ", " + r[14] + ", " + r[15] + ")";
}
function qe(r) {
  return Math.hypot(r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10], r[11], r[12], r[13], r[14], r[15]);
}
function Ce2(r, e, n) {
  return r[0] = e[0] + n[0], r[1] = e[1] + n[1], r[2] = e[2] + n[2], r[3] = e[3] + n[3], r[4] = e[4] + n[4], r[5] = e[5] + n[5], r[6] = e[6] + n[6], r[7] = e[7] + n[7], r[8] = e[8] + n[8], r[9] = e[9] + n[9], r[10] = e[10] + n[10], r[11] = e[11] + n[11], r[12] = e[12] + n[12], r[13] = e[13] + n[13], r[14] = e[14] + n[14], r[15] = e[15] + n[15], r;
}
function pr(r, e, n) {
  return r[0] = e[0] - n[0], r[1] = e[1] - n[1], r[2] = e[2] - n[2], r[3] = e[3] - n[3], r[4] = e[4] - n[4], r[5] = e[5] - n[5], r[6] = e[6] - n[6], r[7] = e[7] - n[7], r[8] = e[8] - n[8], r[9] = e[9] - n[9], r[10] = e[10] - n[10], r[11] = e[11] - n[11], r[12] = e[12] - n[12], r[13] = e[13] - n[13], r[14] = e[14] - n[14], r[15] = e[15] - n[15], r;
}
function Ye(r, e, n) {
  return r[0] = e[0] * n, r[1] = e[1] * n, r[2] = e[2] * n, r[3] = e[3] * n, r[4] = e[4] * n, r[5] = e[5] * n, r[6] = e[6] * n, r[7] = e[7] * n, r[8] = e[8] * n, r[9] = e[9] * n, r[10] = e[10] * n, r[11] = e[11] * n, r[12] = e[12] * n, r[13] = e[13] * n, r[14] = e[14] * n, r[15] = e[15] * n, r;
}
function ke(r, e, n, a) {
  return r[0] = e[0] + n[0] * a, r[1] = e[1] + n[1] * a, r[2] = e[2] + n[2] * a, r[3] = e[3] + n[3] * a, r[4] = e[4] + n[4] * a, r[5] = e[5] + n[5] * a, r[6] = e[6] + n[6] * a, r[7] = e[7] + n[7] * a, r[8] = e[8] + n[8] * a, r[9] = e[9] + n[9] * a, r[10] = e[10] + n[10] * a, r[11] = e[11] + n[11] * a, r[12] = e[12] + n[12] * a, r[13] = e[13] + n[13] * a, r[14] = e[14] + n[14] * a, r[15] = e[15] + n[15] * a, r;
}
function De(r, e) {
  return r[0] === e[0] && r[1] === e[1] && r[2] === e[2] && r[3] === e[3] && r[4] === e[4] && r[5] === e[5] && r[6] === e[6] && r[7] === e[7] && r[8] === e[8] && r[9] === e[9] && r[10] === e[10] && r[11] === e[11] && r[12] === e[12] && r[13] === e[13] && r[14] === e[14] && r[15] === e[15];
}
function We(r, e) {
  var n = r[0], a = r[1], i = r[2], t = r[3], s = r[4], c = r[5], v = r[6], l = r[7], h = r[8], f = r[9], x = r[10], p = r[11], m = r[12], M = r[13], o = r[14], d = r[15], A = e[0], w = e[1], g = e[2], _ = e[3], y = e[4], S = e[5], b = e[6], L = e[7], T = e[8], z = e[9], I = e[10], X = e[11], E = e[12], F = e[13], Y = e[14], k = e[15];
  return Math.abs(n - A) <= R * Math.max(1, Math.abs(n), Math.abs(A)) && Math.abs(a - w) <= R * Math.max(1, Math.abs(a), Math.abs(w)) && Math.abs(i - g) <= R * Math.max(1, Math.abs(i), Math.abs(g)) && Math.abs(t - _) <= R * Math.max(1, Math.abs(t), Math.abs(_)) && Math.abs(s - y) <= R * Math.max(1, Math.abs(s), Math.abs(y)) && Math.abs(c - S) <= R * Math.max(1, Math.abs(c), Math.abs(S)) && Math.abs(v - b) <= R * Math.max(1, Math.abs(v), Math.abs(b)) && Math.abs(l - L) <= R * Math.max(1, Math.abs(l), Math.abs(L)) && Math.abs(h - T) <= R * Math.max(1, Math.abs(h), Math.abs(T)) && Math.abs(f - z) <= R * Math.max(1, Math.abs(f), Math.abs(z)) && Math.abs(x - I) <= R * Math.max(1, Math.abs(x), Math.abs(I)) && Math.abs(p - X) <= R * Math.max(1, Math.abs(p), Math.abs(X)) && Math.abs(m - E) <= R * Math.max(1, Math.abs(m), Math.abs(E)) && Math.abs(M - F) <= R * Math.max(1, Math.abs(M), Math.abs(F)) && Math.abs(o - Y) <= R * Math.max(1, Math.abs(o), Math.abs(Y)) && Math.abs(d - k) <= R * Math.max(1, Math.abs(d), Math.abs(k));
}
var Ue = vr;
var Ge = pr;
var U = {};
G(U, { add: () => Hn, calculateW: () => Nn, clone: () => Wn, conjugate: () => Yn, copy: () => Gn, create: () => er, dot: () => kr, equals: () => Jn, exactEquals: () => Zn, exp: () => Vr, fromEuler: () => kn, fromMat3: () => Cr, fromValues: () => Un, getAngle: () => In, getAxisAngle: () => zn, identity: () => Tn, invert: () => Cn, len: () => Qn, length: () => Dr, lerp: () => $n, ln: () => qr, mul: () => jn, multiply: () => Nr, normalize: () => nr, pow: () => Vn, random: () => qn, rotateX: () => Xn, rotateY: () => On, rotateZ: () => Fn, rotationTo: () => un, scale: () => Yr, set: () => Bn, setAxes: () => ea, setAxisAngle: () => Fr, slerp: () => $, sqlerp: () => ra, sqrLen: () => Kn, squaredLength: () => Wr, str: () => Dn });
var O = {};
G(O, { add: () => $e, angle: () => Mn, bezier: () => cn, ceil: () => Qe, clone: () => Be, copy: () => He, create: () => B, cross: () => W, dist: () => An, distance: () => gr, div: () => Rn, divide: () => dr, dot: () => j, equals: () => _n, exactEquals: () => gn, floor: () => Ke, forEach: () => Pn, fromValues: () => H, hermite: () => sn, inverse: () => an, len: () => rr, length: () => xr, lerp: () => tn, max: () => Je, min: () => Ze, mul: () => wn, multiply: () => mr, negate: () => nn, normalize: () => u, random: () => vn, rotateX: () => on, rotateY: () => pn, rotateZ: () => xn, round: () => ue, scale: () => rn, scaleAndAdd: () => en, set: () => je, sqrDist: () => En, sqrLen: () => Sn, squaredDistance: () => _r, squaredLength: () => yr, str: () => dn, sub: () => yn, subtract: () => Mr, transformMat3: () => hn, transformMat4: () => ln, transformQuat: () => fn, zero: () => mn });
function B() {
  var r = new P2(3);
  return P2 != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r;
}
function Be(r) {
  var e = new P2(3);
  return e[0] = r[0], e[1] = r[1], e[2] = r[2], e;
}
function xr(r) {
  var e = r[0], n = r[1], a = r[2];
  return Math.hypot(e, n, a);
}
function H(r, e, n) {
  var a = new P2(3);
  return a[0] = r, a[1] = e, a[2] = n, a;
}
function He(r, e) {
  return r[0] = e[0], r[1] = e[1], r[2] = e[2], r;
}
function je(r, e, n, a) {
  return r[0] = e, r[1] = n, r[2] = a, r;
}
function $e(r, e, n) {
  return r[0] = e[0] + n[0], r[1] = e[1] + n[1], r[2] = e[2] + n[2], r;
}
function Mr(r, e, n) {
  return r[0] = e[0] - n[0], r[1] = e[1] - n[1], r[2] = e[2] - n[2], r;
}
function mr(r, e, n) {
  return r[0] = e[0] * n[0], r[1] = e[1] * n[1], r[2] = e[2] * n[2], r;
}
function dr(r, e, n) {
  return r[0] = e[0] / n[0], r[1] = e[1] / n[1], r[2] = e[2] / n[2], r;
}
function Qe(r, e) {
  return r[0] = Math.ceil(e[0]), r[1] = Math.ceil(e[1]), r[2] = Math.ceil(e[2]), r;
}
function Ke(r, e) {
  return r[0] = Math.floor(e[0]), r[1] = Math.floor(e[1]), r[2] = Math.floor(e[2]), r;
}
function Ze(r, e, n) {
  return r[0] = Math.min(e[0], n[0]), r[1] = Math.min(e[1], n[1]), r[2] = Math.min(e[2], n[2]), r;
}
function Je(r, e, n) {
  return r[0] = Math.max(e[0], n[0]), r[1] = Math.max(e[1], n[1]), r[2] = Math.max(e[2], n[2]), r;
}
function ue(r, e) {
  return r[0] = Math.round(e[0]), r[1] = Math.round(e[1]), r[2] = Math.round(e[2]), r;
}
function rn(r, e, n) {
  return r[0] = e[0] * n, r[1] = e[1] * n, r[2] = e[2] * n, r;
}
function en(r, e, n, a) {
  return r[0] = e[0] + n[0] * a, r[1] = e[1] + n[1] * a, r[2] = e[2] + n[2] * a, r;
}
function gr(r, e) {
  var n = e[0] - r[0], a = e[1] - r[1], i = e[2] - r[2];
  return Math.hypot(n, a, i);
}
function _r(r, e) {
  var n = e[0] - r[0], a = e[1] - r[1], i = e[2] - r[2];
  return n * n + a * a + i * i;
}
function yr(r) {
  var e = r[0], n = r[1], a = r[2];
  return e * e + n * n + a * a;
}
function nn(r, e) {
  return r[0] = -e[0], r[1] = -e[1], r[2] = -e[2], r;
}
function an(r, e) {
  return r[0] = 1 / e[0], r[1] = 1 / e[1], r[2] = 1 / e[2], r;
}
function u(r, e) {
  var n = e[0], a = e[1], i = e[2], t = n * n + a * a + i * i;
  return t > 0 && (t = 1 / Math.sqrt(t)), r[0] = e[0] * t, r[1] = e[1] * t, r[2] = e[2] * t, r;
}
function j(r, e) {
  return r[0] * e[0] + r[1] * e[1] + r[2] * e[2];
}
function W(r, e, n) {
  var a = e[0], i = e[1], t = e[2], s = n[0], c = n[1], v = n[2];
  return r[0] = i * v - t * c, r[1] = t * s - a * v, r[2] = a * c - i * s, r;
}
function tn(r, e, n, a) {
  var i = e[0], t = e[1], s = e[2];
  return r[0] = i + a * (n[0] - i), r[1] = t + a * (n[1] - t), r[2] = s + a * (n[2] - s), r;
}
function sn(r, e, n, a, i, t) {
  var s = t * t, c = s * (2 * t - 3) + 1, v = s * (t - 2) + t, l = s * (t - 1), h = s * (3 - 2 * t);
  return r[0] = e[0] * c + n[0] * v + a[0] * l + i[0] * h, r[1] = e[1] * c + n[1] * v + a[1] * l + i[1] * h, r[2] = e[2] * c + n[2] * v + a[2] * l + i[2] * h, r;
}
function cn(r, e, n, a, i, t) {
  var s = 1 - t, c = s * s, v = t * t, l = c * s, h = 3 * t * c, f = 3 * v * s, x = v * t;
  return r[0] = e[0] * l + n[0] * h + a[0] * f + i[0] * x, r[1] = e[1] * l + n[1] * h + a[1] * f + i[1] * x, r[2] = e[2] * l + n[2] * h + a[2] * f + i[2] * x, r;
}
function vn(r, e) {
  e = e || 1;
  var n = N() * 2 * Math.PI, a = N() * 2 - 1, i = Math.sqrt(1 - a * a) * e;
  return r[0] = Math.cos(n) * i, r[1] = Math.sin(n) * i, r[2] = a * e, r;
}
function ln(r, e, n) {
  var a = e[0], i = e[1], t = e[2], s = n[3] * a + n[7] * i + n[11] * t + n[15];
  return s = s || 1, r[0] = (n[0] * a + n[4] * i + n[8] * t + n[12]) / s, r[1] = (n[1] * a + n[5] * i + n[9] * t + n[13]) / s, r[2] = (n[2] * a + n[6] * i + n[10] * t + n[14]) / s, r;
}
function hn(r, e, n) {
  var a = e[0], i = e[1], t = e[2];
  return r[0] = a * n[0] + i * n[3] + t * n[6], r[1] = a * n[1] + i * n[4] + t * n[7], r[2] = a * n[2] + i * n[5] + t * n[8], r;
}
function fn(r, e, n) {
  var a = n[0], i = n[1], t = n[2], s = n[3], c = e[0], v = e[1], l = e[2], h = i * l - t * v, f = t * c - a * l, x = a * v - i * c, p = i * x - t * f, m = t * h - a * x, M = a * f - i * h, o = s * 2;
  return h *= o, f *= o, x *= o, p *= 2, m *= 2, M *= 2, r[0] = c + h + p, r[1] = v + f + m, r[2] = l + x + M, r;
}
function on(r, e, n, a) {
  var i = [], t = [];
  return i[0] = e[0] - n[0], i[1] = e[1] - n[1], i[2] = e[2] - n[2], t[0] = i[0], t[1] = i[1] * Math.cos(a) - i[2] * Math.sin(a), t[2] = i[1] * Math.sin(a) + i[2] * Math.cos(a), r[0] = t[0] + n[0], r[1] = t[1] + n[1], r[2] = t[2] + n[2], r;
}
function pn(r, e, n, a) {
  var i = [], t = [];
  return i[0] = e[0] - n[0], i[1] = e[1] - n[1], i[2] = e[2] - n[2], t[0] = i[2] * Math.sin(a) + i[0] * Math.cos(a), t[1] = i[1], t[2] = i[2] * Math.cos(a) - i[0] * Math.sin(a), r[0] = t[0] + n[0], r[1] = t[1] + n[1], r[2] = t[2] + n[2], r;
}
function xn(r, e, n, a) {
  var i = [], t = [];
  return i[0] = e[0] - n[0], i[1] = e[1] - n[1], i[2] = e[2] - n[2], t[0] = i[0] * Math.cos(a) - i[1] * Math.sin(a), t[1] = i[0] * Math.sin(a) + i[1] * Math.cos(a), t[2] = i[2], r[0] = t[0] + n[0], r[1] = t[1] + n[1], r[2] = t[2] + n[2], r;
}
function Mn(r, e) {
  var n = r[0], a = r[1], i = r[2], t = e[0], s = e[1], c = e[2], v = Math.sqrt(n * n + a * a + i * i), l = Math.sqrt(t * t + s * s + c * c), h = v * l, f = h && j(r, e) / h;
  return Math.acos(Math.min(Math.max(f, -1), 1));
}
function mn(r) {
  return r[0] = 0, r[1] = 0, r[2] = 0, r;
}
function dn(r) {
  return "vec3(" + r[0] + ", " + r[1] + ", " + r[2] + ")";
}
function gn(r, e) {
  return r[0] === e[0] && r[1] === e[1] && r[2] === e[2];
}
function _n(r, e) {
  var n = r[0], a = r[1], i = r[2], t = e[0], s = e[1], c = e[2];
  return Math.abs(n - t) <= R * Math.max(1, Math.abs(n), Math.abs(t)) && Math.abs(a - s) <= R * Math.max(1, Math.abs(a), Math.abs(s)) && Math.abs(i - c) <= R * Math.max(1, Math.abs(i), Math.abs(c));
}
var yn = Mr;
var wn = mr;
var Rn = dr;
var An = gr;
var En = _r;
var rr = xr;
var Sn = yr;
var Pn = function() {
  var r = B();
  return function(e, n, a, i, t, s) {
    var c, v;
    for (n || (n = 3), a || (a = 0), i ? v = Math.min(i * n + a, e.length) : v = e.length, c = a; c < v; c += n) r[0] = e[c], r[1] = e[c + 1], r[2] = e[c + 2], t(r, r, s), e[c] = r[0], e[c + 1] = r[1], e[c + 2] = r[2];
    return e;
  };
}();
function bn() {
  var r = new P2(4);
  return P2 != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 0), r;
}
function wr(r) {
  var e = new P2(4);
  return e[0] = r[0], e[1] = r[1], e[2] = r[2], e[3] = r[3], e;
}
function Rr(r, e, n, a) {
  var i = new P2(4);
  return i[0] = r, i[1] = e, i[2] = n, i[3] = a, i;
}
function Ar(r, e) {
  return r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r;
}
function Er(r, e, n, a, i) {
  return r[0] = e, r[1] = n, r[2] = a, r[3] = i, r;
}
function Sr(r, e, n) {
  return r[0] = e[0] + n[0], r[1] = e[1] + n[1], r[2] = e[2] + n[2], r[3] = e[3] + n[3], r;
}
function Pr(r, e, n) {
  return r[0] = e[0] * n, r[1] = e[1] * n, r[2] = e[2] * n, r[3] = e[3] * n, r;
}
function br(r) {
  var e = r[0], n = r[1], a = r[2], i = r[3];
  return Math.hypot(e, n, a, i);
}
function Lr(r) {
  var e = r[0], n = r[1], a = r[2], i = r[3];
  return e * e + n * n + a * a + i * i;
}
function Tr(r, e) {
  var n = e[0], a = e[1], i = e[2], t = e[3], s = n * n + a * a + i * i + t * t;
  return s > 0 && (s = 1 / Math.sqrt(s)), r[0] = n * s, r[1] = a * s, r[2] = i * s, r[3] = t * s, r;
}
function zr(r, e) {
  return r[0] * e[0] + r[1] * e[1] + r[2] * e[2] + r[3] * e[3];
}
function Ir2(r, e, n, a) {
  var i = e[0], t = e[1], s = e[2], c = e[3];
  return r[0] = i + a * (n[0] - i), r[1] = t + a * (n[1] - t), r[2] = s + a * (n[2] - s), r[3] = c + a * (n[3] - c), r;
}
function Xr(r, e) {
  return r[0] === e[0] && r[1] === e[1] && r[2] === e[2] && r[3] === e[3];
}
function Or(r, e) {
  var n = r[0], a = r[1], i = r[2], t = r[3], s = e[0], c = e[1], v = e[2], l = e[3];
  return Math.abs(n - s) <= R * Math.max(1, Math.abs(n), Math.abs(s)) && Math.abs(a - c) <= R * Math.max(1, Math.abs(a), Math.abs(c)) && Math.abs(i - v) <= R * Math.max(1, Math.abs(i), Math.abs(v)) && Math.abs(t - l) <= R * Math.max(1, Math.abs(t), Math.abs(l));
}
var ua = function() {
  var r = bn();
  return function(e, n, a, i, t, s) {
    var c, v;
    for (n || (n = 4), a || (a = 0), i ? v = Math.min(i * n + a, e.length) : v = e.length, c = a; c < v; c += n) r[0] = e[c], r[1] = e[c + 1], r[2] = e[c + 2], r[3] = e[c + 3], t(r, r, s), e[c] = r[0], e[c + 1] = r[1], e[c + 2] = r[2], e[c + 3] = r[3];
    return e;
  };
}();
function er() {
  var r = new P2(4);
  return P2 != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r[3] = 1, r;
}
function Tn(r) {
  return r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 1, r;
}
function Fr(r, e, n) {
  n = n * 0.5;
  var a = Math.sin(n);
  return r[0] = a * e[0], r[1] = a * e[1], r[2] = a * e[2], r[3] = Math.cos(n), r;
}
function zn(r, e) {
  var n = Math.acos(e[3]) * 2, a = Math.sin(n / 2);
  return a > R ? (r[0] = e[0] / a, r[1] = e[1] / a, r[2] = e[2] / a) : (r[0] = 1, r[1] = 0, r[2] = 0), n;
}
function In(r, e) {
  var n = kr(r, e);
  return Math.acos(2 * n * n - 1);
}
function Nr(r, e, n) {
  var a = e[0], i = e[1], t = e[2], s = e[3], c = n[0], v = n[1], l = n[2], h = n[3];
  return r[0] = a * h + s * c + i * l - t * v, r[1] = i * h + s * v + t * c - a * l, r[2] = t * h + s * l + a * v - i * c, r[3] = s * h - a * c - i * v - t * l, r;
}
function Xn(r, e, n) {
  n *= 0.5;
  var a = e[0], i = e[1], t = e[2], s = e[3], c = Math.sin(n), v = Math.cos(n);
  return r[0] = a * v + s * c, r[1] = i * v + t * c, r[2] = t * v - i * c, r[3] = s * v - a * c, r;
}
function On(r, e, n) {
  n *= 0.5;
  var a = e[0], i = e[1], t = e[2], s = e[3], c = Math.sin(n), v = Math.cos(n);
  return r[0] = a * v - t * c, r[1] = i * v + s * c, r[2] = t * v + a * c, r[3] = s * v - i * c, r;
}
function Fn(r, e, n) {
  n *= 0.5;
  var a = e[0], i = e[1], t = e[2], s = e[3], c = Math.sin(n), v = Math.cos(n);
  return r[0] = a * v + i * c, r[1] = i * v - a * c, r[2] = t * v + s * c, r[3] = s * v - t * c, r;
}
function Nn(r, e) {
  var n = e[0], a = e[1], i = e[2];
  return r[0] = n, r[1] = a, r[2] = i, r[3] = Math.sqrt(Math.abs(1 - n * n - a * a - i * i)), r;
}
function Vr(r, e) {
  var n = e[0], a = e[1], i = e[2], t = e[3], s = Math.sqrt(n * n + a * a + i * i), c = Math.exp(t), v = s > 0 ? c * Math.sin(s) / s : 0;
  return r[0] = n * v, r[1] = a * v, r[2] = i * v, r[3] = c * Math.cos(s), r;
}
function qr(r, e) {
  var n = e[0], a = e[1], i = e[2], t = e[3], s = Math.sqrt(n * n + a * a + i * i), c = s > 0 ? Math.atan2(s, t) / s : 0;
  return r[0] = n * c, r[1] = a * c, r[2] = i * c, r[3] = 0.5 * Math.log(n * n + a * a + i * i + t * t), r;
}
function Vn(r, e, n) {
  return qr(r, e), Yr(r, r, n), Vr(r, r), r;
}
function $(r, e, n, a) {
  var i = e[0], t = e[1], s = e[2], c = e[3], v = n[0], l = n[1], h = n[2], f = n[3], x, p, m, M, o;
  return p = i * v + t * l + s * h + c * f, p < 0 && (p = -p, v = -v, l = -l, h = -h, f = -f), 1 - p > R ? (x = Math.acos(p), m = Math.sin(x), M = Math.sin((1 - a) * x) / m, o = Math.sin(a * x) / m) : (M = 1 - a, o = a), r[0] = M * i + o * v, r[1] = M * t + o * l, r[2] = M * s + o * h, r[3] = M * c + o * f, r;
}
function qn(r) {
  var e = N(), n = N(), a = N(), i = Math.sqrt(1 - e), t = Math.sqrt(e);
  return r[0] = i * Math.sin(2 * Math.PI * n), r[1] = i * Math.cos(2 * Math.PI * n), r[2] = t * Math.sin(2 * Math.PI * a), r[3] = t * Math.cos(2 * Math.PI * a), r;
}
function Cn(r, e) {
  var n = e[0], a = e[1], i = e[2], t = e[3], s = n * n + a * a + i * i + t * t, c = s ? 1 / s : 0;
  return r[0] = -n * c, r[1] = -a * c, r[2] = -i * c, r[3] = t * c, r;
}
function Yn(r, e) {
  return r[0] = -e[0], r[1] = -e[1], r[2] = -e[2], r[3] = e[3], r;
}
function Cr(r, e) {
  var n = e[0] + e[4] + e[8], a;
  if (n > 0) a = Math.sqrt(n + 1), r[3] = 0.5 * a, a = 0.5 / a, r[0] = (e[5] - e[7]) * a, r[1] = (e[6] - e[2]) * a, r[2] = (e[1] - e[3]) * a;
  else {
    var i = 0;
    e[4] > e[0] && (i = 1), e[8] > e[i * 3 + i] && (i = 2);
    var t = (i + 1) % 3, s = (i + 2) % 3;
    a = Math.sqrt(e[i * 3 + i] - e[t * 3 + t] - e[s * 3 + s] + 1), r[i] = 0.5 * a, a = 0.5 / a, r[3] = (e[t * 3 + s] - e[s * 3 + t]) * a, r[t] = (e[t * 3 + i] + e[i * 3 + t]) * a, r[s] = (e[s * 3 + i] + e[i * 3 + s]) * a;
  }
  return r;
}
function kn(r, e, n, a) {
  var i = 0.5 * Math.PI / 180;
  e *= i, n *= i, a *= i;
  var t = Math.sin(e), s = Math.cos(e), c = Math.sin(n), v = Math.cos(n), l = Math.sin(a), h = Math.cos(a);
  return r[0] = t * v * h - s * c * l, r[1] = s * c * h + t * v * l, r[2] = s * v * l - t * c * h, r[3] = s * v * h + t * c * l, r;
}
function Dn(r) {
  return "quat(" + r[0] + ", " + r[1] + ", " + r[2] + ", " + r[3] + ")";
}
var Wn = wr;
var Un = Rr;
var Gn = Ar;
var Bn = Er;
var Hn = Sr;
var jn = Nr;
var Yr = Pr;
var kr = zr;
var $n = Ir2;
var Dr = br;
var Qn = Dr;
var Wr = Lr;
var Kn = Wr;
var nr = Tr;
var Zn = Xr;
var Jn = Or;
var un = function() {
  var r = B(), e = H(1, 0, 0), n = H(0, 1, 0);
  return function(a, i, t) {
    var s = j(i, t);
    return s < -0.999999 ? (W(r, e, i), rr(r) < 1e-6 && W(r, n, i), u(r, r), Fr(a, r, Math.PI), a) : s > 0.999999 ? (a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 1, a) : (W(r, i, t), a[0] = r[0], a[1] = r[1], a[2] = r[2], a[3] = 1 + s, nr(a, a));
  };
}();
var ra = function() {
  var r = er(), e = er();
  return function(n, a, i, t, s, c) {
    return $(r, a, s, c), $(e, i, t, c), $(n, r, e, 2 * c * (1 - c)), n;
  };
}();
var ea = function() {
  var r = sr();
  return function(e, n, a, i) {
    return r[0] = a[0], r[3] = a[1], r[6] = a[2], r[1] = i[0], r[4] = i[1], r[7] = i[2], r[2] = -n[0], r[5] = -n[1], r[8] = -n[2], nr(e, Cr(e, r));
  };
}();
var Q = {};
G(Q, { add: () => sa, angle: () => Pa, ceil: () => ca, clone: () => na, copy: () => ia, create: () => Ur, cross: () => ga, dist: () => Na, distance: () => jr, div: () => Fa, divide: () => Hr, dot: () => da, equals: () => za, exactEquals: () => Ta, floor: () => va, forEach: () => Ca, fromValues: () => aa, inverse: () => Ma, len: () => Ia, length: () => Qr, lerp: () => _a, max: () => ha, min: () => la, mul: () => Oa, multiply: () => Br, negate: () => xa, normalize: () => ma, random: () => ya, rotate: () => Sa, round: () => fa, scale: () => oa, scaleAndAdd: () => pa, set: () => ta, sqrDist: () => Va, sqrLen: () => qa, squaredDistance: () => $r, squaredLength: () => Kr, str: () => La, sub: () => Xa, subtract: () => Gr, transformMat2: () => wa, transformMat2d: () => Ra, transformMat3: () => Aa, transformMat4: () => Ea, zero: () => ba });
function Ur() {
  var r = new P2(2);
  return P2 != Float32Array && (r[0] = 0, r[1] = 0), r;
}
function na(r) {
  var e = new P2(2);
  return e[0] = r[0], e[1] = r[1], e;
}
function aa(r, e) {
  var n = new P2(2);
  return n[0] = r, n[1] = e, n;
}
function ia(r, e) {
  return r[0] = e[0], r[1] = e[1], r;
}
function ta(r, e, n) {
  return r[0] = e, r[1] = n, r;
}
function sa(r, e, n) {
  return r[0] = e[0] + n[0], r[1] = e[1] + n[1], r;
}
function Gr(r, e, n) {
  return r[0] = e[0] - n[0], r[1] = e[1] - n[1], r;
}
function Br(r, e, n) {
  return r[0] = e[0] * n[0], r[1] = e[1] * n[1], r;
}
function Hr(r, e, n) {
  return r[0] = e[0] / n[0], r[1] = e[1] / n[1], r;
}
function ca(r, e) {
  return r[0] = Math.ceil(e[0]), r[1] = Math.ceil(e[1]), r;
}
function va(r, e) {
  return r[0] = Math.floor(e[0]), r[1] = Math.floor(e[1]), r;
}
function la(r, e, n) {
  return r[0] = Math.min(e[0], n[0]), r[1] = Math.min(e[1], n[1]), r;
}
function ha(r, e, n) {
  return r[0] = Math.max(e[0], n[0]), r[1] = Math.max(e[1], n[1]), r;
}
function fa(r, e) {
  return r[0] = Math.round(e[0]), r[1] = Math.round(e[1]), r;
}
function oa(r, e, n) {
  return r[0] = e[0] * n, r[1] = e[1] * n, r;
}
function pa(r, e, n, a) {
  return r[0] = e[0] + n[0] * a, r[1] = e[1] + n[1] * a, r;
}
function jr(r, e) {
  var n = e[0] - r[0], a = e[1] - r[1];
  return Math.hypot(n, a);
}
function $r(r, e) {
  var n = e[0] - r[0], a = e[1] - r[1];
  return n * n + a * a;
}
function Qr(r) {
  var e = r[0], n = r[1];
  return Math.hypot(e, n);
}
function Kr(r) {
  var e = r[0], n = r[1];
  return e * e + n * n;
}
function xa(r, e) {
  return r[0] = -e[0], r[1] = -e[1], r;
}
function Ma(r, e) {
  return r[0] = 1 / e[0], r[1] = 1 / e[1], r;
}
function ma(r, e) {
  var n = e[0], a = e[1], i = n * n + a * a;
  return i > 0 && (i = 1 / Math.sqrt(i)), r[0] = e[0] * i, r[1] = e[1] * i, r;
}
function da(r, e) {
  return r[0] * e[0] + r[1] * e[1];
}
function ga(r, e, n) {
  var a = e[0] * n[1] - e[1] * n[0];
  return r[0] = r[1] = 0, r[2] = a, r;
}
function _a(r, e, n, a) {
  var i = e[0], t = e[1];
  return r[0] = i + a * (n[0] - i), r[1] = t + a * (n[1] - t), r;
}
function ya(r, e) {
  e = e || 1;
  var n = N() * 2 * Math.PI;
  return r[0] = Math.cos(n) * e, r[1] = Math.sin(n) * e, r;
}
function wa(r, e, n) {
  var a = e[0], i = e[1];
  return r[0] = n[0] * a + n[2] * i, r[1] = n[1] * a + n[3] * i, r;
}
function Ra(r, e, n) {
  var a = e[0], i = e[1];
  return r[0] = n[0] * a + n[2] * i + n[4], r[1] = n[1] * a + n[3] * i + n[5], r;
}
function Aa(r, e, n) {
  var a = e[0], i = e[1];
  return r[0] = n[0] * a + n[3] * i + n[6], r[1] = n[1] * a + n[4] * i + n[7], r;
}
function Ea(r, e, n) {
  var a = e[0], i = e[1];
  return r[0] = n[0] * a + n[4] * i + n[12], r[1] = n[1] * a + n[5] * i + n[13], r;
}
function Sa(r, e, n, a) {
  var i = e[0] - n[0], t = e[1] - n[1], s = Math.sin(a), c = Math.cos(a);
  return r[0] = i * c - t * s + n[0], r[1] = i * s + t * c + n[1], r;
}
function Pa(r, e) {
  var n = r[0], a = r[1], i = e[0], t = e[1], s = Math.sqrt(n * n + a * a) * Math.sqrt(i * i + t * t), c = s && (n * i + a * t) / s;
  return Math.acos(Math.min(Math.max(c, -1), 1));
}
function ba(r) {
  return r[0] = 0, r[1] = 0, r;
}
function La(r) {
  return "vec2(" + r[0] + ", " + r[1] + ")";
}
function Ta(r, e) {
  return r[0] === e[0] && r[1] === e[1];
}
function za(r, e) {
  var n = r[0], a = r[1], i = e[0], t = e[1];
  return Math.abs(n - i) <= R * Math.max(1, Math.abs(n), Math.abs(i)) && Math.abs(a - t) <= R * Math.max(1, Math.abs(a), Math.abs(t));
}
var Ia = Qr;
var Xa = Gr;
var Oa = Br;
var Fa = Hr;
var Na = jr;
var Va = $r;
var qa = Kr;
var Ca = function() {
  var r = Ur();
  return function(e, n, a, i, t, s) {
    var c, v;
    for (n || (n = 2), a || (a = 0), i ? v = Math.min(i * n + a, e.length) : v = e.length, c = a; c < v; c += n) r[0] = e[c], r[1] = e[c + 1], t(r, r, s), e[c] = r[0], e[c + 1] = r[1];
    return e;
  };
}();
var _s, _l, _e2, _n2, _i, _o, _t, _a2, _r2, _h, _v, _c, _K_instances, f_fn, p_fn, m_fn, d_fn, _a3;
var K = (_a3 = class extends Ce {
  constructor(e, n = "webgl", a) {
    super();
    __privateAdd(this, _K_instances);
    __privateAdd(this, _s);
    __privateAdd(this, _l, null);
    __privateAdd(this, _e2, null);
    __privateAdd(this, _n2, null);
    __privateAdd(this, _i, null);
    __publicField(this, "screen_distance", 25);
    __publicField(this, "scale_factor", 1);
    __publicField(this, "fake_alpha_enabled", false);
    __publicField(this, "fake_alpha_scale", 1);
    __privateAdd(this, _o, O.fromValues(0, 0, -1));
    __privateAdd(this, _t, O.create());
    __privateAdd(this, _a2, D.create());
    __privateAdd(this, _r2, Q.create());
    __privateAdd(this, _h, O.create());
    __privateAdd(this, _v, U.create());
    __privateAdd(this, _c, O.create());
    let i = e.getContext(n, a);
    if (i === null) throw new Error(`Cannot create a ${n} context from canvas`);
    __privateSet(this, _s, i), __privateMethod(this, _K_instances, p_fn).call(this), __privateMethod(this, _K_instances, m_fn).call(this), __privateMethod(this, _K_instances, d_fn).call(this);
  }
  get native() {
    return __privateGet(this, _s);
  }
  set frame_buffer(e) {
    __privateSet(this, _n2, e);
  }
  drawFrameSection({ frame_section: e }) {
    __privateSet(this, _i, e);
  }
  get meta_data() {
    var _a6;
    return ((_a6 = __privateGet(this, _i)) == null ? void 0 : _a6.meta_data) || null;
  }
  drawXRFrame({ xr_views: e, xr_viewports: n, frame_camera_transforms: a }) {
    if (!__privateGet(this, _i)) return;
    let i = __privateGet(this, _s);
    __privateGet(this, _n2) !== null && i.bindFramebuffer(i.FRAMEBUFFER, __privateGet(this, _n2)), i.clearColor(0, 0, 0, 0), i.clear(i.COLOR_BUFFER_BIT | i.DEPTH_BUFFER_BIT), i.enable(i.BLEND), i.blendFunc(i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA);
    let t = i.getUniformLocation(__privateGet(this, _e2), "size"), s = i.getUniformLocation(__privateGet(this, _e2), "offset"), c = i.getUniformLocation(__privateGet(this, _e2), "viewMatrix"), v = i.getUniformLocation(__privateGet(this, _e2), "viewOffset"), l = i.getUniformLocation(__privateGet(this, _e2), "projectionMatrix"), h = i.getUniformLocation(__privateGet(this, _e2), "billboardMatrix"), f = i.getUniformLocation(__privateGet(this, _e2), "fakeAlphaEnabled"), x = i.getUniformLocation(__privateGet(this, _e2), "fakeAlphaScale");
    i.activeTexture(i.TEXTURE0), i.bindTexture(i.TEXTURE_2D, __privateGet(this, _l)), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, i.RGBA, i.UNSIGNED_BYTE, __privateGet(this, _i).pixels);
    let p = Math.atan(1 / e[0].projectionMatrix[5]) * 2, m = n[0].width / n[0].height, M = this.scale_factor * this.screen_distance * Math.tan(p * 0.5), o = M * m, d = __privateGet(this, _i).section.width / e.length, A = __privateGet(this, _i).section.height;
    i.uniform2fv(t, [d, A]);
    let w = n.reduce((g, { width: _ }) => g + _, 0);
    for (let g = 0; g < e.length; g++) {
      let _ = e[g], y = n[g], S = a[g];
      O.set(__privateGet(this, _h), S.position[0], S.position[1], S.position[2]), U.set(__privateGet(this, _v), S.orientation[0], S.orientation[1], S.orientation[2], S.orientation[3]), O.transformQuat(__privateGet(this, _c), __privateGet(this, _o), __privateGet(this, _v)), O.scaleAndAdd(__privateGet(this, _t), __privateGet(this, _h), __privateGet(this, _c), this.screen_distance), __privateGet(this, _r2)[0] = _.projectionMatrix[8], __privateGet(this, _r2)[1] = _.projectionMatrix[9];
      let b = __privateMethod(this, _K_instances, f_fn).call(this, __privateGet(this, _t), o, M);
      i.uniform2fv(v, __privateGet(this, _r2)), i.viewport(y.x, y.y, y.width, y.height), i.uniformMatrix4fv(c, false, _.transform.inverse.matrix), i.uniformMatrix4fv(l, false, _.projectionMatrix), i.uniformMatrix4fv(h, false, b), i.uniform1i(f, this.fake_alpha_enabled ? 1 : 0), i.uniform1f(x, this.fake_alpha_scale);
      let L = y.x / w, T = __privateGet(this, _i).section.left + L * __privateGet(this, _i).section.width;
      i.uniform2fv(s, [T, __privateGet(this, _i).section.top]), i.drawArrays(i.TRIANGLE_STRIP, 0, 4);
    }
  }
  refreshSize() {
  }
  release() {
    let e = __privateGet(this, _s);
    e.clear(e.COLOR_BUFFER_BIT | e.DEPTH_BUFFER_BIT), e.bindFramebuffer(e.FRAMEBUFFER, null);
  }
}, _s = new WeakMap(), _l = new WeakMap(), _e2 = new WeakMap(), _n2 = new WeakMap(), _i = new WeakMap(), _o = new WeakMap(), _t = new WeakMap(), _a2 = new WeakMap(), _r2 = new WeakMap(), _h = new WeakMap(), _v = new WeakMap(), _c = new WeakMap(), _K_instances = new WeakSet(), f_fn = function(e, n, a) {
  return D.fromRotationTranslationScale(__privateGet(this, _a2), __privateGet(this, _v), e, O.fromValues(n, a, 1)), __privateGet(this, _a2);
}, p_fn = function() {
  let e = __privateGet(this, _s), n = `
            attribute vec2 position;
            varying vec2 texCoord;

            uniform mat4 viewMatrix;
            uniform mat4 projectionMatrix;
            uniform vec2 scale;
            uniform mat4 billboardMatrix;

            uniform vec2 size;
            uniform vec2 offset;
            uniform vec2 viewOffset;

            void main() {
                texCoord = (position + 1.0) * 0.5;
                texCoord.y = 1.0 - texCoord.y;
                texCoord = size * texCoord + offset;
                gl_Position = projectionMatrix * viewMatrix * billboardMatrix * vec4(position + viewOffset, 0.0, 1.0);
            }`, a = e.createShader(e.VERTEX_SHADER);
  e.shaderSource(a, n), e.compileShader(a), e.getShaderParameter(a, e.COMPILE_STATUS) || console.error("Vertex shader failed to compile: " + e.getShaderInfoLog(a));
  let i = `
            precision mediump float;
            varying vec2 texCoord;
            uniform sampler2D texture;
            uniform int fakeAlphaEnabled;
            uniform float fakeAlphaScale;

            float luminance(vec3 color) {
                // sRGB luminance approximation
                return dot(color, vec3(0.299, 0.587, 0.114));
            }

            void main() {
                gl_FragColor = texture2D(texture, texCoord);
                if(fakeAlphaEnabled == 1) {
                    // Use luminance to determine alpha so values close to dark are transparent and smoothly fade
                    // to prevent noise around object's edges
                    float luma = luminance(gl_FragColor.rgb);
                    float alpha = smoothstep(0.02, 0.1, luma);
                    gl_FragColor.a = alpha;

                    // remap [0..1]  [0..fakeAlphaScale] to see through opaque objects in AR
                    if(fakeAlphaScale < 1.0) {
                        gl_FragColor.a *= fakeAlphaScale;
                    }

                    // Premultiply RGB by alpha to avoid color bleeding on transparent edges
                    // (required for correct blending in compositing / XR rendering)
                    gl_FragColor.rgb *= alpha;
                }
            }`, t = e.createShader(e.FRAGMENT_SHADER);
  e.shaderSource(t, i), e.compileShader(t), e.getShaderParameter(t, e.COMPILE_STATUS) || console.error("Fragment shader failed to compile: " + e.getShaderInfoLog(t));
  let s = e.createProgram();
  e.attachShader(s, a), e.attachShader(s, t), e.linkProgram(s), e.useProgram(s), e.getProgramParameter(s, e.LINK_STATUS) || console.error("Program failed to compile: " + e.getProgramInfoLog(s)), e.useProgram(s), __privateSet(this, _e2, s);
}, m_fn = function() {
  let e = __privateGet(this, _s), n = e.createBuffer(), a = new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]);
  e.bindBuffer(e.ARRAY_BUFFER, n), e.bufferData(e.ARRAY_BUFFER, a, e.STATIC_DRAW);
  let i = e.getAttribLocation(__privateGet(this, _e2), "position");
  e.enableVertexAttribArray(i), e.vertexAttribPointer(i, 2, e.FLOAT, false, 0, 0);
}, d_fn = function() {
  let e = __privateGet(this, _s);
  __privateSet(this, _l, e.createTexture()), e.bindTexture(e.TEXTURE_2D, __privateGet(this, _l)), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.bindTexture(e.TEXTURE_2D, null);
  let n = e.getUniformLocation(__privateGet(this, _e2), "texture");
  e.uniform1i(n, 0);
}, _a3);
function Ga() {
  let r, e;
  return { promise: new Promise((a, i) => {
    r = a, e = i;
  }), resolve: r, reject: e };
}
var _s2, _l2, _e3, _n3, _i2, _o2, _t2, _a5, _r3, _h2, _v4, _c2, _f, _p, _r_instances, m_fn2, d_fn2, _x2, _M, _g, y_fn, w_fn, R_fn, __fn, A_fn, _a4;
var Z = (_a4 = class {
  constructor(e = 1) {
    __privateAdd(this, _r_instances);
    __publicField(this, "cameras_origin", null);
    __privateAdd(this, _s2);
    __privateAdd(this, _l2);
    __privateAdd(this, _e3, null);
    __privateAdd(this, _n3);
    __privateAdd(this, _i2);
    __privateAdd(this, _o2);
    __privateAdd(this, _t2, []);
    __privateAdd(this, _a5);
    __privateAdd(this, _r3, null);
    __privateAdd(this, _h2, "inline");
    __privateAdd(this, _v4, false);
    __privateAdd(this, _c2, null);
    __privateAdd(this, _f, []);
    __privateAdd(this, _p, 0);
    __privateAdd(this, _x2, (e) => {
      if (!this.cameras_origin) return;
      let n = new Vector3().fromArray(this.cameras_origin.position), a = new Quaternion().fromArray(this.cameras_origin.orientation), i = new Vector3().fromArray(this.cameras_origin.scale), t = new Matrix4().compose(n, a, i).invert(), s = a.conjugate();
      for (let c of e) {
        let { position: v, orientation: l } = c.global_transform, h = new Vector3().fromArray(v);
        h.applyMatrix4(t), h.toArray(v);
        let f = new Quaternion().fromArray(l);
        new Quaternion().multiplyQuaternions(s, f).toArray(l);
      }
    });
    __privateAdd(this, _M, (e) => {
      if (!this.cameras_origin) return;
      let n = new Vector3().fromArray(this.cameras_origin.position), a = new Quaternion().fromArray(this.cameras_origin.orientation), i = new Vector3().fromArray(this.cameras_origin.scale), t = new Matrix4().compose(n, a, i);
      for (let s of e) {
        let { position: c, orientation: v } = s, l = new Vector3().fromArray(c);
        l.applyMatrix4(t), l.toArray(c);
        let h = new Quaternion().fromArray(v);
        new Quaternion().multiplyQuaternions(a, h).toArray(v);
      }
    });
    __privateAdd(this, _g, (e, n) => {
      var _a6;
      let a = __privateGet(this, _r3), i = a.renderState.baseLayer, t = (_a6 = n.getViewerPose(__privateGet(this, _c2))) == null ? void 0 : _a6.views;
      if (!t) {
        a.requestAnimationFrame(__privateGet(this, _g));
        return;
      }
      let s = [...t], c = [];
      s.forEach((l) => {
        c.push(i.getViewport(l));
      }), __privateGet(this, _v4) && (s = s.splice(0, 1), c = c.splice(0, 1)), __privateMethod(this, _r_instances, A_fn).call(this, c) && (console.error("XRViewports have changed, ending the XRSession"), a.end()), __privateMethod(this, _r_instances, y_fn).call(this, s), __privateGet(this, _x2).call(this, __privateGet(this, _n3).cameras);
      let v = c.map((l, h) => {
        let f = __privateGet(this, _n3).viewports[h], { world_position: x, world_orientation: p } = f.camera_projection;
        return { position: Array.from(x), orientation: Array.from(p) };
      });
      __privateGet(this, _M).call(this, v), __privateGet(this, _a5).drawXRFrame({ xr_views: s, xr_viewports: c, frame_camera_transforms: v }), a.requestAnimationFrame(__privateGet(this, _g));
    });
    __privateSet(this, _n3, new ls({ width: window.innerWidth, height: window.innerHeight, context_constructor: K, context_type: "webgl", context_options: { xrCompatible: true }, resolution_scale: e })), __privateSet(this, _a5, __privateGet(this, _n3).context), __privateSet(this, _s2, __privateGet(this, _x2)), __privateSet(this, _l2, __privateGet(this, _M));
  }
  static async isSessionSupported(e) {
    if (!navigator.xr) return false;
    let n = navigator.xr.isSessionSupported || navigator.xr.supportsSession;
    return n ? await n.call(navigator.xr, e).catch(console.warn) ?? false : false;
  }
  get session() {
    return __privateGet(this, _r3);
  }
  get mode() {
    return __privateGet(this, _h2);
  }
  get reference_space() {
    return __privateGet(this, _c2);
  }
  get is_stereo_vision() {
    return __privateGet(this, _f).length === 2;
  }
  set overriden_near_plane(e) {
    __privateSet(this, _i2, e);
  }
  set cameras_origin_transform_enabled(e) {
    e ? (__privateSet(this, _x2, __privateGet(this, _s2)), __privateSet(this, _M, __privateGet(this, _l2))) : (__privateSet(this, _x2, () => {
    }), __privateSet(this, _M, () => {
    }));
  }
  async release() {
    if (__privateGet(this, _r3) && (this.stop(), await __privateGet(this, _r3).end().catch((e) => console.warn("Could not end XR session:", e))), __privateGet(this, _e3)) for (let { livelink_viewport: e } of __privateGet(this, _t2)) __privateGet(this, _e3).removeViewport({ viewport: e });
    __privateGet(this, _n3).release();
  }
  get fakeAlpha() {
    return __privateGet(this, _a5).fake_alpha_enabled;
  }
  set fakeAlpha(e) {
    __privateGet(this, _a5).fake_alpha_enabled = e;
  }
  get fakeAlphaScale() {
    return __privateGet(this, _a5).fake_alpha_scale;
  }
  set fakeAlphaScale(e) {
    if (e < 0 || e > 1) throw new Error("Fake alpha scale must be between 0 and 1");
    __privateGet(this, _a5).fake_alpha_scale = e;
  }
  async initialize(e, { xrSessionInit: n = {}, forceSingleView: a = false }) {
    var _a6;
    if (__privateSet(this, _h2, e), __privateSet(this, _v4, a), !_a4.isSessionSupported(e)) throw new Error(`WebXR "${e}" not supported`);
    __privateGet(this, _r3) && (console.warn("Releasing previous XR session"), await this.release());
    let i = ["local-floor", "local"], t;
    for (let s of i) {
      let c = s ? { ...n, requiredFeatures: [...n.requiredFeatures || [], s] } : n;
      try {
        __privateSet(this, _r3, await navigator.xr.requestSession(e, c)), await this.updateRenderState(), await this.setReferenceSpaceType(s);
        break;
      } catch (v) {
        console.warn("Failed to request XR session", { spaceType: s, requiredFeatures: c.requiredFeatures }, v), (_a6 = __privateGet(this, _r3)) == null ? void 0 : _a6.end(), t = v;
      }
    }
    if (!__privateGet(this, _r3)) throw t;
    return __privateGet(this, _r3);
  }
  async configureViewports({ livelink: e, overscan_fov_factor: n, enable_overscan_surface_scale: a, enable_fake_alpha: i }) {
    __privateGet(this, _e3) && this.releaseLivelinkViewports(), __privateSet(this, _e3, e);
    let t = await __privateMethod(this, _r_instances, m_fn2).call(this);
    t.length > 2 && console.error("WebXRHelper doesn't support more than 2 eyes yet"), __privateMethod(this, _r_instances, w_fn).call(this, t), __privateMethod(this, _r_instances, d_fn2).call(this, { xr_views: t, fov_factor: n, enable_surface_scale: a });
    let s = __privateGet(this, _h2) === "immersive-ar";
    this.fakeAlpha = i ?? s;
    let c = s ? { grid: false, displayBackground: false } : void 0;
    __privateGet(this, _e3).addViewports({ viewports: __privateGet(this, _t2).map(({ livelink_viewport: v }) => v) });
    for (let v in __privateGet(this, _t2)) {
      let { xr_view: l, xr_viewport: h, livelink_viewport: f } = __privateGet(this, _t2)[v];
      await __privateMethod(this, _r_instances, R_fn).call(this, { index: v, xr_view: l, xr_viewport: h, viewport: f, dataJSON: c });
    }
  }
  start() {
    __privateGet(this, _r3).requestAnimationFrame(__privateGet(this, _g));
  }
  stop() {
    __privateGet(this, _p) && __privateGet(this, _r3) && __privateGet(this, _r3).cancelAnimationFrame(__privateGet(this, _p));
  }
  async setReferenceSpaceType(e = "local") {
    return __privateSet(this, _c2, await __privateGet(this, _r3).requestReferenceSpace(e).catch(async (n) => {
      throw console.error(`Failed to request XR reference space of type ${e}:`, n), n;
    })), __privateGet(this, _c2);
  }
  async updateRenderState(e = {}) {
    let n = __privateGet(this, _r3), a = new XRWebGLLayer(n, __privateGet(this, _a5).native, e);
    await n.updateRenderState({ baseLayer: a }), __privateGet(this, _a5).frame_buffer = a.framebuffer, __privateGet(this, _n3).resize(a.framebufferWidth, a.framebufferHeight);
  }
  releaseLivelinkViewports() {
    for (let e of __privateGet(this, _t2)) __privateGet(this, _n3).removeViewport({ viewport: e.livelink_viewport });
    __privateGet(this, _t2).length = 0;
  }
  get resolution_scale() {
    return __privateGet(this, _n3).resolution_scale;
  }
  set resolution_scale(e) {
    __privateGet(this, _n3).resolution_scale = e;
  }
}, _s2 = new WeakMap(), _l2 = new WeakMap(), _e3 = new WeakMap(), _n3 = new WeakMap(), _i2 = new WeakMap(), _o2 = new WeakMap(), _t2 = new WeakMap(), _a5 = new WeakMap(), _r3 = new WeakMap(), _h2 = new WeakMap(), _v4 = new WeakMap(), _c2 = new WeakMap(), _f = new WeakMap(), _p = new WeakMap(), _r_instances = new WeakSet(), m_fn2 = function() {
  let { promise: e, resolve: n, reject: a } = Ga(), i = 200, t = async (s, c) => {
    var _a6;
    let v = (_a6 = c.getViewerPose(__privateGet(this, _c2))) == null ? void 0 : _a6.views;
    if (!v) {
      --i > 0 ? __privateGet(this, _r3).requestAnimationFrame(t) : a(new Error("Failed to get XR views."));
      return;
    }
    __privateGet(this, _v4) && v.length > 1 ? (console.log("WebXRHelper: forcing single view"), n(v.slice(0, 1))) : n(v);
  };
  return __privateSet(this, _p, __privateGet(this, _r3).requestAnimationFrame(t)), e;
}, d_fn2 = function({ xr_views: e, fov_factor: n = 1.5, enable_surface_scale: a = true }) {
  if (n === 1) return;
  a ? (__privateGet(this, _n3).resolution_scale = n, __privateGet(this, _a5).scale_factor = __privateGet(this, _n3).resolution_scale) : __privateGet(this, _a5).scale_factor = n;
  let i = e[0].projectionMatrix[5], t = 2 * Math.atan(1 / i), s = 2 * Math.atan(Math.tan(t / 2) * n);
  __privateSet(this, _o2, s * (180 / Math.PI)), t * (180 / Math.PI), `${__privateGet(this, _o2)}${__privateGet(this, _a5).scale_factor}${__privateGet(this, _n3).resolution_scale}`;
}, _x2 = new WeakMap(), _M = new WeakMap(), _g = new WeakMap(), y_fn = function(e) {
  __privateGet(this, _n3).cameras.forEach((n, a) => {
    let i = e[a], { position: t, orientation: s } = i.transform, { livelink_viewport: c } = __privateGet(this, _t2)[a], v = [t.x, t.y, t.z], l = [s.x, s.y, s.z, s.w];
    n.local_transform = { position: v, orientation: l };
    let h = __privateMethod(this, _r_instances, __fn).call(this, i.projectionMatrix, c.width, c.height), { fovy: f, nearPlane: x, farPlane: p, offset: m } = h;
    (!n.perspective_lens || n.perspective_lens.fovy !== f || n.perspective_lens.nearPlane !== x || n.perspective_lens.farPlane !== p || n.perspective_lens.offset !== m) && (n.perspective_lens = h);
  });
}, w_fn = function(e) {
  let n = __privateGet(this, _r3).renderState.baseLayer, a = e.map((s) => ({ view: s, viewport: n.getViewport(s) })), i = a.map((s) => s.viewport);
  __privateSet(this, _f, i);
  let t = a.every(({ viewport: s }) => s.x <= 1 && s.y <= 1 && s.width <= 1 && s.height <= 1);
  for (let s of a) {
    let c = s.viewport, v = new dt(t ? { left: c.x, top: c.y, width: c.width, height: c.height } : { left: c.x / n.framebufferWidth, top: c.y / n.framebufferHeight, width: c.width / n.framebufferWidth, height: c.height / n.framebufferHeight });
    `${s.view.eye}`;
    let l = new Ir({ core: __privateGet(this, _e3), rendering_surface: __privateGet(this, _n3), options: { rect: v } });
    __privateGet(this, _t2).push({ xr_view: s.view, xr_viewport: c, livelink_viewport: l });
  }
}, R_fn = async function({ index: e, xr_view: n, xr_viewport: a, viewport: i, dataJSON: t }) {
  var _a6;
  let s = await __privateGet(this, _e3).scene.newEntity({ name: `XR_camera_${n.eye}_${e}`, components: { local_transform: {}, perspective_lens: __privateMethod(this, _r_instances, __fn).call(this, n.projectionMatrix, i.width, i.height), camera: { renderGraphRef: "398ee642-030a-45e7-95df-7147f6c43392", dataJSON: t }, tags: { value: [`viewport_x = ${a.x.toString()}`, `viewport_y = ${a.y.toString()}`, `viewport_width = ${a.width.toString()}`, `viewport_height = ${a.height.toString()}`, `recommanded_scale = ${((_a6 = n.recommendedViewportScale) == null ? void 0 : _a6.toString()) || "?"}`] } }, options: { delete_on_client_disconnection: true, auto_broadcast: false } });
  i.camera_projection = new es({ camera_entity: s, viewport: i }), `${n.eye}`;
}, __fn = function(e, n, a) {
  let i = n / a, t = __privateGet(this, _o2) ?? Math.atan(1 / e[5]) * (180 / Math.PI) * 2, s = e[14] / (e[10] - 1);
  this.is_stereo_vision && this.cameras_origin && this.cameras_origin.scale[0] !== 1 && (s *= 1 / this.cameras_origin.scale[0]);
  let c = e[14] / (e[10] + 1), v = [e[8], e[9] * -1];
  return { fovy: t, aspectRatio: i, nearPlane: __privateGet(this, _i2) || s, farPlane: c, offset: v };
}, A_fn = function(e) {
  return __privateGet(this, _f).length === 0 ? true : e.some((n, a) => {
    let i = __privateGet(this, _f)[a];
    return i ? i.width !== n.width || i.height !== n.height || i.x !== n.x || i.y !== n.y : true;
  });
}, _a4);
var Ka = (0, import_react.createContext)({ webXRHelper: null, xrSession: null });
function wi({ children: r, mode: e, resolutionScale: n = 1, requiredFeatures: a = [], optionalFeatures: i = [], forceSingleView: t, overscanFovFactor: s, enableOverscanSurfaceScale: c, enableFakeAlpha: v, domOverlayRoot: l, onSessionEnd: h }) {
  let { instance: f } = (0, import_react.useContext)(P), x = (0, import_react.useRef)(null), p = (0, import_react.useMemo)(() => new Z(n), [e, a.join("-"), i.join("-"), t, l]), m = (0, import_react.useRef)(null), [M, o] = (0, import_react.useState)(null);
  return (0, import_react.useEffect)(() => {
    p && (p.resolution_scale = n);
  }, [p, n]), (0, import_react.useEffect)(() => {
    if (!(!M || !h)) return M.addEventListener("end", h), () => {
      M.removeEventListener("end", h);
    };
  }, [M, h]), (0, import_react.useEffect)(() => {
    let d = l || x.current;
    if (!(!d || !f)) return m.current || (m.current = p.initialize(e, { xrSessionInit: { requiredFeatures: a, optionalFeatures: ["dom-overlay", ...i], domOverlay: { root: d } }, forceSingleView: t }).then((A) => (o(A), p.configureViewports({ livelink: f, overscan_fov_factor: s, enable_overscan_surface_scale: c, enable_fake_alpha: v }))).then(() => {
      p.start(), m.current = null;
    })), () => {
      p.release(), o(null);
    };
  }, [p, f]), import_react.default.createElement(Ka.Provider, { value: { webXRHelper: p, xrSession: M } }, l ? import_react.default.createElement(import_react.default.Fragment, null, r) : import_react.default.createElement("div", { "data-role": "webxr-dom-overlay", ref: x }, r));
}
typeof window < "u" && (window.__LIVELINK__ || (window.__LIVELINK__ = {}), Object.prototype.hasOwnProperty.call(window.__LIVELINK__, "@3dverse/livelink-webxr") ? console.warn(" WARNING  Multiple instances of Livelink WebXR being imported.") : window.__LIVELINK__["@3dverse/livelink-webxr"] = "0.1.12");
export {
  wi as WebXR,
  Ka as WebXRContext,
  Z as WebXRHelper
};
//# sourceMappingURL=@3dverse_livelink-webxr.js.map
